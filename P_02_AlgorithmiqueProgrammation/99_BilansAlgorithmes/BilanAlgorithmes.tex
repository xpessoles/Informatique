\documentclass[10pt]{article}
\input{style/coursHeadings}
\input{style/programHeadings}
\input{style/macros_SII}
\input{style/macros_Titres}
\input{style/macros_Frames}

%Si le boolen xp est vrai : compilation pour xabi
%Sinon compilation Damien
\newboolean{xp}
\setboolean{xp}{true}

\newboolean{prof}
\setboolean{prof}{true}

\usepackage[%
    pdftitle={CI 2 - Algorithmique - Bilan},
    pdfauthor={Xavier Pessoles},
    colorlinks=true,
    linkcolor=blue,
    citecolor=magenta]{hyperref}


\def\discipline{Informatique}
\def\xxtitre{\ifthenelse{\boolean{xp}}{
CI 2 : Algorithmique \& Programmation}{
Chapitre  -- }}

\def\xxsoustitre{\ifthenelse{\boolean{xp}}{
Algorithmes d'Informatique}{
Partie  -- }}

\def\xxauteur{\ifthenelse{\boolean{xp}}{
Xavier \textsc{Pessoles} }{
}}

\def\xxpied{\ifthenelse{\boolean{xp}}{
CI 2 : Algorithmique \& Programmation\\
Bilan Algorithmes}{
\xxtitre}}

\def\xxcathegorie{\ifthenelse{\boolean{xp}}{
2013 -- 2014 \\
Xavier \textsc{Pessoles}}{
Informatique - Cours}}





%---------------------------------------------------------------------------


\begin{document}

\ifthenelse{\boolean{xp}}{\input{style/enteteXP}}{\input{style/enteteDI}}


\setlength{\parskip}{0ex plus 0.2ex minus 0ex}
 \renewcommand{\contentsname}{}
 \renewcommand{\baselinestretch}{1}

\tableofcontents

 \renewcommand{\baselinestretch}{1.2}
\setlength{\parskip}{2ex plus 0.5ex minus 0.2ex}

\newpage


\section{Recherches dans une liste}
\subsection{Recherche d'un nombre dans une liste}

%\subsubsection{Algorithme naïf}

\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Recherche naïve d'un nombre dans une liste triée ou non \\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{n}, int : un entier 
\item \textsf{tab}, liste : une liste d'entiers triés ou non triés
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item un booléen : \textsf{Vrai} si le nombre est dans la liste, \textsf{Faux} sinon.
\end{itemize} \\
\\
\textbf{is\_number\_in\_list}(\textsf{n},\textsf{tab}) :\\
\hspace{.4cm}\textsf{l} $\leftarrow$ \textbf{longueur}(\textsf{tab}) \\
\hspace{.4cm}\textbf{Pour} \textsf{i} \textbf{allant de} 1 \textbf{à} \textsf{l} \textbf{faire} : \\
\hspace{.8cm} \textbf{Si}  \textsf{tab[i] = n} \textbf{alors} :\\
\hspace{1.2cm}\textbf{Retourne} \textsf{Vrai} \\
\hspace{.8cm} \textbf{Fin Si} \\
\hspace{.4cm}\textbf{Fin Faire} \\
\hspace{.4cm}\textbf{Retourne} \textsf{Faux} \\
\textbf{Fin fonction} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}


\begin{minipage}[c]{.49\linewidth}
\begin{py}
\begin{python}
def is_number_in_list(nb,tab):
    """Renvoie True si le nombre nb est dans la liste 
    de nombres tab
    Keyword arguments:
      * nb, int -- nombre entier
      * tab, list -- liste de nombres entiers    
    """
    for i in range(len(tab)):
        if tab[i]==nb:
            return True
    return False
\end{python}
\end{py}
\end{minipage}\hfill
\begin{minipage}[c]{.49\linewidth}
\begin{py}
\begin{python}
def is_number_in_list(nb,tab):
    """Renvoie True si le nombre nb est dans la liste 
    de nombres tab
    Keyword arguments:
      * nb, int -- nombre entier
      * tab, list -- liste de nombres entiers    
    """
    i=0
    while i<len(tab) and tab[i]!=nb:
        i+=1
    return i<len(tab)
\end{python}
\end{py}
\end{minipage}

\begin{rem}
Ces algorithmes sont modifiables aisément dans le cas où on souhaiterait connaître l'index du nombre recherché.
\end{rem}

%\subsubsection{Algorithme raccourci}



\subsection{Recherche du maximum dans une liste de nombre}

\begin{minipage}[c]{.48\linewidth}
\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Recherche du maximum dans une liste de nombres\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : une liste de nombres
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{maxi}, réel : maximum de la liste
\end{itemize} \\
\\
\textbf{what\_is\_max}(\textsf{tab}) :\\
\hspace{.4cm}\textsf{n} $\leftarrow$ \textbf{longueur}(\textsf{tab}) \\
\hspace{.4cm}\textsf{i  $\leftarrow$ 2} \\
\hspace{.4cm}\textsf{maxi  $\leftarrow$ tab[1]} \\
\hspace{.4cm}\textbf{Tant que} \textsf{i < n} \textbf{faire} : \\
\hspace{.8cm}\textbf{Si} \textsf{tab[i]>maxi} \textbf{alors} : \\
\hspace{1.2cm} \textsf{maxi  $\leftarrow$ tab[i]} \\
\hspace{.8cm}\textbf{Fin si} \\
\hspace{.8cm}\textsf{i  $\leftarrow$ i+1} \\
\hspace{.4cm}\textbf{Fin tant que} \\
\hspace{.4cm}\textbf{Retourner} \textsf{maxi}\\
\textbf{Fin fonction} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}
\end{minipage} \hfill
\begin{minipage}[c]{.48\linewidth}
\begin{py}
\begin{python}
def what_is_max(tab):
    """ 
    Renvoie le plus grand nombre d'une liste
    Keyword arguments:
    tab -- liste de nombres 
    """
    i=1
    maxi=tab[0]
    while i<len(tab):
        if tab[i]>maxi:
            maxi=tab[i]
        i+=1
    return maxi
\end{python}
\end{py}
\end{minipage}

\subsection{Recherche par dichotomie dans un tableau trié}


\begin{minipage}[c]{.48\linewidth}
\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Recherche par dichotomie d'un nombre dans une liste triée\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{nb}, int : un entier 
\item \textsf{tab}, liste : une liste d'entiers triés
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{m}, int : l'index du nombre recherché
\item \textsf{None} : cas où \textsf{nb} n'est pas dans \textsf{tab}
\end{itemize}
\\
\textbf{is\_number\_in\_list\_dicho}(\textsf{nb},\textsf{tab}) :\\
\hspace{.4cm}\textsf{g} $\leftarrow$ \textsf{0} \\
\hspace{.4cm}\textsf{d} $\leftarrow$ \textbf{longueur}(\textsf{tab}) \\
\hspace{.4cm}\textbf{Tant que} \textsf{g $<$ d} \textbf{alors} : \\
\hspace{.8cm} \textsf{m} $\leftarrow$ \textsf{(g+d)} \textbf{div} \textsf{2}\\
\hspace{1.2cm}\textbf{Si} \textsf{tab[m]=nb} \textbf{alors} :\\
\hspace{1.6cm}\textbf{Retourne} \textsf{m}\\
\hspace{1.2cm}\textbf{Sinon si} \textsf{tab[m]<nb} \textbf{alors} :\\
\hspace{1.6cm}\textsf{g} $\leftarrow$ \textsf{m+1}\\
\hspace{1.2cm}\textbf{Sinon, alors} :\\
\hspace{1.6cm}\textsf{d} $\leftarrow$ \textsf{m-1}\\
\hspace{.8cm} \textbf{Fin Si} \\
\hspace{.4cm}\textbf{Fin Tant que} \\
\hspace{.4cm}\textbf{Retourne} \textsf{None} \\
\textbf{Fin fonction} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}
\end{minipage} \hfill
\begin{minipage}[c]{.48\linewidth}
\begin{py}
\begin{python}
def is_number_in_list_dicho(nb,tab):
    """ 
    Recherche d'un nombre par dichotomie dans un 
    tableau trié. 
    Renvoie l'index si le nombre nb est dans la liste 
    de nombres tab.
    Renvoie None sinon.
    Keyword arguments:
    nb,int -- nombre entier
    tab,list -- liste de nombres entiers triés
    """
    g, d = 0, len(tab)-1
    while g <= d:
        m = (g + d) // 2
        if tab[m] == nb:
            return m
        if tab[m] < nb:
            g = m+1
        else:
            d = m-1
    return None
\end{python}
\end{py}
\end{minipage}

\section{Gestion d'une liste de nombres}
\subsection{Calcul de la moyenne}

\begin{minipage}[c]{.48\linewidth}
\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Calcul de la moyenne arithmétique des nombres d'une liste\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : une liste de nombres
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{res}, réel : moyenne des nombres
\end{itemize} \\
\\
\textbf{calcul\_moyenne}(\textsf{tab}) :\\
\hspace{.4cm}\textsf{n} $\leftarrow$ \textbf{longueur}(\textsf{tab}) \\
\hspace{.4cm}\textsf{res} $\leftarrow$ \textsf{0} \\
\hspace{.4cm}\textbf{Pour} \textsf{i} \textbf{allant de}\textsf{1} \textbf{à} \textsf{n} \textbf{faire}: \\
\hspace{.8cm} \textsf{res  $\leftarrow$ res+tab[i]} \\
\hspace{.4cm}\textbf{Fin faire} \\
\hspace{.4cm}\textbf{Retourner} \textsf{res/n}\\
\textbf{Fin fonction} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}
\end{minipage} \hfill
\begin{minipage}[c]{.48\linewidth}
\begin{py}
\begin{python}
def calcul_moyenne(tab):
    """ 
    Renvoie la moyenne des valeurs d'une liste de 
    nombres.
    Keyword arguments:
    tab -- liste de nombres
    """
    res = 0
    for i in range(len(tab)):
        res = res+tab[i]
    return res/(len(tab))
\end{python}
\end{py}    
\end{minipage}

\subsection{Calcul de la variance}
Soit une série statistique prenant les $n$ valeurs $x_1$, $x_2$, ..., $x_n$. Soit $m$ la moyenne de ces valeurs. La variance est définie par :
$$
v = \dfrac{1}{n} \sum\limits_{i=1}^n\left(x_i - m \right)^2
$$


\begin{minipage}[c]{.48\linewidth}
\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Calcul de la variance des nombres d'une liste\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : une liste de nombres
\item \textsf{m}, réel : moyenne de la liste
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{res}, réel : variance
\end{itemize} \\
\\
\textbf{calcul\_variance}(\textsf{tab}) :\\
\hspace{.4cm}\textsf{n} $\leftarrow$ \textbf{longueur}(\textsf{tab}) \\
\hspace{.4cm}\textsf{res} $\leftarrow$ \textsf{0} \\
\hspace{.4cm}\textbf{Pour} \textsf{i} \textbf{allant de} \textsf{1} \textbf{à} \textsf{n} \textbf{faire}: \\
\hspace{.8cm} \textsf{res  $\leftarrow$ res+(tab[i]-m)**2} \\
\hspace{.4cm}\textbf{Fin faire} \\
\hspace{.4cm}\textbf{Retourner} \textsf{res/n}\\
\textbf{Fin fonction} \\
\hline
\end{tabular}
\end{center}

\end{pseudo}
\end{minipage} \hfill
\begin{minipage}[c]{.48\linewidth}
\begin{py}
\begin{python}
def calcul_variance(tab,m):
    """ 
    Renvoie la variance des valeurs d'un tableau.
    Keyword arguments:
    tab -- liste de nombres
    m -- moyenne des valeurs
    """
    res = 0
    for i in range(len(tab)):
        res = res+(tab[i]-m)**2
    return res/(len(tab))
\end{python}
\end{py}
\end{minipage} 

\subsection{Calcul de la médiane} %Seconde année


\begin{minipage}[c]{.48\linewidth}
\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Recherche de la valeur médiane d'une liste de nombres triés \\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : liste de nombres triés
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item flt : valeur de la médiane
\end{itemize}
\\
\textbf{mediane}(\textsf{tab}) :\\
\hspace{.4cm}\textsf{n} $\leftarrow$ \textbf{Longueur}\textsf{(tab)} \\
\hspace{.4cm}\textbf{Si} \textsf{n} \textbf{modulo} \textsf{2 = 0} \textbf{Alors} : \\
\hspace{.8cm} \textsf{i $\leftarrow$ n/2} \\
\hspace{.8cm} \textbf{Retourner} \textsf{(tab[i] +tab[i+1])/2} \\
\hspace{.4cm}\textbf{Sinon} :\\
\hspace{.8cm} \textsf{i $\leftarrow$ n}\textbf{div} \textsf{2+1} \\
\hspace{.8cm} \textbf{Retourner} \textsf{(tab[i])} \\
\textbf{Fin fonction} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}
\end{minipage} \hfill
\begin{minipage}[c]{.48\linewidth}
\begin{py}
\begin{python}
def calcul_mediane(tab):
    """ 
    Calcule la variance des éléments d'un tableau trié.
    Keyword arguments:
    tab -- liste de nombres
    """
    if len(tab)%2 == 0 :
        i=len(tab)//2
        return (tab[i-1]+tab[i])/2
    else :
        i = len(tab)//2
    return tab[i]
\end{python}
\end{py}
\end{minipage}
%\subsubsection*{Estimation de la complexité}

\section{Chaînes de caractères}
\subsection{Recherche d'un mot dans une chaîne de caractères}

%\begin{minipage}[c]{.48\linewidth}
%\begin{pseudo}
%\end{pseudo}
%\end{minipage} \hfill
%\begin{minipage}[c]{.48\linewidth}
\begin{py}
\begin{python}
def index_of_word_in_text(mot, texte):
    """ Recherche si le mot est dans le texte.
    Renvoie l'index si le mot est présent, None sinon.
    Keyword arguments:
    mot -- mot recherché
    texte -- texte
    """
    for i in range(1 + len(texte) - len(mot)):
        j = 0
        while j < len(mot) and mot[j] == texte[i + j]:
            j += 1
        if j == len(mot):
            return i
    return None
\end{python}
\end{py}
%\end{minipage}

%\subsubsection*{Estimation de la complexité}

\section{Calcul numérique}
\subsection{Recherche du zéro d'une fonction continue monotone par la méthode de dichotomie}


\begin{minipage}[c]{.48\linewidth}
\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Recherche de la solution de $f(x)=0$ par dichotomie \\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{f}, fonction : fonction continue et monotone sur $[a,b]$
\item \textsf{a, b}, réels : nombre réels tels que $a<b$
\item \textsf{$\varepsilon$}, réel : tolérance du calcul
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item flt : solution de l'équation
\end{itemize}
\\
\textbf{solveDichotomie}(\textsf{f,a,b,$\varepsilon$}) :\\
\hspace{.4cm}\textsf{g} $\leftarrow$ \textsf{a} \\
\hspace{.4cm}\textsf{d} $\leftarrow$ \textsf{b} \\
\hspace{.4cm}\textbf{Tant que} \textsf{d-g>$\varepsilon$} \textbf{Alors} : \\
\hspace{.8cm}\textsf{m} $\leftarrow$ \textsf{(g+d)/2} \\
\hspace{.8cm}\textbf{Si} \textsf{f(g)*f(m) $\leq$ 0} \textbf{Alors} : \\
\hspace{1.2cm}\textsf{d $\leftarrow$  m} \\
\hspace{.8cm} \textbf{Sinon :} \\
\hspace{1.2cm}\textsf{g $\leftarrow$  m} \\
\hspace{.8cm} \textbf{Fin Si}\\
\hspace{.4cm} \textbf{Fin Tant que}\\
\textbf{Fin fonction} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}
%\begin{pseudo}
%\begin{algorithm}[H]
%\Fonction{
%Données:$f$, $a$,$b$, $\varepsilon$ \\
%$g\gets a$\\
%$d \gets b$\\
%$f_g \gets f(g)$\\
%$f_d \gets f(d)$\\
%\Tq{$ (d-g) > \varepsilon$}{
%$m \gets (g+d)/2$ \\
%$f_m\gets f(m)$
%
%\eSi{$f_g\cdot f_m \leq 0$}{
%$d \gets m$\\
%$f_d \gets f_m$\\
%}{
%$g \gets m$\\
%$f_d \gets f_m$\\
%}
%}
%\Retour{$(g+d)/2$}
%}
%\end{algorithm}
%\end{pseudo}
\end{minipage} \hfill
\begin{minipage}[c]{.48\linewidth}
\begin{py}
\begin{python}
def solveDichotomie(f,a,b,eps):
    """
    Recherche par dichotomie de la solution 
    de l'équation f(x)=0.
    Keywords arguments :
    Entrées : 
        a,b, flt : Nombre réels tels que a<b
        f, function : fonction continue et monotone 
        sur [a,b]
        eps,flt : tolérance de la résolution
    Sortie : 
        flt : solution de la fonction
    """
    g = a
    d = b
    while (d-g) > eps:
        m = (g+d)/2 
        if f(g) * f(m) <= 0 :
            d = m
        else :
            g  = m
    return (g+d)/2
\end{python}
\end{py}
\end{minipage}

%\subsubsection*{Précision du calcul}
%\subsubsection*{Rapidité}
%\subsubsection*{Comparaison à zéro}

\subsection{Recherche du zéro d'une fonction continue monotone par la méthode de Newton}


\begin{minipage}[c]{.48\linewidth}
\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Recherche de la solution de $f(x)=0$ par la méthode de Newton \\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{f}, fonction : fonction continue et monotone sur $[a,b]$
\item \textsf{df}, fonction : fonction dérivée de $f$ sur $[a,b]$
\item \textsf{a}, réel : nombre réel tel que
\item \textsf{$\varepsilon$}, réel : tolérance du calcul
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item c: flt : solution de l'équation
\end{itemize}
\\
\textbf{solveNewton}(\textsf{f,df,a,$\varepsilon$}) :\\
\hspace{.4cm} $c \gets  a-\dfrac{f(a)}{df(a)} $\\ 
\hspace{.4cm} \textbf{Tant que} $ |c-a|> \varepsilon$ \textbf{alors} \\
\hspace{.8cm} $a \gets  c$\\
\hspace{.8cm} $c \gets  c-\dfrac{f(c)}{df(c)} $\\ 
\textbf{Fin fonction} \\
\hline
\end{tabular}
\end{center}
%\begin{algorithm}[H]
%\Fonction{
%Données:$f$, $f'$, $a$, $\varepsilon$ \\
%$g\gets a$\\
%$c \gets  g-\dfrac{f(g)}{f'(g)} $\\
%\Tq{$ |c-g|> \varepsilon$}{
%$g \gets  c$ \\
%$c \gets c-\dfrac{f(c)}{f'(c)}$
%}
%\Retour{$c$}
%}
%\end{algorithm}
\end{pseudo}
\end{minipage} \hfill
\begin{minipage}[c]{.48\linewidth}
\begin{py}
\begin{python}
def solveNewton(f,df,a,eps):
    """
    Recherche par la méthode de Newton de la solution 
    de l'équation f(x)=0.
    Keywords arguments :
    Entrées :
        f, function : fonction à valeur de IR dans IR
        df, function : dérivée de f à valeur de IR dans IR
        a, flt : solution initiale
        eps,flt : tolérance de la résolution
    Sortie : 
        m : flt : solution de la fonction    
    """
    c = a-f(a)/df(a)
    while abs(c-a)>eps:
        a = c
        c = c-f(c)/df(c)
    return c
\end{python}
\end{py}
\end{minipage} 

\begin{rem}
La dérivée de $f$ notée $f'$ pourra être une fonction qui a été définie. On peut aussi calculer la dérivée de façon numérique. Ainsi, en tenant compte des précautions mathématiques d'usage, il est possible de procéder ainsi :

\begin{py}
\begin{python}
def derive_fonctions(f,x,eps):
    return (f(x+eps)-f(x))/(eps)
\end{python}
\end{py}
\end{rem}


%\subsubsection*{Précision du calcul}
%\subsubsection*{Rapidité}

\subsection{Méthode des rectangles pour le calcul approché d'une intégrale sur un segment}
\subsubsection{Méthode des rectangles à gauche}

\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Calcul d'intégrale par la méthode des rectangles à gauche\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{f}, fonction : fonction définie sur $[a,b]$  
\item \textsf{a}, réel : borne inférieure de l'intervalle de définition
\item \textsf{b}, réel : borne supérieure de l'intervalle de définition, \textsf{b$\geq$a}
\item \textsf{nb}, entiers : nombre d'échantillons pour calculer l'intégrale
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{res}, réel : valeur approchée de $\int\limits_a^b f(t)\text{d}t$
\end{itemize}
\\
\textbf{integrale\_rectangles\_gauche}(\textsf{f,a,b,nb}) :\\
\hspace{.4cm}\textsf{res} $\leftarrow$ \textsf{0}\\
\hspace{.4cm}\textsf{pas} $\leftarrow$ \textsf{(b-a)/nb}\\
\hspace{.4cm}\textsf{x} $\leftarrow$ \textsf{a}\\
\hspace{.4cm}\textbf{Tant que} \textsf{x<b},  \textbf{Faire :}\\
\hspace{.8cm}\textsf{res}$\leftarrow$ \textsf{res + } \textbf{f(}\textsf{x}\textbf{)}\\
\hspace{.8cm}\textsf{x} $\leftarrow$ \textsf{x+pas}\\
\hspace{.4cm}\textbf{Fin Tant que} \\
\hspace{.4cm} \textsf{res} $\leftarrow$ \textsf{res*pas}\\
\hspace{.4cm}\textbf{Retourner} \textsf{res}\\
\textbf{Fin Fonction} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}

\begin{py}
\begin{python}
def integrale_rectangles_gauche(f,a,b,nb):
    """
    Calcul de la valeur approchée de l'intégrale de f(x) entre a et b par la 
    méthode des rectangles à gauche.
    Keywords arguments :
    f -- fonction à valeur dans IR
    a -- flt, borne inférieure de l'intervalle d'intégration
    b -- flt, borne supérieure de l'intervalle d'intégration
    nb -- int, nombre d'échantillons pour le calcul
    """
    res = 0
    pas = (b-a)/nb
    x = a
    while x<b:
        res = res + f(x)
        x = x + pas
    return res*pas
\end{python}
\end{py}


\subsubsection{Méthode des rectangles à droite}

\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Calcul d'intégrale par la méthode des rectangles à droite\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{f}, fonction : fonction définie sur $[a,b]$  
\item \textsf{a}, réel : borne inférieure de l'intervalle de définition
\item \textsf{b}, réel : borne supérieure de l'intervalle de définition, \textsf{b$\geq$a}
\item \textsf{nb}, entiers : nombre d'échantillons pour calculer l'intégrale
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{res}, réel : valeur approchée de $\int\limits_a^b f(t)\text{d}t$
\end{itemize}
\\
\textbf{integrale\_rectangles\_droite}(\textsf{f,a,b,nb}) :\\
\hspace{.4cm}\textsf{res} $\leftarrow$ \textsf{0}\\
\hspace{.4cm}\textsf{pas} $\leftarrow$ \textsf{(b-a)/nb}\\
\hspace{.4cm}\textsf{x} $\leftarrow$ \textsf{a+pas}\\
\hspace{.4cm}\textbf{Tant que} \textsf{x<=b} : \textbf{Faire}\\
\hspace{.8cm}\textsf{res}$\leftarrow$ \textsf{res +} \textbf{f(}\textsf{x}\textbf{)}\\
\hspace{.8cm}\textsf{x} $\leftarrow$ \textsf{x+pas}\\
\hspace{.4cm}\textbf{Fin Tant que} \\
\hspace{.4cm} \textsf{res} $\leftarrow$ \textsf{res*pas}\\
\hspace{.4cm}\textbf{Retourner} \textsf{res}\\
\textbf{Fin Fonction} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}

\begin{py}
\begin{python}
def integrale_rectangles_droite(f,a,b,nb):
    """
    Calcul de la valeur approchée de l'intégrale de f(x) entre a et b par la 
    méthode des rectangles à droite.
    Keywords arguments :
    f -- fonction à valeur dans IR
    a -- flt, borne inférieure de l'intervalle d'intégration
    b -- flt, borne supérieure de l'intervalle d'intégration
    nb -- int, nombre d'échantillons pour le calcul
    """
    res = 0
    pas = (b-a)/nb
    x = a+pas
    while x<=b:
        res = res + f(x)
        x = x + pas
    return res*pas
\end{python}
\end{py}

\subsubsection{Méthode des rectangles -- Point milieu}

\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Calcul d'intégrale par la méthode des rectangles -- point milieu\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{f}, fonction : fonction définie sur $[a,b]$  
\item \textsf{a}, réel : borne inférieure de l'intervalle de définition
\item \textsf{b}, réel : borne supérieure de l'intervalle de définition, \textsf{b$\geq$a}
\item \textsf{nb}, entiers : nombre d'échantillons pour calculer l'intégrale
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{res}, réel : valeur approchée de $\int\limits_a^b f(t)\text{d}t$
\end{itemize}
\\
\textbf{integrale\_rectangles\_milieu}(\textsf{f,a,b,nb}) :\\
\hspace{.4cm}\textsf{res} $\leftarrow$ \textsf{0}\\
\hspace{.4cm}\textsf{pas} $\leftarrow$ \textsf{(b-a)/nb}\\
\hspace{.4cm}\textsf{x} $\leftarrow$ \textsf{a+pas/2}\\
\hspace{.4cm}\textbf{Tant que} \textsf{x<b} : \textbf{Faire}\\
\hspace{.8cm}\textsf{res}$\leftarrow$ \textsf{res + } 
\textbf{f(}\textsf{x}\textbf{)}\\
\hspace{.8cm}\textsf{x} $\leftarrow$ \textsf{x+pas}\\
\hspace{.4cm}\textbf{Fin Tant que} \\
\hspace{.4cm}\textsf{res} $\leftarrow$ \textsf{res*pas}\\
\hspace{.4cm}\textbf{Retourner} \textsf{res}\\
\hline
\end{tabular}
\end{center}
\end{pseudo}

\begin{py}
\begin{python}
def integrale_rectangles_milieu(f,a,b,nb):
    """
    Calcul de la valeur approchée de l'intégrale de f(x) entre a et b par la méthode du point milieu.
    Keywords arguments :
    f -- fonction à valeur dans IR
    a -- flt, borne inférieure de l'intervalle d'intégration
    b -- flt, borne supérieure de l'intervalle d'intégration
    nb -- int, nombre d'échantillons pour le calcul
    """
    res = 0
    pas = (b-a)/nb
    x = a+pas/2
    while x<b:
        res = res + f(x)
        x = x + pas
    return res*pas
\end{python}
\end{py}

\subsection{Méthode des trapèzes pour le calcul approché d'une intégrale sur un segment}

\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Calcul d'intégrale par la méthode des trapèzes\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{f}, fonction : fonction définie sur $[a,b]$  
\item \textsf{a}, réel : borne inférieure de l'intervalle de définition
\item \textsf{b}, réel : borne supérieure de l'intervalle de définition, \textsf{b$\geq$a}
\item \textsf{nb}, entiers : nombre d'échantillons pour calculer l'intégrale
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{res}, réel : valeur approchée de $\int\limits_a^b f(t)\text{d}t$
\end{itemize}
\\
\textbf{integrale\_trapeze}(\textsf{f,a,b,nb}) :\\
\hspace{.4cm}\textsf{res} $\leftarrow$ \textsf{0}\\
\hspace{.4cm}\textsf{pas} $\leftarrow$ \textsf{(b-a)/nb}\\
\hspace{.4cm}\textsf{x} $\leftarrow$ \textsf{a+pas}\\
\hspace{.4cm}\textbf{Tant que} \textsf{x<b}, \textbf{Faire :}\\
\hspace{.8cm}\textsf{res}$\leftarrow$ \textsf{res + }\textbf{f(}\textsf{x}\textbf{)}\\
\hspace{.8cm}\textsf{x} $\leftarrow$ \textsf{x+pas}\\
\hspace{.4cm}\textbf{Fin Tant que} \\
\hspace{.4cm}\textsf{res}$\leftarrow$ \textsf{pas*(res + (}\textbf{f(}\textsf{a}\textbf{)} + \textbf{f(}\textsf{b}\textbf{)} \textsf{)/2 )}\\
\hspace{.4cm}\textbf{Retourner} \textsf{res}\\
\hline
\end{tabular}
\end{center}
\end{pseudo}

\begin{py}
\begin{python}
def integrale_trapeze(f,a,b,nb):
    """
    Calcul de la valeur approchée de l'intégrale de f(x) entre a et b par la méthode des trapèzes.
    Keywords arguments :
    f -- fonction à valeur dans IR
    a -- flt, borne inférieure de l'intervalle d'intégration
    b -- flt, borne supérieure de l'intervalle d'intégration
    nb -- int, nombre d'échantillons pour le calcul
    """
    res = 0
    pas = (b-a)/nb
    x = a+pas
    while x<b:
        res = res + f(x)
        x = x + pas
    res = pas*(res+(f(a)+f(b))/2)
    return res
\end{python}
\end{py}

\begin{rem}
En raison de la comparaison de réels,  il pourrait être préférable de réaliser la boucle \textsf{while} sur un compteur d'échantillons.
\end{rem}

\subsection{Méthode d'Euler pour la résolution d'une équation différentielle}

\subsubsection{Méthode d'Euler explicite}
Résolution de l'équation différentielle :
$$
y(t) + \tau\dfrac{dy(t)}{dt} = y_f
$$


\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Méthode d'Euler explicite\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tau}, réel : constante de temps
\item \textsf{y\_0}, réel : valeur initiale de y
\item \textsf{y\_f}, réel : valeur finale y
\item \textsf{t\_f}, réel : temps de la simulation numérique
\item \textsf{nb}, entier : nombre d'échantillons pour calculer les valeurs de y
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{res}, liste : liste des couples (t,y(t)).
\end{itemize}
\\
\textbf{euler\_explicite}(\textsf{tau,y\_0,y\_f,t\_f,nb}) :\\
\hspace{.4cm}\textbf{Initialiser} \textsf{res} \\
\hspace{.4cm}\textsf{t} $\leftarrow$ \textsf{0}\\
\hspace{.4cm}\textsf{y} $\leftarrow$ \textsf{y\_0}\\
\hspace{.4cm}\textsf{pas} $\leftarrow$ \textsf{t\_f/nb}\\
\hspace{.4cm}\textbf{Tant que} \textsf{t<t\_f} \textbf{Faire} :\\
\hspace{.8cm}\textbf{Ajouter} \textsf{(t,y)}  \textbf{à} \textsf{res} \\
\hspace{.8cm} \textsf{y $\leftarrow$ y + pas *(y\_f-y)/tau}\\
\hspace{.8cm} \textsf{t $\leftarrow$ t + pas}\\
\hspace{.4cm}\textbf{Fin Tant que} \\
\hspace{.4cm}\textbf{Retourner} \textsf{res}\\
\hline
\end{tabular}
\end{center}
\end{pseudo}

\begin{py}
\begin{python}
def euler_explicite(tau,y0,yf,tf,nb):
    """
    Résolution d'une équation différentielle d'ordre 1 en utilisant la méthode
    d'Euler explicite.
    Keywords arguments :
    tau -- flt, constante de temps de l'équation différentielle 
    y0 -- flt, valeur initiale de y(t)
    yf -- flt valeur finale de y(t)
    tf -- flt temps de fin de la simulation
    nb -- int, nombre d'échantillons pour la simulation
    """
    t = 0
    y = y0 
    pas = tf / nb
    res = []
    while t < tf:
        res.append((t,y))
        y = y + pas*(yf-y)/tau
        t = t + pas
    return res
\end{python}
\end{py}
%\subsubsection*{Complexité algorithmique}

\newpage

\subsection{Algorithme de Gauss -- Jordan \cite{wack}}


\begin{py}
\begin{python}
def recherche_pivot(A,i):
    n = len(A) # le nombre de lignes
    j = i # la ligne du maximum provisoire
    for k in range(i+1, n):
        if abs(A[k][i]) > abs(A[j][i]):
            j = k # un nouveau maximum provisoire
    return j
\end{python}

\begin{python}    
def echange_lignes(A,i,j):
    # Li <-->Lj
    A[i][:],A[j][:]=A[j][:],A[i][:]
\end{python}

\begin{python}
def transvection_ligne(A, i, j, mu):
    # L_i <- L_i + mu.L_j """
    nc = len(A[0]) # le nombre de colonnes
    for k in range(nc):
        A[i][k] = A[i][k] + mu * A[j][k]
\end{python}

\begin{python}
def resolution(AA, BB):
    """Résolution de AA.X=BB; AA doit etre inversible"""
    A, B = AA.copy(), BB.copy()
    n = len(A)
    assert len(A[0]) == n
    # Mise sous forme triangulaire
    for i in range(n):
        j = recherche_pivot(A, i)
        if j > i:
            echange_lignes(A, i, j)
            echange_lignes(B, i, j)
        for k in range(i+1, n):
            x = A[k][i] / float(A[i][i])
            transvection_ligne(A, k, i, -x)
            transvection_ligne(B, k, i, -x)
    # Phase de remontée
    X = [0.] * n
    for i in range(n-1, -1, -1):
        X[i] = (B[i][0]-sum(A[i][j]*X[j] for j in range(i+1,n))) / A[i][i]
    return X
\end{python}
\end{py}
 
\section{Algorithmes de tris}%Seconde année
\subsection{Tri par sélection}
\begin{py}
\begin{python}
#Tri par sélection
def tri_selection(tab):
    for i in range(0,len(tab)):
        indice = i
        for j in range(i+1,len(tab)):
            if tab[j]<tab[indice]:
               indice = j
        tab[i],tab[indice]=tab[indice],tab[i]
    return tab
\end{python}
\end{py}
\subsection{Tri par insertion}
\subsubsection{Méthode 1}
\begin{minipage}[c]{.48\linewidth}
\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Tri par insertion -- Méthode 1\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : une liste de nombres
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{tab}, liste : la liste de nombres triés
\end{itemize}
\\
\textbf{tri\_insertion}(\textsf{tab}) :\\
\hspace{.4cm} \textsf{n} $\leftarrow$ \textbf{longueur}(\textsf{tab}) \\
\hspace{.4cm}\textbf{Pour} \textsf{i} \textbf{de} 2 \textbf{à} \textsf{n} : \\
\hspace{.8cm} \textsf{x} $\leftarrow$ \textsf{tab[i]} \\
\hspace{.8cm} \textsf{j} $\leftarrow$ \textsf{1} \\
\hspace{.8cm}\textbf{Tant que} \textsf{j $\leq$ i-1} \textbf{et} \textsf{tab[j]<x}  : \\
\hspace{1.2cm} \textsf{j} $\leftarrow$ \textsf{j+1} \\
\hspace{.8cm}\textbf{Fin Tant que} \\
\hspace{.8cm}\textbf{Pour} \textsf{k} \textbf{de} \textsf{i-1} \textbf{à} \textsf{j-1} \textbf{par pas de} \textsf{-1} \textbf{faire} : \\
\hspace{1.2cm} \textsf{tab[k+1]} $\leftarrow$ \textsf{tab[k]} \\
\hspace{.8cm}\textbf{Fin Pour} \\
\hspace{.8cm} \textsf{tab[j]} $\leftarrow$ \textsf{x} \\
\hspace{.4cm}\textbf{Fin Pour} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}
\end{minipage} \hfill
\begin{minipage}[c]{.48\linewidth}
\begin{py}
\begin{python}
def tri_insertion_01(tab):
    """ 
    Trie une liste de nombre en utilisant la méthode 
    du tri par insertion.
    En Python, le passage se faisant par référence, il 
    n'est pas indispensable de retourner le tableau.
    Keyword arguments:
    tab -- liste de nombres
    """
    for i in range (1,len(tab)):
        x=tab[i]
        j=0
        while j<=i-1 and tab[j]<x:
            j = j+1
        for k in range(i-1,j-1,-1):
            tab[k+1]=tab[k]
        tab[j]=x
\end{python}
\end{py}
\end{minipage}

\subsubsection*{Estimation de la complexité}
\begin{itemize}
\item Meilleur des cas, le tableau est trié à l'envers, la complexité est linéaire : $\mathcal{O}(n)$.
\item Pire des cas, le tableau est trié, la complexité est quadratique : $\mathcal{O}(n^2)$.
\end{itemize}

\subsubsection{Méthode 2}
\begin{minipage}[c]{.48\linewidth}
\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Tri par insertion -- Méthode 2\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : une liste de nombres
\end{itemize}
\textbf{Résultat :} 
\begin{itemize}
\item \textsf{tab}, liste : la liste de nombres triés
\end{itemize}
\\
\textbf{tri\_insertion}(\textsf{tab}) :\\
\hspace{.4cm} \textsf{n} $\leftarrow$ \textbf{longueur}(\textsf{tab}) \\
\hspace{.4cm}\textbf{Pour} \textsf{i} \textbf{de} 2 \textbf{à} \textsf{n} : \\
\hspace{.8cm} \textsf{x} $\leftarrow$ \textsf{tab[i]} \\
\hspace{.8cm} \textsf{j} $\leftarrow$ \textsf{i} \\
\hspace{.8cm}\textbf{Tant que} \textsf{j >1} \textbf{et} \textsf{tab[j-1]>x}  : \\
\hspace{1.2cm} \textsf{tab[j]} $\leftarrow$ \textsf{tab[j-1]} \\
\hspace{1.2cm} \textsf{j} $\leftarrow$ \textsf{j-1} \\
\hspace{.8cm}\textbf{Fin Tant que} \\
\hspace{.8cm} \textsf{tab[j]} $\leftarrow$ \textsf{x} \\
\hspace{.4cm}\textbf{Fin Pour} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}
\end{minipage} \hfill
\begin{minipage}[c]{.48\linewidth}
\begin{py}
\begin{python}
def tri_insertion_02(tab):
    """ 
    Trie une liste de nombre en utilisant la méthode 
    du tri par insertion.
    En Python, le passage se faisant par référence, 
    il n'est pas indispensable de retourner le tableau.
    Keyword arguments:
    tab -- liste de nombres
    """
    for i in range (1,len(tab)):
        x=tab[i]
        j=i
        while j>0 and tab[j-1]>x:
            tab[j]=tab[j-1]
            j = j-1
        tab[j]=x
\end{python}
\end{py}
\end{minipage}
\subsubsection*{Estimation de la complexité}
\begin{itemize}
\item Meilleur des cas, le tableau est trié, la complexité est linéaire : $\mathcal{O}(n)$.
\item Pire des cas, le tableau est trié à l'envers, la complexité est quadratique : $\mathcal{O}(n^2)$.
\end{itemize}


%\begin{py}
%\begin{python}    
%#Tri par insertion
%def tri_insertion(tab):
%    for i in range(1,len(tab)):
%        a=tab[i] 
%        j=i-1    
%        while j>=0 and tab[j]>a:
%            tab[j+1]=tab[j]
%            j=j-1
%        tab[j+1]=a
%    return tab
%\end{python}
%\end{py}

\subsection{Tri shell}
\begin{py}
\begin{python}
def shellSort(array):
     "Shell sort using Shell's (original) gap sequence: n/2, n/4, ..., 1."
     "http://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Shell_sort#Python"
     gap = len(array) // 2
     # loop over the gaps
     while gap > 0:
         # do the insertion sort
         for i in range(gap, len(array)):
             val = array[i]
             j = i
             while j >= gap and array[j - gap] > val:
                 array[j] = array[j - gap]
                 j -= gap
             array[j] = val
         gap //= 2
\end{python}
\end{py}

\subsection{Tri rapide <<Quicksort>>}
\subsubsection{Tri rapide}

\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Tri Quicksort -- Segmentation\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : une liste de nombres
\item \textsf{i,j}, entiers : indices de début et de fin de la segmentation à effectuer
\end{itemize}
\textbf{Résultats :} 
\begin{itemize}
\item \textsf{tab}, liste : la liste de nombre segmenté avec le pivot à sa place définitive
\item \textsf{k} entier : l'indice de la place du pivot
\end{itemize}
\\
\textbf{segmente}(\textsf{tab,i,j}) :\\
\hspace{.4cm} \textsf{g $\leftarrow$ i+1 }\\
\hspace{.4cm} \textsf{d $\leftarrow$ j}\\
\hspace{.4cm} \textsf{p $\leftarrow$ tab[i]}\\
\hspace{.4cm} \textbf{Tant que} \textsf{g $\leq$ d} \textbf{Faire} \\
\hspace{.8cm} \textbf{Tant que} \textsf{d$\geq$ 0} \textbf{et} \textsf{tab[d]>p} \textbf{Faire} \\
\hspace{1.2cm} \textsf{d $\leftarrow$ d-1}\\  
\hspace{.8cm} \textbf{Fin Tant que}  \\
\hspace{.8cm} \textbf{Tant que} \textsf{g$\leq$ j} \textbf{et} \textsf{tab[g]$\leq$p} \textbf{Faire} \\
\hspace{1.2cm} \textsf{g $\leftarrow$ g+1}\\  
\hspace{.8cm} \textbf{Fin Tant que}  \\
\hspace{.8cm} \textbf{Si} \textsf{g<d} \textbf{alors} \\
\hspace{1.2cm} \textbf{Échange(} \textsf{tab,g,d} \textbf{)} \\
\hspace{1.2cm} \textsf{d $\leftarrow$ d-1}\\  
\hspace{1.2cm} \textsf{g $\leftarrow$ g+1}\\  
\hspace{.8cm} \textbf{Fin Si} \\
\hspace{.4cm} \textbf{Fin Tant que}  \\
\hspace{.4cm} \textsf{k$\leftarrow$ d}  \\
\hspace{.4cm} \textbf{Échange(} \textsf{tab,i,d} \textbf{)} \\
\hspace{.4cm} \textbf{Retourner} \textsf{k}  \\
\hline
\end{tabular}
\end{center}



\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Tri Quicksort -- Tri rapide\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : une liste de nombres
\item \textsf{i,j}, entiers : indices de début et de fin de la portion à trier
\end{itemize}
\textbf{Résultats :} 
\begin{itemize}
\item \textsf{tab}, liste : liste triée entre les indices \textsf{i} et \textsf{j}
\end{itemize}
\\
\textbf{tri\_quicksort}(\textsf{tab,i,j}) :\\
\hspace{.4cm} \textbf{Si} \textsf{g<d} \textbf{alors} \\
\hspace{.8cm} \textsf{k$\leftarrow$} \textbf{segmente(}\textsf{tab,i,j} \textbf{)} \\
\hspace{.8cm} \textbf{tri\_quicksort(}\textsf{tab,i,k-1} \textbf{)} \\
\hspace{.8cm} \textbf{tri\_quicksort(}\textsf{tab,k+1,j} \textbf{)} \\
\hspace{.4cm} \textbf{Fin Si} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}

\begin{py}
\begin{python}
def segmente(tab,i,j):
    """
    Segmentation d'un tableau par rapport à un pivot.
    Keyword arguments: 
    tab (list) -- liste de nombres
    i,j (int) -- indices de fin et de début de la segmantation
    Retour :    
    tab (list) -- liste de nombres avec le pivot à sa place définitive
    k (int) -- indice de la place du pivot
    """
    g =i+1
    d=j
    p=tab[i]
    while g<=d :
        while d>=0 and tab[d]>p:
            d=d-1
        while g<=j and tab[g]<=p:
            g=g+1
        if g<d :
            tab[g],tab[d]=tab[d],tab[g]
            d=d-1
            g=g+1
    k=d
    tab[i],tab[d]=tab[d],tab[i]
    return k
\end{python}

\begin{python}
def tri_quicksort(tab,i,j):
    """
    Tri d'une liste par l'utilisation du tri rapide (Quick sort).
    Keyword arguments: 
    tab (list) -- liste de nombres
    i,j (int) -- indices de fin et de début de la zone de tri
    Retour :    
    tab (list) -- liste de nombres avec le pivot à sa place définitive
    """
    if i<j :
        k = segmente(tab,i,j)
        tri_quicksort(tab,i,k-1)
        tri_quicksort(tab,k+1,j)
\end{python}
\end{py}


\subsubsection{Tri rapide optimisé}

\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Tri Quicksort -- Tri rapide optimisé\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : une liste de nombres
\item \textsf{i,j}, entiers : indices de début et de fin de la portion de liste à trier
\end{itemize}
\textbf{Résultats :} 
\begin{itemize}
\item \textsf{tab}, liste : liste triée entre les indices \textsf{i} et \textsf{j}
\end{itemize}
\\
\textbf{tri\_quicksort\_optimized}(\textsf{tab,i,j}) :\\
\hspace{.4cm} \textbf{Si} \textsf{i<j} \textbf{alors} \\
\hspace{.8cm} \textsf{k$\leftarrow$} \textbf{segmente(}\textsf{tab,i,j} \textbf{)} \\
\hspace{.8cm} \textbf{Si} \textsf{k-i>15} \textbf{alors} \\
\hspace{1.2cm} \textbf{tri\_quicksort(}\textsf{tab,i,k-1} \textbf{)} \\
\hspace{.8cm} \textbf{Sinon} \\
\hspace{1.2cm} \textbf{tri\_insertion(}\textsf{tab,i,k-1} \textbf{)} \\
\hspace{.8cm} \textbf{Fin Si} \\
\hspace{.8cm} \textbf{Si} \textsf{j-k>15} \textbf{alors} \\
\hspace{1.2cm} \textbf{tri\_quicksort(}\textsf{tab,k+1,j} \textbf{)} \\
\hspace{.8cm} \textbf{Sinon} \\
\hspace{1.2cm} \textbf{tri\_insertion(}\textsf{tab,k+1,j} \textbf{)} \\
\hspace{.8cm} \textbf{Fin Si} \\
\hspace{.4cm} \textbf{Fin Si} \\
\hline
\end{tabular}
\end{center}
\end{pseudo}
\subsection{Tri fusion}


\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Tri Fusion -- Fusion de deux listes\\
\hline
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : une liste de nombres \textsf{tab[g:d]} avec \textsf{g} indice de la valeur de gauche, \textsf{d} indice de la valeur de droite
\item \textsf{m}, entier : indice tel que \textsf{$g\leq$m<d} et tel que les sous-tableaux \textsf{tab[g:m]} et \textsf{tab[m+1:d]} soient ordonnés
\end{itemize}
\textbf{Résultats :} 
\begin{itemize}
\item \textsf{tab}, liste : liste triée entre les indices \textsf{g} et \textsf{d}
\end{itemize}
\\
\textbf{fusion\_listes}(\textsf{tab,g,d,m}) :\\
\hspace{.4cm} \textsf{n1$\leftarrow$ m-g+1}\\
\hspace{.4cm} \textsf{n2$\leftarrow$ d-m}\\
\hspace{.4cm} \textbf{Initialiser tableau} \textsf{G}  \\
\hspace{.4cm} \textbf{Initialiser tableau} \textsf{D}  \\
\hspace{.4cm} \textbf{Pour} \textsf{i} \textbf{allant de} \textsf{1} \textbf{à} \textsf{n1} \textbf{faire}\\
\hspace{.8cm}  \textsf{G[i] $ \leftarrow$ tab[g+i-1]}\\
\hspace{.4cm}  \textbf{Fin Pour}\\
\hspace{.4cm} \textbf{Pour} \textsf{j} \textbf{allant de} \textsf{1} \textbf{à} \textsf{n2} \textbf{faire}\\
\hspace{.8cm} \textsf{D[j] $ \leftarrow$ tab[m+j]}\\
\hspace{.4cm} \textbf{Fin Pour}\\
\hspace{.4cm} \textsf{i $\leftarrow$ 1}\\
\hspace{.4cm} \textsf{j $\leftarrow$ 1}\\
\hspace{.4cm} \textsf{G[n1+1] $\leftarrow$ $+\infty$}\\
\hspace{.4cm} \textsf{D[n2+1] $\leftarrow$ $+\infty$}\\
\hspace{.4cm} \textbf{Pour} \textsf{k} \textbf{allant de} \textsf{g} \textbf{à} \textsf{d} \textbf{faire}\\
%\hspace{.8cm} \textbf{Si} \textsf{i$\leq$n1} \textbf{et} \textsf{G[i]$\leq$D[j]} \textbf{alors} \\
\hspace{.8cm} \textbf{Si}  \textsf{G[i]$\leq$D[j]} \textbf{alors} \\
\hspace{1.2cm} \textsf{tab[k]$\leftarrow$ G[i]} \\
\hspace{1.2cm} \textsf{i$\leftarrow$ i+1} \\
\hspace{.8cm} \textbf{Sinon} \\
%\hspace{1.2cm} \textbf{Si} \textsf{j$\leq$n2} \textbf{et} \textsf{G[i]>D[j]} \textbf{alors} \\
\hspace{1.2cm} \textbf{Si} \textsf{G[i]>D[j]} \textbf{alors} \\
\hspace{1.6cm} \textsf{tab[k]$\leftarrow$ D[j]} \\
\hspace{1.6cm} \textsf{j$\leftarrow$ j+1} \\
\hspace{1.2cm} \textbf{Fin Si} \\
\hspace{.8cm} \textbf{Fin Si} \\
\hspace{.4cm}  \textbf{Fin Pour}\\
\hline
\end{tabular}
\end{center}
\end{pseudo}



\begin{pseudo}
\begin{center}
\begin{tabular}{p{.9\textwidth}}
\hline
\textbf{Algorithme :} Tri Fusion \\
\hline
Algorithme récursif du table de tri. \\
\textbf{Données :}
\begin{itemize}
\item \textsf{tab}, liste : une liste de nombres non triés \textsf{tab[g:d]} 
\item \textsf{g,d}, entiers : indices de début et de fin de la liste
\end{itemize}
\textbf{Résultats :} 
\begin{itemize}
\item \textsf{tab}, liste : liste triée entre les indices \textsf{g} et \textsf{d}
\end{itemize}
\\
\textbf{tri\_fusion}(\textsf{tab,g,d}) :\\
\hspace{.4cm} \textbf{Si} \textsf{g<d}  \textbf{alors} \\
\hspace{.8cm} \textsf{m $\leftarrow$ (g+d)} \textbf{div} 2\\
\hspace{.8cm} \textbf{tri\_fusion}(tab,g,m) \\
\hspace{.8cm} \textbf{tri\_fusion}(tab,m+1,d) \\
\hspace{.8cm} \textbf{fusion\_listes}(tab,g,d,m) \\
\hspace{.4cm}  \textbf{Fin Si}\\
\hline
\end{tabular}
\end{center}
\end{pseudo}

\begin{py}
\begin{python}
def fusion_listes(tab,g,d,m):
    """
    Fusionne deux listes triées.
    Keyword arguments:
    tab (list) -- liste : une liste de nombres tab[g:d] avec g indice de la 
    valeur de gauche, d indice de la valeur de droite
    g,d,m (int) -- entiers : indices tels que g<=m<d et tel que les 
    sous-tableaux tab[g:m] et tab[m+1:d] soient ordonnés
    Résultat :
    tab (list) : liste triée entre les indices g et d
    """
    n1 = m-g+1
    n2 = d-m
    G,D = [],[]
    for i in range (n1):
        G.append(tab[g+i])
    for j in range (n2):
        D.append(tab[m+j+1])
    i,j=0,0
    G.append(99999999999)
    D.append(99999999999)
    for k in range (g,d+1):
        if G[i]<=D[j]: # and i<=n1 
            tab[k]=G[i]
            i=i+1
        elif G[i]>D[j]: # and j<=n2
            tab[k]=D[j]
            j=j+1
            
def tri_fusion(tab,g,d):
    """
    Tri d'une liste par la métode du tri fusion
    Keyword arguments:
    tab (list) -- liste : une liste de nombres non triés tab[g:d]
    g,d (int) -- entiers : indices de début et de fin de liste si on veut trier
                           tout le tableau g=0, d=len(tab)-1
    Résultat :
    tab (list) : liste triée entre les indices g et d
    """
    if g<d:
        m=(g+d)//2
        tri_fusion(tab,g,m)
        tri_fusion(tab,m+1,d)
        fusion_listes(tab,g,d,m)
\end{python}
\end{py}

\section{Algorithmes classiques}
\subsection{Division euclidienne}
\begin{pseudo}
\begin{algorithm}[H]
\KwData{$a,b \in\mathbb{N}^*$}
reste $\gets$ a\\
quotient $\gets$ 0\\
\Tq{reste $\geq$ b}{
reste $\gets$ reste $-$ b\\
quotient $\gets$ quotient $+$ 1\\
}
Retourner quotient,reste
\end{algorithm}
\end{pseudo}

\subsection{Algorithme d'Euclide}
Cet algorithme permet de calculer le PGCD de deux nombres entiers. Il se base sur le fait que si $a$ et $b$ sont deux entiers naturels non nuls, $pgcd(a,b)=pgcd(b, a \text{mod} b)$. 

%\begin{pseudo}
%\begin{algorithm}[H]
%\KwData{$a,b \in\mathbb{N}^*$}
%$x\gets a$\\
%$y\gets b$\\
%\Tq{$y\neq 0$}{
%$r\gets$ reste de la division euclidienne de $x$ par $y$\\
%$x\gets y$\\
%$y\gets r$}
%Afficher $x$.
%\end{algorithm}
%\end{pseudo}
\begin{minipage}[c]{.48\linewidth}
\begin{pseudo}
\begin{tabular}{p{.9\textwidth}}
\hline
Fonction PGCD : algorithme d’Euclide \\
\hline
\textbf{Données :} a et b : deux entiers naturels non nuls tels que a > b \\
\textbf{Résultat :} le PGCD de a et b \\
\\
\textbf{Euclide\_PGCD}(a,b) \\
\hspace{.5cm}\textbf{Répéter}\\
\hspace{1cm}r $\leftarrow$ a mod b\\
\hspace{1cm}a $\leftarrow$ b \\
\hspace{1cm}b $\leftarrow$ r \\
\hspace{.5cm}\textbf{Jusqu’à} r == 0 \\
\hspace{.5cm}\textbf{Retourner} a\\
\hline
\end{tabular}
\end{pseudo}
\end{minipage} \hfill
\begin{minipage}[c]{.48\linewidth}
\begin{py}
Codage en Pythonde l'algorithme d'Euclide :
\begin{python}
def Euclide_PGCD(a,b):	# on définit le nom de la 
			# fonction et ses variables 
			# d'entrées/d'appel
    r=a%b		# on calcule le reste dans 
			# la division de a par b
    
    while r!=0:		# tant que r est non nul :
        a=b		# b devient le nouveau a
        b=r		# r devient le nouveau b
        r=a%b		# on recalcule le reste
        
    return(b)		# une fois la boucle terminée, 
			# on retourne le dernier b    
print(Euclide_PGCDpgcd(1525,755))	
			# on affiche le résultat 
			# retourné par la fonction
\end{python}
\end{py}
\end{minipage}

\begin{center}
\includegraphics[width=.45\textwidth]{images/algo_euclide}
\end{center}
%\subsection{Recherche des nombres premiers -- Crible d'Ératosthène}
\subsection{Calcul de puissance}
\subsubsection{Algorithme naïf}

\begin{py}
\begin{python}
def exponentiation_naive(x,n):
    """
    Renvoie x* *n par la methode naive.
    Keyword arguments:
    Entrées : 
        x, flt : un nombre réel
        n, int : un nombre entier
    Sortie : 
        res,flt : resultat
    """
    res = 1
    while n>=1:
        res = res * x
        n=n-1
    return res
\end{python}
\end{py}

\subsubsection{Exponentiation rapide itérative}
\begin{py}
\begin{python}
def exponentiation_rapide_iteratif(x,n):
    """ 
    Renvoie x**n par la methode d'exponentiation rapide.
    Keyword arguments:
    Entrées : 
        x, flt : un nombre réel
        n, int : un nombre entier
    Sortie : 
        res,flt : resultat
    """
    if n==0 :
        return 1
    else :
        res = 1
        a = x
        while n>0:
            if n%2 == 1:
                res = res*a
            a=a*a
            n=int(n/2)
        return res
\end{python}
\end{py}


%\section{Calcul d'un polynôme}
%\subsection{Algorithme naïf}
%\subsection{Méthode de Horner}

\begin{thebibliography}{2}
\bibitem{pb}{Patrick Beynet, Cours d'informatique de CPGE, Lycée Rouvière de Toulon, UPSTI.}
\bibitem{ap}{Adrien Petri et Laurent Deschamps, Cours d'informatique de CPGE, Lycée Rouvière de Toulon.}
\bibitem{di}{Damien Iceta, Cours d'informatique de CPGE, Lycée Gustave Eiffel de Cachan, UPSTI.}
\bibitem{wack}{Benjamin WACK, Sylvain CONCHON, Judicaël COURANT, Marc DE FALCO, Gilles DOWEK, Jean-Christophe FILLIÂTRE, Stéphane GONNORD, 
Informatique pour tous en classes préparatoires aux grandes écoles, 
Éditions Eyrolles.}
\end{thebibliography}
\end{document}


 