\section{Anlayse des algorithmes}

\subsection{Définition}

\begin{defi}{Terminaison d'un algorithme} \\
Prouver la terminaison d'un algorithme signifie montrer que cet algorithme se terminera en un temps fini. On utilise pour cela un \textbf{variant de boucle}.
\end{defi}

\begin{defi}{Correction d'un algorithme} \\
Prouver la correction d'un algorithme signifie montrer que cet algorithme fournit bien la solution au problème qu'il est sensé résoudre. On utilise pour cela un \textbf{invariant de boucle}.
\end{defi}

%\begin{defi}\textbf{Analyser} \\
%Prouver la correction d'un algorithme signifie montrer que cet algorithme fournit bien la solution au problème qu'il est sensé résoudre. On utilise pour cela un \textbf{invariant de boucle}.
%\end{defi}


\subsection{Un exemple ...}
\begin{obj}

L'objectif est ici de montrer la nécessité d'utiliser un invariant de boucle.

Pour cela, on propose la fonction suivante sensée déterminer le plus petit entier \texttt{n} strictement positif tel que $1 + 2 + . . . + n$ dépasse strictement la valeur entière strictement positive \texttt{v}. Cette fonction renvoie-t-elle le bon résultat ? Desfois ? Toujours ?
\end{obj}
\begin{lstlisting}
def foo(v:int) -> int:
    r = 0
    n = 0
    while r < v : 
        n = n+1
        r = r+n
    return n
\end{lstlisting}

\textit{Montrer intuitivement que \texttt{foo(v)} se termine pour $v\in\mathbb{N}^*$.}

L'algorithme se terminera si on sort de la boucle \texttt{while}. Il faut pour cela que la condition \texttt{r<v} devienne fausse (cette condition est vraie initialement). Pour cela, il faut que \texttt{r} devienne supérieure ou égale à \texttt{v} dont la valeur ne change jamais. 

\texttt{n} étant incrémenté de 1 à chaque itération, la valeur de \texttt{r} augmente donc à chaque itération. Il y aura donc un rang \texttt{n} au-delà duquel \texttt{r} sera supérieur à \texttt{v}. L'algorithme se termine donc. 

\bigskip

\textit{Que renvoie \texttt{foo(9)} ? Cela répond-il au besoin ?}

\begin{center}
\begin{tabular}{llll}
\hline
Début de la i\ieme itération & \texttt{r} & \texttt{n} & \texttt{r < v} \\ \hline \hline
Itération 1 & \texttt{0} & \texttt{0} & \texttt{0 < 9  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 2& \texttt{1} & \texttt{1} & \texttt{1 < 9  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 3 & \texttt{3} & \texttt{2} & \texttt{3 < 9  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 4 & \texttt{6} & \texttt{3} & \texttt{6 < 9  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 5 & \texttt{10} & \texttt{4} & \texttt{10< 9  } $\Rightarrow$ \texttt{  False} \\ \hline
\end{tabular}
\end{center}

La fonction renvoie 4. On a $1+2+3+4 = 10$. On dépasse strictement la valeur 9. La fonction répond au besoin dans ce cas. 

\bigskip

\textit{Que renvoie \texttt{foo(10)} ? Cela répond-il au besoin ?}

\begin{center}
\begin{tabular}{llll}
\hline
Début de la i\ieme itération & \texttt{r} & \texttt{n} & \texttt{r < v} \\ \hline \hline
Itération 1 & \texttt{0} & \texttt{0} & \texttt{0 < 10  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 2& \texttt{1} & \texttt{1} & \texttt{1 < 10  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 3 & \texttt{3} & \texttt{2} & \texttt{3 < 10  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 4 & \texttt{6} & \texttt{3} & \texttt{6 < 10  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 5 & \texttt{10} & \texttt{4} & \texttt{10< 10  } $\Rightarrow$ \texttt{  False} \\ \hline
\end{tabular}
\end{center}
La fonction renvoie 4. On a $1+2+3+4 = 10$. On ne dépasse pas strictement la valeur 10. La fonction ne répond pas au besoin dans ce cas. 

\bigskip

\begin{resultat}
La fonction proposée ne remplit pas le cahier des charges. Aurait-on pu le prouver formellement ?
\end{resultat}

\section{Terminaison d'un algorithme}

\subsection{Variant de boucle}
\begin{defi}{Variant de boucle} \\
Un variant de boucle permet de prouver la terminaison d'une boucle conditionnelle.  Un variant de boucle est une \textbf{quantité entière positive} à l’entrée de chaque
itération de la boucle et qui \textbf{diminue strictement à chaque itération}.
\end{defi}

\begin{theorem}
Si une boucle admet un variant de boucle, elle termine.
\end{theorem}

\begin{prop}
Un algorithme qui n’utilise ni boucles inconditionnelles (boucle \texttt{for}) ni récursivité termine toujours. Ainsi,
la question de la terminaison n’est à considérer que dans ces deux cas.
\end{prop}

Reprenons l'exemple précédent. 
\begin{lstlisting}
def foo(v:int) -> int:
    r = 0
    n = 0
    while r < v : 
        n = n+1
        r = r+n
    return n
\end{lstlisting}

Dans cet exemple montrons que la quantité $u_n = v-r$ est un variant de boucle : 
\begin{itemize}
\item initialement, $r=0$ et $v>0$; donc  $u_0 > 0$;
\item à la fin de l'itération $n$, on suppose que $u_n = v-r >0$ et que $u_n < u_{n-1}$;
\item à l'itération $n+1$ : 
\begin{itemize}
\item cas 1 : $r\geq v$. Dans ce cas, $n$ et $r$ n'évoluent pas l'hypothèse de récurrence reste vraie. On sort de la boucle \texttt{while}. L'algorithme termine,
\item cas 2 : $r < v$. Dans ce cas, à la fin de l'itération $n+1$,  montrons que  $u_{n+1} < u_{n}$ : $u_{n+1} = v - (r + n + 1) =  u_n -n - 1$ soit $u_{n+1} =u_n -n - 1$ et donc $u_{n+1} < u_{n}$. L'hypothèse de récurrence est donc vraie au rang $n+1$. 
\end{itemize}
\end{itemize}

Au final, $u_n = v-r$ est donc un variant de boucle et la boucle se termine.


\subsection{Un second exemple ressemblant...} 

\begin{flushright}
\footnotesize
[\url{https://marcdefalco.github.io/pdf/complet_python.pdf}]
\normalsize
\end{flushright}

Considérons l’algorithme suivant qui, étant donné un entier naturel $n$ strictement positif (inférieur à $2^{30}$), détermine le plus petit entier $k$ tel que $n \leq 2^k$.
\begin{lstlisting}
def plus_grande_puissance2(n):
    k = 0
    p = 1
    while p < n:
        k = k+1
        p = p*2
    return k
\end{lstlisting}
\begin{demo}\textbf{[1]} $\quad$
Dans l’exemple précédent, la quantité $n - p$ est un variant de boucle :
\begin{itemize}
\item au départ, $n > 0$ et $p = 1$ donc $n - p \geq 0$;
\item comme il s’agit d’une différence de deux entiers, c’est un entier. Et tant que la condition
de boucle est vérifiée $p < n$ donc $n - p > 0$.
\item lorsqu’on passe d’une itération à la suivante, la quantité passe de $n-p$ à $n-2p$ or $2p-p > 0$
car $p \geq 1$. Il y a bien une stricte diminution.
\end{itemize}
\end{demo}

\begin{demo}\textbf{[2]} $\quad$
Montrons que, la quantité $u_j = n - p$ est un variant de boucle :
\begin{itemize}
\item intialement, $n > 0$ et $p = 1$ donc $n - p \geq 0$;
\item à la fin de l'itération $j$, on suppose que $u_j = n - p >0 $ et$u_j < u_{j-1}$;
\item à la fin de l'itération suivante, $u_{j+1}=n-2p = u_j - p$. $p$ est positif donc $u_{j+1}$ est un entier et $u_{j+1}<u_j$. Par suite, ou bien $u_{j+1}<0$ c'est à dire que $n-p<0$ soit $p>n$. On sort donc de la boucle. Ou bien, $u_{j+1}>0$, et la boucle continue.
\end{itemize}
$n - p$ est donc un variant de boucle.
\end{demo}

\section{Correction d'un algorithme}
\subsection{Invariant de boucle}

\begin{defi}{Invariant de boucle}
Soit une boucle. Une propriété est appelée un invariant de boucle lorsque :
\begin{itemize}
\item cette propriété est vérifiée avant d'entrer dans la boucle;
\item si cette propriété est vérifiée en entrée d'itération, alors elle est vérifiée en sortie de l'itération.
\end{itemize}

\end{defi}


Reprenons un des exemples précédents. Reconsidérons l’algorithme suivant qui, étant donné un entier naturel $n$ strictement positif (inférieur à $2^{30}$), détermine le plus petit entier $k$ tel que $n \leq 2^k$.
\begin{lstlisting}
def plus_grande_puissance2(n):
    k = 0
    p = 1
    while p < n:
        k = k+1
        p = p*2
    return k
\end{lstlisting}
\begin{demo}
Montrons que la propriété suivante est un invariant de boucle : $p=2^k$ et $2^{k-1}<n$.
\begin{itemize}
\item \textbf{Initialisation : }à l'entrée dans la boucle $k=0$ et $p=1$, $n\in\mathbb{N}^*$
\begin{itemize}
\item d'une part  on a bien $1=2^0$;
\item d'autre part $2^{-1}<n$.
\end{itemize}
\item On considère que la propriété est vraie au $n$\ieme tour de bouclen c'est à dire $p=2^k$ et $2^{k-1}<n$.
\item Au tour de boucle suivant : 
\begin{itemize}
\item \textbf{ou bien} $p>=n$. Dans ce cas, on sort de la boucle et on a toujours $p=2^k$ et $2^{k-1}<n$ (propriété d'invariance). La propriété est donc vraie au tour $n+1$.
\item \textbf{ou bien} $p<n$. Dans ce cas, il faut montrer que  $p=2^{k+1}$ et $2^{k}<n$. Etant entrés dans la boucle, $p<n \Rightarrow 2^k<n$. De plus, en fin de boucle, $p\rightarrow p *2$ et $k\rightarrow k+1$. On a donc $p\leftarrow 2^k *2=2^{k+1}$. 
\end{itemize}
\end{itemize}
La propriété citée est donc un invariant de boucle. 
\end{demo}

\subsection{Un << contre exemple >>}


Reprenons le tout premier exemple où on cherche le plus petit entier \texttt{n} strictement positif tel que $1 + 2 + . . . + n$ dépasse strictement la valeur entière strictement positive \texttt{v} .
\begin{lstlisting}
def foo(v:int) -> int:
    r = 0
    n = 0
    while r < v : 
        n = n+1
        r = r+n
    return n
\end{lstlisting}

La propriété suivante est-elle un invariant de boucle : 
$r=\sum\limits_{i=1}^n i$ et 
$\sum\limits_{n=1}^{n-1} i < v$, 
$n\in\mathbb{N}^*$ ?

La réponse est directement NON, car la phase d'initialisation n'est pas vérifiée car $n=0$ et $n\notin\mathbb{N}^*$.
Cela signifie donc que l'algorithme proposé en répond pas au cahier des charges. 

Modifions donc l'algorithme ainsi.
\begin{lstlisting}
def foo2(v:int) -> int:
    r = 1
    n = 1
    while r < v : 
        r = r+n
        n = n+1
    return n
\end{lstlisting}

Montrons que la propriété suivante est un invariant de boucle : $r=\sum\limits_{i=0}^n i$ et 
$\sum\limits_{n=0}^{n-1} i < v$, 
$n\in\mathbb{N}^*$.

\begin{itemize}
\item \textbf{Initialisation : }à l'entrée dans la boucle $r=1$ et $n=1$, $n\in\mathbb{N}^*$
\begin{itemize}
\item d'une part  on a bien $i=\sum\limits_{i=0}^1 i$;
\item d'autre part$  \sum\limits_{n=0}^{0}i =0 < v$.
\end{itemize}
\item On considère que la propriété est vraie au $n$\ieme  tour de boucle c'est-à-dire $r=\sum\limits_{i=0}^n i$ et $\sum\limits_{n=0}^{n-1} i < v$.
\item Au tour de boucle suivant : 
\begin{itemize}
\item \textbf{ou bien} $r\geq v$ et la propriété vraie au rang $n$ reste vraie;
\item \textbf{ou bien} $r < v$. À la fin de l'itération, on a donc $r\leftarrow r+n+1 $ et $n\leftarrow n+1 +1$.
Or $r=\sum\limits_{i=0}^n i$; donc $r\leftarrow \sum\limits_{i=0}^{n+1} i$. Par ailleurs, étant entrés dans la boucle, 
$r=\sum\limits_{i=0}^n i < v$. Les deux assertions sont donc vraies au rang $n+1$. 
%$p<n$. Dans ce cas, il faut montrer que  $p=2^{k+1}$ et $2^{k}<n$. Etant entrés dans la boucle, $p<n \Rightarrow 2^k<n$. De plus, en fin de boucle, $p\leftarrow p *2$ et $k\leftarrow k+1$. On a donc $p\leftarrow 2^k *2=2^{k+1}$. 
\end{itemize}
\end{itemize}
La propriété citée est donc un invariant de boucle. 

\subsection{Correction partielle -- Correction totale}
\begin{defi}{Correction partielle -- Correction totale}
La correction est partielle quand le résultat est correct lorsque l'algorithme s'arrête, la correction est totale si elle est partielle et si l'algorithme termine.
\end{defi}

\newpage
\section{A TRIER}

\begin{defi} 
\textbf{Preuve d'algorithme}

Une preuve d'algorithme est une démonstration montrant qu'un algorithme réalise la tâche pour laquelle il a été conçu. 

Il faut alors montrer sa \textbf{terminaison} c'est-à-dire montrer que l'algorithme se termine. On utilise pour cela un \textbf{variant de boucle}.

Il faut ensuite montrer sa \textbf{correction} c'est-à-dire montrer que l'algorithme réalise la tâche attendue. On utilise pour cela un \textbf{invariant de boucle}.
\end{defi}



\subsection{Un premier exemple}

\textit{Donner l'algorithme permettant de déterminer le plus petit entier n tel que 1 + 2 + . . . + n dépasse strictement 1000.}

Proposons cet algorithme.
\begin{lstlisting}
res = 0
n = 0
while res < 1000 : 
    n = n+1
    res = res+n
    
print(n,res)
\end{lstlisting}

\subsection{Un deuxième exemple : $n!$}

\begin{lstlisting}
for i in range(1,n+1):
    # en entrant dans le ième tour de boucle, p = (i-1)!
    p=p*i
    # en sortant du ième tour de boucle, p = i!

print(p) #p = n!
\end{lstlisting}

Ici, l'invariant de boucle est << $p$ contient $(i-1)!$ >> : 
\begin{enumerate}
\item c'est bien une propriété qui est vraie pour $i=1$;
\item supposons qu'au rang i, $p=(i-1)!$ à l'entrée de la boucle. Au cours de la boucle, $p$ va prendre la valeur $p=(i-1)!\times i=i!=((i+1)-1)!$ donc la propriété est vérifiée en sortie de boucle;
\item enfin, au dernier tour de boucle, $i$ vaut $n$ donc $p=n!$ ce qui répond à la question.\\
\end{enumerate}

\subsection{Un troisième exemple : algorithme d'Euclide}
\url{https://lgarcin.github.io/CoursPythonCPGE/preuve.html}

\begin{lstlisting}
def pgcd(a, b):
  while b!= 0:
      a, b = b, a % b
  return a
\end{lstlisting}

On suppose que l'argument $b$ est un entier naturel. En notant $b_k$ la valeur de $b$ à la fin de la $k^\text{ème}$ itération ($b_0$ désigne la valeur de $b$ avant d'entrer dans la boucle), on a $0\leq b_{k+1}<b_k$ si $b_k>0$. La suite $(b_k)$ est donc une suite strictement décroissante d'entiers naturels : elle est finie et la boucle se termine.


On note $a_k$ et $b_k$ les valeurs de a et b à la fin de la $k^\text{ème}$ itération ($a_0$ et $b_0$ désignent les valeurs de $a$ et $b$ avant d'entrer dans la boucle). Or, si $a=bq+r$, il est clair que tout diviseur commun de $a$ et $b$ est un diviseur commun de $b$ et $r$ et réciproquement. Notamment, $a\wedge b=b\wedge r$. Ceci prouve que $a_k\wedge b_k=a_{k+1}\wedge b_{k+1}$. La quantité $a_k\wedge b_k$ est donc bien un invariant de boucle. En particulier, à la fin de la dernière itération (numérotée $N$), $b_N=0$ de sorte que $a_0\wedge b_0=a_N\wedge b_N=a_N\wedge0=a_N$. La fonction \texttt{pgcd} renvoie donc bien le \texttt{pgcd} de $a$ et $b$.

\subsection{Un troisième exemple (bis) : algorithme d'Euclide}
\url{https://mathematice.fr/fichiers/cpge/infoprepaC8.pdf}

On effectue la division euclidienne de $a$ par $b$ où $a $et $b$ sont deux entiers strictement positifs. Il s’agit
donc de déterminer deux entiers $q$ et $r$ tels que $a = bq+r$ avec $0 \leq r < b$. Voici un algorithme déterminant
$q$ et $r$ :

\begin{lstlisting}
q = 0
r = a
while r >= b :
    q = q + 1
    r = r -b
\end{lstlisting}

On choisit comme invariant de boucle la propriété $a = bq + r$.
\begin{itemize}
\item Initialisation : $q$ est initialisé à 0 et $r$ à $a$, donc la propriété $a = bq + r = b\cdot 0 + a$ est vérifiée avant le premier passage dans la boucle.
\item Hérédité : avant une itération arbitraire, supposons que l’on ait $a = bq + r$ et montrons que cette propriété est encore vraie après cette itération. Soient $q'$ la valeur de $q$ à la fin de l’itération et $r'$ la valeur de $r$ à la fin de l’itération. Nous devons montrer que $a = bq' + r'$. On a $q'= q + 1$ et $r' = r- b$, alors $bq' + r' = b(q + 1) + (r - b) = bq + r = a$. La propriété est bien conservée.
\end{itemize}


\textbf{Terminaison}
Nous reprenons l’exemple précédent.
\begin{itemize}
\item Commençons par montrer que le programme s’arrête : la suite formée par les valeurs de $r$ au cours
des itérations est une suite d’entiers strictement décroissante : $r$ étant initialisé à $a$, si $a \geq b$ alors
la valeur de $r$ sera strictement inférieure à celle de $b$ en un maximum de $a - b$ étapes.
\item Ensuite, si le programme s’arrête, c’est que la condition du "tant que" n’est plus satisfaite, donc
que $r < b$. Il reste à montrer que $r \geq 0$. Comme $r$ est diminué de $b$ à chaque itération, si $r < 0$,
alors à l’itération précédente la valeur de $r$ était $r' = r + b$ ; or $r' < b$ puisque $r < 0$. Et donc la
boucle se serait arrêtée à l’itération précédente, ce qui est absurde; on on déduit que $r \geq 0$.
\end{itemize}
En conclusion, le programme se termine avec $0 \leq r < b$ et la propriété $a = bq + r$ est vérifiée à chaque
itération; ceci prouve que l’algorithme effectue bien la division euclidienne de $a$ par $b$.



\subsection{Quatrième exemple }
L’objectif est de calculer le produit de deux nombres entiers positifs $a$ et $b$ sans utiliser de multiplication.
\begin{lstlisting}
p = 0
m = 0
while m < a :
    m = m + 1
    p = p + b
\end{lstlisting}

Comme dans l’exemple précédent, le programme se termine car la suite des valeurs de $m$ est une suite
d’entiers consécutifs strictement croissante, et atteint la valeur $a$ en $a$ étapes.

Un invariant de boucle est ici : $p = m.b$.

\begin{itemize}
\item Initialisation : avant le premier passage dans la boucle, $p = 0$ et $m = 0$, donc $p = mb$.
\item Hérédité : supposons que $p = mb$ avant une itération; les valeurs de $p$ et $m$ après l’itération sont
$p'= p + b$ et $m' = m + 1$. Or $p'= (p + b) = m.b + b = (m + 1)b = m'b$. Donc la propriété
reste vraie.
\item Conclusion : à la sortie de la boucle $p = m.b$.
\end{itemize}
Puisqu’à la sortie de la boucle $m = a$, on a bien $p = ab$.