\section{Anlayse des algorithmes}

\subsection{Définition}

\begin{defi}\textbf{Terminaison d'un algorithme} \\
Prouver la terminaison d'un algorithme signifie montrer que cet algorithme se terminera en un temps fini. On utilise pour cela un \textbf{variant de boucle}.
\end{defi}

\begin{defi}\textbf{Correction d'un algorithme} \\
Prouver la correction d'un algorithme signifie montrer que cet algorithme fournit bien la solution au problème qu'il est sensé résoudre. On utilise pour cela un \textbf{invariant de boucle}.
\end{defi}

\begin{defi}\textbf{Analyser} \\
Prouver la correction d'un algorithme signifie montrer que cet algorithme fournit bien la solution au problème qu'il est sensé résoudre. On utilise pour cela un \textbf{invariant de boucle}.
\end{defi}


\subsection{Un exemple ...}
On propose la fonction suivante sensée déterminer le plus petit entier \texttt{n} tel que $1 + 2 + . . . + n$ dépasse strictement la valeur entière strictement positive \texttt{v} .

\begin{lstlisting}
def foo(v:int) -> int:
    r = 0
    n = 0
    while r < v : 
        n = n+1
        r = r+n
    return n
\end{lstlisting}

\textit{Montrer intuitivement que \texttt{foo()} se termine.}
L'algorithme se terminera si on sort de la boucle \texttt{while}. Il faut pour cela que la condition \texttt{r<v} devienne fausse (cette condition est vraie initialement). Pour cela, il faut que \texttt{r} devienne supérieure ou égale à \texttt{v} dont la valeur ne change jamais. 
\texttt{n} étant incrémenter de 1 à chaque itération, la valeur de \texttt{r} augmente donc à chaque itération. Il y aura donc un rang \texttt{n} au-delà duquel \texttt{r} sera supérieur à \texttt{v}. L'algorithme donc se termine. 

\bigskip

\textit{Que renvoie \texttt{foo(9)} ? Cela répond-il au besoin ?}

\begin{center}
\begin{tabular}{llll}
\hline
Début de la i\ieme itération & \texttt{r} & \texttt{n} & \texttt{r < v} \\ \hline \hline
Itération 1 & \texttt{0} & \texttt{0} & \texttt{0 < 9  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 2& \texttt{1} & \texttt{1} & \texttt{1 < 9  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 3 & \texttt{3} & \texttt{2} & \texttt{3 < 9  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 4 & \texttt{6} & \texttt{3} & \texttt{6 < 9  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 5 & \texttt{10} & \texttt{4} & \texttt{10< 9  } $\Rightarrow$ \texttt{  False} \\ \hline
\end{tabular}
\end{center}

La fonction renvoie 4. On a $1+2+3+4 = 10$. On dépassement strictement la valeur 10. La fonction répond au besoin dans ce cas. 

\bigskip

\textit{Que renvoie \texttt{foo(10)} ? Cela répond-il au besoin ?}

\begin{center}
\begin{tabular}{llll}
\hline
Début de la i\ieme itération & \texttt{r} & \texttt{n} & \texttt{r < v} \\ \hline \hline
Itération 1 & \texttt{0} & \texttt{0} & \texttt{0 < 10  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 2& \texttt{1} & \texttt{1} & \texttt{1 < 10  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 3 & \texttt{3} & \texttt{2} & \texttt{3 < 10  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 4 & \texttt{6} & \texttt{3} & \texttt{6 < 10  } $\Rightarrow$ \texttt{  True} \\ \hline
Itération 5 & \texttt{10} & \texttt{4} & \texttt{10< 10  } $\Rightarrow$ \texttt{  False} \\ \hline
\end{tabular}
\end{center}
La fonction renvoie 4. On a $1+2+3+4 = 10$. On ne dépassement pas strictement la valeur 10. La fonction ne répond pas au besoin dans ce cas. 

\bigskip

\textbf{Bilan : } la fonction proposée ne remplit pas le cahier des charges. Aurait-on pu le prouver formellement ?

\section{Terminaison d'un algorithme}

\subsection{Variant de boucle}
\begin{defi} \textbf{Variant de boucle} \\
Un variant de boucle permet de prouver la terminaison d'une boucle conditionnelle.  Un variant de boucle est une \textbf{quantité entière positive} à l’entrée de chaque
itération de la boucle et qui \textbf{diminue strictement à chaque itération}.
\end{defi}

\begin{theorem}
Si une boucle admet un variant de boucle, elle termine.
\end{theorem}

\begin{rem}
Un algorithme qui n’utilise ni boucles inconditionnelles ni récursivité termine toujours. Ainsi,
la question de la terminaison n’est à considérer que dans ces deux cas.
\end{rem}

Reprenons l'exemple précédent. 
\begin{lstlisting}
def foo(v:int) -> int:
    r = 0
    n = 0
    while r < v : 
        n = n+1
        r = r+n
    return n
\end{lstlisting}

Dans cet exemple montrons que la quantité $u_n = v-r$ est un variant de boucle : 
\begin{itemize}
\item initialement, $r=0$ et $v>0$; donc  $u_0 > 0$;
\item à la fin de l'itération $n$, on suppose que $u_n = v-r >0$ et que $u_n < u_{n-1}$. 
\begin{itemize}
\item cas 1 : $r\geq v$. Dans ce cas, $n$ et $r$ n'évoluent pas l'hypothèse de récurrence reste vraie. 
\item cas 2 : $r < v$. Dans ce cas, à la fin de l'itération $n+1$,  montrons que  $u_{n+1} < u_{n}$ : $u_{n+1} = v - (r + n + 1) =  u_n -n - 1$ soit $u_{n+1} =u_n -n - 1$ et donc $u_{n+1} < u_{n}$. L'hypothèse de récurrence est donc vraie au rang $n+1$. 
\end{itemize}
\end{itemize}

Au final, $u_n = v-r$ est donc un variant de boucle. La boucle se termine donc.


\subsection{Un second exemple ressemblant...} 

\footnotesize
[\url{https://marcdefalco.github.io/pdf/complet_python.pdf}]
\normalsize

Considérons par l’algorithme suivant qui, étant donné un entier naturel $n$ strictement positif (inférieur à $2^{30}$), détermine le plus petit entier $k$ tel que $n \leq 2^k$.
\begin{lstlisting}
def plus_grande_puissance2(n):
    k = 0
    p = 1
    while p < n:
        k = k+1
        p = p*2
    return k
\end{lstlisting}
Dans l’exemple précédent, la quantité $n - p$ est un variant de boucle :
\begin{itemize}
\item au départ, $n > 0$ et $p = 1$ donc $n - p \geq 0$;
\item comme il s’agit d’une différence de deux entiers, c’est un entier. Et tant que la condition
de boucle est vérifiée $p < n$ donc $n - p > 0$.
\item lorsqu’on passe d’une itération à la suivante, la quantité passe de $n-p$ à $n-2p$ or $2p-p > 0$
car $p \geq 1$. Il y a bien une stricte diminution.
\end{itemize}

\newpage


\begin{defi} 
\textbf{Preuve d'algorithme}

Une preuve d'algorithme est une démonstration montrant qu'un algorithme réalise la tâche pour laquelle il a été conçu. 

Il faut alors montrer sa \textbf{terminaison} c'est-à-dire montrer que l'algorithme se termine. On utilise pour cela un \textbf{variant de boucle}.

Il faut ensuite montrer sa \textbf{correction} c'est-à-dire montrer que l'algorithme réalise la tâche attendue. On utilise pour cela un \textbf{invariant de boucle}.
\end{defi}



\subsection{Un premier exemple}

\textit{Donner l'algorithme permettant de déterminer le plus petit entier n tel que 1 + 2 + . . . + n dépasse strictement 1000.}

Proposons cet algorithme.
\begin{lstlisting}
res = 0
n = 0
while res < 1000 : 
    n = n+1
    res = res+n
    
print(n,res)
\end{lstlisting}

\subsection{Un deuxième exemple : $n!$}

\begin{lstlisting}
for i in range(1,n+1):
    # en entrant dans le ième tour de boucle, p = (i-1)!
    p=p*i
    # en sortant du ième tour de boucle, p = i!

print(p) #p = n!
\end{lstlisting}

Ici, l'invariant de boucle est << $p$ contient $(i-1)!$ >> : 
\begin{enumerate}
\item c'est bien une propriété qui est vraie pour $i=1$;
\item supposons qu'au rang i, $p=(i-1)!$ à l'entrée de la boucle. Au cours de la boucle, $p$ va prendre la valeur $p=(i-1)!\times i=i!=((i+1)-1)!$ donc la propriété est vérifiée en sortie de boucle;
\item enfin, au dernier tour de boucle, $i$ vaut $n$ donc $p=n!$ ce qui répond à la question.\\
\end{enumerate}

\subsection{Un troisième exemple : algorithme d'Euclide}
\url{https://lgarcin.github.io/CoursPythonCPGE/preuve.html}

\begin{lstlisting}
def pgcd(a, b):
  while b!= 0:
      a, b = b, a % b
  return a
\end{lstlisting}

On suppose que l'argument $b$ est un entier naturel. En notant $b_k$ la valeur de $b$ à la fin de la $k^\text{ème}$ itération ($b_0$ désigne la valeur de $b$ avant d'entrer dans la boucle), on a $0\leq b_{k+1}<b_k$ si $b_k>0$. La suite $(b_k)$ est donc une suite strictement décroissante d'entiers naturels : elle est finie et la boucle se termine.


On note $a_k$ et $b_k$ les valeurs de a et b à la fin de la $k^\text{ème}$ itération ($a_0$ et $b_0$ désignent les valeurs de $a$ et $b$ avant d'entrer dans la boucle). Or, si $a=bq+r$, il est clair que tout diviseur commun de $a$ et $b$ est un diviseur commun de $b$ et $r$ et réciproquement. Notamment, $a\wedge b=b\wedge r$. Ceci prouve que $a_k\wedge b_k=a_{k+1}\wedge b_{k+1}$. La quantité $a_k\wedge b_k$ est donc bien un invariant de boucle. En particulier, à la fin de la dernière itération (numérotée $N$), $b_N=0$ de sorte que $a_0\wedge b_0=a_N\wedge b_N=a_N\wedge0=a_N$. La fonction \texttt{pgcd} renvoie donc bien le \texttt{pgcd} de $a$ et $b$.

\subsection{Un troisième exemple (bis) : algorithme d'Euclide}
\url{https://mathematice.fr/fichiers/cpge/infoprepaC8.pdf}

On effectue la division euclidienne de $a$ par $b$ où $a $et $b$ sont deux entiers strictement positifs. Il s’agit
donc de déterminer deux entiers $q$ et $r$ tels que $a = bq+r$ avec $0 \leq r < b$. Voici un algorithme déterminant
$q$ et $r$ :

\begin{lstlisting}
q = 0
r = a
while r >= b :
    q = q + 1
    r = r -b
\end{lstlisting}

On choisit comme invariant de boucle la propriété $a = bq + r$.
\begin{itemize}
\item Initialisation : $q$ est initialisé à 0 et $r$ à $a$, donc la propriété $a = bq + r = b\cdot 0 + a$ est vérifiée avant le premier passage dans la boucle.
\item Hérédité : avant une itération arbitraire, supposons que l’on ait $a = bq + r$ et montrons que cette propriété est encore vraie après cette itération. Soient $q'$ la valeur de $q$ à la fin de l’itération et $r'$ la valeur de $r$ à la fin de l’itération. Nous devons montrer que $a = bq' + r'$. On a $q'= q + 1$ et $r' = r- b$, alors $bq' + r' = b(q + 1) + (r - b) = bq + r = a$. La propriété est bien conservée.
\end{itemize}


\textbf{Terminaison}
Nous reprenons l’exemple précédent.
\begin{itemize}
\item Commençons par montrer que le programme s’arrête : la suite formée par les valeurs de $r$ au cours
des itérations est une suite d’entiers strictement décroissante : $r$ étant initialisé à $a$, si $a \geq b$ alors
la valeur de $r$ sera strictement inférieure à celle de $b$ en un maximum de $a - b$ étapes.
\item Ensuite, si le programme s’arrête, c’est que la condition du "tant que" n’est plus satisfaite, donc
que $r < b$. Il reste à montrer que $r \geq 0$. Comme $r$ est diminué de $b$ à chaque itération, si $r < 0$,
alors à l’itération précédente la valeur de $r$ était $r' = r + b$ ; or $r' < b$ puisque $r < 0$. Et donc la
boucle se serait arrêtée à l’itération précédente, ce qui est absurde; on on déduit que $r \geq 0$.
\end{itemize}
En conclusion, le programme se termine avec $0 \leq r < b$ et la propriété $a = bq + r$ est vérifiée à chaque
itération; ceci prouve que l’algorithme effectue bien la division euclidienne de $a$ par $b$.



\subsection{Quatrième exemple }
L’objectif est de calculer le produit de deux nombres entiers positifs $a$ et $b$ sans utiliser de multiplication.
\begin{lstlisting}
p = 0
m = 0
while m < a :
    m = m + 1
    p = p + b
\end{lstlisting}

Comme dans l’exemple précédent, le programme se termine car la suite des valeurs de $m$ est une suite
d’entiers consécutifs strictement croissante, et atteint la valeur $a$ en $a$ étapes.

Un invariant de boucle est ici : $p = m.b$.

\begin{itemize}
\item Initialisation : avant le premier passage dans la boucle, $p = 0$ et $m = 0$, donc $p = mb$.
\item Hérédité : supposons que $p = mb$ avant une itération; les valeurs de $p$ et $m$ après l’itération sont
$p'= p + b$ et $m' = m + 1$. Or $p'= (p + b) = m.b + b = (m + 1)b = m'b$. Donc la propriété
reste vraie.
\item Conclusion : à la sortie de la boucle $p = m.b$.
\end{itemize}
Puisqu’à la sortie de la boucle $m = a$, on a bien $p = ab$.