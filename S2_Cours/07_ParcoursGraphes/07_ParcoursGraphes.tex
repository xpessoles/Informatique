

\subsection{Piles et files}

\subsubsection{Pile}
\begin{defi}{Pile}
Une pile est une structure de données dans laquelle le dernier élément stocké est le premier à en sortir. On parle de principe \textit{LIFO} pour \textit{Last In First Out}. Le dernier élément stocké est appelé \textbf{sommet}.
\end{defi}

Pour gérer une pile, indépendamment de la façon dont elle est implémentée, on suppose exister les opérations élémentaires suivantes : 
\begin{itemize}
\item création d'une pile vide;
\item test si une pile est vide;
\item rajout d'un élément au sommet de la pile;
\item accès au sommet d'une pile non vide;
\item suppression (et renvoi) du sommet d'une pile non vide.
\end{itemize}

Théoriquement, chacune de ces opérations doit se faire à \textbf{temps constant}.

Une des possiblités pour implémenter les piles est d'utiliser le module \texttt{deque}. Chacun des éléments de la pile peut être un objet de type différent.

\begin{lstlisting} 
from collections import deque

# Création d'une pile vide
pile = deque() 

# Test si une pile est vide
len(pile) == 0

# Ajout de l'élément Truc au sommet de la pile
pile.append("Truc")

# Suppression (et renvoi) du sommet d'une pile non vide
sommet = pile.pop()
\end{lstlisting}



\subsubsection{File}
\begin{defi}{File}
Une file est une structure de données dans laquelle le premier élément stocké est le premier à en sortir. On parle de principe \textit{FIFO} pour \textit{First In First Out}. 
\end{defi}

Pour gérer une file, indépendamment de la façon dont elle est implémentée, on suppose exister les opérations élémentaires suivantes : 
\begin{itemize}
\item création d'une file vide;
\item test si une file est vide;
\item rajout d'un élément dans la file;
\item suppression (et renvoi) du premier élément innséré dans la file.
\end{itemize}

Théoriquement, chacune de ces opérations doit se faire à \textbf{temps constant}.

Une des possiblités pour implémenter les piles est d'utiliser le module \texttt{deque}. Chacun des éléments de la file peut être un objet de type différent. Dans cette vision des files, les éléments sont ajoutés << à droite >> et sortent de la file << par la gauche >>.

\begin{lstlisting} 
from collections import deque

# Création d'une file vide
file = deque() 

# Teste si une pile est vide
len(file) == 0

# Ajoute l'élément Truc dans la file 
file.append("Truc")

# Suppression (et renvoi) du premier élément inséré dans la file
sommet = pile.popleft()

\end{lstlisting}


\subsection{Parcours générique d'un graphe}

\begin{defi}{Parcours générique}
Soit in graphe $G=(S,A)$. On parle de parcours générique d'un graphe lorsqu'on souhaite savoir, à partir du sommet $S_i$, quels sont les sommets accessibles. 
\end{defi}

\subsection{Parcours en largeur}

\subsection{Parcours en profondeur}

\subsection{Détection de la présence des cycles}

\subsection{Connexité d'un graphe non orienté}

\section{Pondération d'un graphe}



\section{Recheche du plus court chemin}
\subsection{Algorithme de Dijkstra}

\subsection{Algorithme A$\star$}

\begin{defi}{}
\end{defi}

\begin{defi}{}
\end{defi}

\begin{defi}{}
\end{defi}

\begin{defi}{}
\end{defi}

\begin{defi}{}
\end{defi}
