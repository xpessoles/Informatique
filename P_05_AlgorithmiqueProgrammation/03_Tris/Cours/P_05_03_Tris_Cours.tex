\documentclass[10pt,fleqn]{article} % Default font size and left-justified equations
\usepackage[%
    pdftitle={Informatique : Tris d'une liste de valeurs numériques},
    pdfauthor={Xavier Pessoles}]{hyperref}

\input{style/new_style}
\input{style/macros_SII}
\usepackage{colortbl}
%\fichetrue
\fichefalse

%\proftrue
\proffalse

%\tdtrue
\tdfalse

\courstrue
%\coursfalse

% -------------------------------------
% Déclaration des titres
% -------------------------------------

\def\discipline{Informatique}
\def\xxtete{Informatique}
\def\classe{PT}
\def\xxnumpartie{Partie 5}
\def\xxpartie{Algorithmique \& Programmation (Suite)}

\def\xxnumchapitre{Chapitre 3}
\def\xxchapitre{\hspace{.12cm} Tri d'une liste de valeurs numériques}

\def\xxposongletx{2}
\def\xxposonglettext{1.45}
\def\xxposonglety{13}%10

\def\xxonglet{Part. 5 -- Ch. 3}

\def\xxactivite{Cours}
\def\xxauteur{\textsl{Patrick Beynet \\ Xavier Pessoles}}

\def\xxcompetences{%
\textsl{%
\textbf{Savoirs et compétences :}
\begin{itemize}[label=\ding{112},font=\color{ocre}] 
\item ***%Alg -- C16 : Piles - Algorithmes de manipulation : fonctions «push» et «pop.
\end{itemize}
}}

\def\xxfigures{
%\includegraphics[width=\textwidth]{images/hanoi}

\textit{Tour de Hanoi [2]}
}%figues de la page de garde

\def\xxpied{%
Partie 5 -- Algorithmique et Programmation\\
Ch 3 : Tri d'une liste de valeurs numériques -- \xxactivite%
}

%---------------------------------------------------------------------------
\begin{document}
\chapterimage{png/Fond_ALG}
\input{style/new_pagegarde}
%---------------------------------------------------------------------------

\section{Présentation}
Un algorithme de tri est un algorithme qui permet d'organiser une collection d'objets selon un ordre déterminé. Le tri permet notamment de faciliter les recherches ultérieures d’un élément dans une liste (recherche dichotomique).
On s’intéresse ici à des méthodes de tri d’une liste de valeurs numériques. Celle-ci est implémentée sous la forme d’un tableau à une dimension.

\begin{rem}
Pour trier des chaînes de caractères (mots), il suffit d’associer une valeur numérique à chaque caractère (code ASCII par exemple). 
On se limite dans le cadre du programme aux cas détaillés du tri par insertion, du tri rapide et du tri fusion.
\end{rem}

\section{Tri par insertion}
\subsection{Exemple du tri de carte}

Soit un paquet de « $n$ » cartes. On prend la première dans une main.
On saisie la seconde carte et on l’insère avant ou après la première selon le cas.
A l’étape « $i$ », la ième carte est insérée à sa place dans le paquet déjà trié. 
Pour cela, on peut :
\begin{itemize}
\item soit partir du début du tas déjà trié et s’arrêter lorsqu'on rencontre une carte plus grande que la i\ieme (méthode 1);
\item soit partir de la fin du tas déjà trié, et s’arrêter si on rencontre une carte plus petite que la i\ieme (méthode 2).
\end{itemize}
Le paquet contient alors « $i$ » cartes triées. On procède ainsi de suite jusqu’à la dernière carte.

\subsection{Application à une liste de nombres}

\begin{tabular}{|c|c|c|c|c|}
\hline
5 & 8 & 3 & 2 & 9 \\
\hline
\end{tabular}

\begin{minipage}[b]{.1\linewidth}
Étape 1 
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{|c|c|c|c|c|}
\hline
\cellcolor{black!10}5 & \cellcolor{black!30}8 & 3 & 2 & 9 \\
\hline
\end{tabular}
\end{minipage}\hfill
\begin{minipage}[b]{.1\linewidth}
$$
\Longrightarrow
$$
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{|c|c|c|c|c|}
\hline
\cellcolor{black!10}5 & \cellcolor{black!30}8 & 3 & 2 & 9 \\
\hline
\end{tabular}
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{ll}
1 comparaison & 1 comparaison \\
0 affectation & 0 affectation \\
\end{tabular}
\end{minipage}


\begin{minipage}[b]{.1\linewidth}
Étape 2
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{|c|c|c|c|c|}
\hline
\cellcolor{black!10}5 & \cellcolor{black!10}8 & \cellcolor{black!30}3 & 2 & 9 \\
\hline
\end{tabular}
\end{minipage}\hfill
\begin{minipage}[b]{.1\linewidth}
$$
\Longrightarrow
$$
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{|c|c|c|c|c|}
\hline
\cellcolor{black!30} 3 & \cellcolor{black!10}5 & \cellcolor{black!10}8 & 2 & 9 \\
\hline
\end{tabular}
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{ll}
1 comparaison & 2 comparaisons \\
3 affectations & 3 affectations \\
\end{tabular}
\end{minipage}


\begin{minipage}[b]{.1\linewidth}
Étape 3
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{|c|c|c|c|c|}
\hline
\cellcolor{black!10}3 & \cellcolor{black!10}5 & \cellcolor{black!10}8 & \cellcolor{black!30}2 & 9 \\
\hline
\end{tabular}
\end{minipage}\hfill
\begin{minipage}[b]{.1\linewidth}
$$
\Longrightarrow
$$
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{|c|c|c|c|c|}
\hline
\cellcolor{black!30}2 & \cellcolor{black!10}3 & \cellcolor{black!10}5 & \cellcolor{black!10}8 & 9 \\
\hline
\end{tabular}
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{ll}
1 comparaison & 3 comparaisons \\
4 affectations & 4 affectations \\
\end{tabular}
\end{minipage}


\begin{minipage}[b]{.1\linewidth}
Étape 4
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{|c|c|c|c|c|}
\hline
\cellcolor{black!10}2 & \cellcolor{black!10}3 & \cellcolor{black!10}5 & \cellcolor{black!10}8 & \cellcolor{black!30}9 \\
\hline
\end{tabular}
\end{minipage}\hfill
\begin{minipage}[b]{.1\linewidth}
$$
\Longrightarrow
$$
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{|c|c|c|c|c|}
\hline
\cellcolor{black!10}2 & \cellcolor{black!10}3 & \cellcolor{black!10}5 & \cellcolor{black!10}8 & \cellcolor{black!30}9 \\
\hline
\end{tabular}
\end{minipage}\hfill
\begin{minipage}[b]{.2\linewidth}
\begin{tabular}{ll}
4 comparaisons & 1 comparaison \\
0 affectation & 0 affectation \\
\end{tabular}
\end{minipage}


L’analyse de la complexité de l’algorithme peut se faire par l’étude du nombre de comparaisons à effectuer.

Dans le cas de la méthode 1 : 
\begin{itemize}
\item meilleur des cas : le tableau est trié à l’envers. Il y a donc $n - 1$ comparaisons à effectuer. La complexité est donc de classe linéaire : $C(n)=\mathcal{O}(n)$;
\item pire des cas, le tableau est déjà trié. Il y a alors une comparaison à effectuer à la première étape, puis deux, … puis $n-1$. On en déduit donc un nombre total de $\dfrac{n\left(n-1\right)}{2}$ comparaisons. La complexité est donc de classe quadratique : $C(n)=\mathcal{O}\left(n^2\right)$.
\end{itemize}

Dans le cas de la méthode 2 : 
\begin{itemize}
\item meilleur des cas : le tableau est déjà trié. Il y a donc $n - 1$ comparaisons à effectuer. La complexité est donc de classe linéaire : $C(n)=\mathcal{O}(n)$;
\item pire des cas, le tableau est trié à l’envers. Il y a alors une comparaison à effectuer à la première étape, puis deux, … puis $n-1$. On en déduit donc un nombre total de $\dfrac{n\left(n-1\right)}{2}$  comparaisons. La complexité est donc de classe quadratique : $C(n)=\mathcal{O}\left(n^2\right)$.


\end{itemize}


\begin{exemple}
Le tri de cartes.
\end{exemple}

\begin{rem}
On peut aussi montrer que la complexité en moyenne est de classe quadratique lorsque les permutations sont équiprobables. L’efficacité du tri par insertion est excellente lorsque le tableau est déjà trié ou « presque trié » ($C(n)=\mathcal{O}\left(n\right)$). Il surpasse alors toutes les autres méthodes de tri qui sont au mieux en $\mathcal{O}\left(n ln(n)\right)$.
\end{rem}

\section{Le tri rapide (\textit{Quicksort})}


\begin{exemple}
Tri de valeurs numériques
Problème : Comment trier une liste de nombres par la méthode de « tri rapide » ?
\end{exemple}
L’algorithme fait parti de la catégorie des algorithmes « diviser pour régner ».
À chaque appel de la fonction de tri, le nombre de données à traiter est diminué de un. C'est-à-dire que l’on ne traite plus l’élément appelé « pivot » dans les appels de fonction ultérieurs, il est placé à sa place définitive dans le tableau.
Le tableau de valeurs est ensuite segmenté en deux parties :
\begin{itemize}
\item dans un premier tableau, toutes les valeurs numériques sont inférieures au « pivot »;
\item dans un second tableau, toutes valeurs numériques sont supérieures au « pivot ».
\end{itemize}

L’appel de la fonction de tri est récursif sur les tableaux segmentés.
On peut par exemple choisir le premier élément du tableau comme « pivot » :




Le « coût » temporel de l’algorithme de tri est principalement donné par des opérations de comparaison sur les éléments à trier. On raisonne donc sur le nombre de données à traiter pour l’analyse de la complexité de l’algorithme.

Dans le pire des cas, un des deux segments est vide à chaque appel de la fonction de tri. Cela arrive lorsque le tableau est déjà trié. Le nombre de données à traiter  pour le i\ieme appel, est $n - i + 1$.
Le nombre total pour n appels de fonction est donc $\dfrac{n(n+1)}{2}$. On peut aussi écrire une relation de récurrence du type $C(n) = C(n-1) + n - 1$
La complexité est donc de classe quadratique $C(n) = \mathcal{O}\left(n^2\right)$.

Dans le meilleur des cas, les deux segments sont de taille égale. Pour un nombre de données à traiter $n$, chacun des segments suivant a donc au plus $\dfrac{n-1}{2}$ éléments (on retire le pivot). On répète ainsi la segmentation des tableaux jusqu’à arriver au plus à un seul élément. 
On peut écrire une relation de récurrence du type $C(n) = 2 C\left(\dfrac{n - 1}{ 2} \right)  +  n - 1$.
 
La complexité est donc de classe quasi linéaire $C(n)=\mathcal{O}\left(n ln(n)\right)$.

\begin{rem}
Certains algorithmes de tri rapide prennent pour « pivot » le dernier élément, la valeur moyenne du premier et du dernier, ou un positionnement aléatoire dans le tableau. Pour se placer dans le meilleur des cas pour chaque segment de tableau, il faut prendre pour pivot la valeur médiane du tableau de valeurs. Le problème est que cette recherche de pivot idéal a aussi un « coût ».
\end{rem}

On écrit tout d’abord l’algorithme effectuant la segmentation du tableau :
\begin{itemize}
\item le pivot (1\ier élément du tableau) est mis à sa place définitive;
\item pour des indices inférieurs, toutes les valeurs sont plus petites ou égales;
\item pour des indices supérieurs, toutes les valeurs sont plus grandes.
\end{itemize}

\section{Le tri fusion}

La méthode de tri fusion pour un tableau de données est la suivante :
\begin{enumerate}
\item on coupe en deux parties à peu près égales les données à trier;
\item on trie les données de chaque partie par la méthode de tri fusion;
\item on fusionne les deux parties en interclassant les données.
\end{enumerate}

L’algorithme est donc récursif. Il fait parti des algorithmes « diviser pour régner ». La récursivité s'arrête car on finit par arriver à des listes composées d'un seul élément et le tri est alors trivial. 

Si l’on s’intéresse au nombre de données à traiter à chaque appel de fonction, la relation de récurrence est du type :
$C(n) = 2 C\left(\dfrac{n}{2}\right)  +  n$.
La méthode de tri fusion a donc une efficacité temporelle comparable au tri rapide en $\mathcal{O}\left(n \ln(n)\right)$. Par contre, elle n'opère pas en place : une zone temporaire de données supplémentaire de taille égale à celle de l'entrée est nécessaire. Des versions plus complexes peuvent être effectuées sur place mais sont moins rapides.

\begin{rem}
D’autres méthodes de tri existent : tri par sélection $\mathcal{O}\left(n^2\right)$, tri à bulles  $\mathcal{O}\left(n^2\right)$, \textit{etc}.
\end{rem}

\section{Synthèse}

\begin{thebibliography}{2}
\bibitem{1}{Patrick Beynet, \textit{Supports de cours de TSI 2}, Lycée Rouvière, Toulon.}

\end{thebibliography}
\end{document}

