\documentclass[10pt]{article}
\input{style/coursHeadings}
\input{style/programHeadings}
\input{style/macros_SII}
\input{style/macros_Titres}
\input{style/macros_Frames}
\usepackage{fancybox}
\newsavebox{\codebox}
\newsavebox{\codeboxx}

%Si le boolen xp est vrai : compilation pour xabi
%Sinon compilation Damien
\newboolean{xp}
\setboolean{xp}{true}

\newboolean{prof}
\setboolean{prof}{false}


% Commenter \proffalse et décommenter \proftrue pour avoir le corrigé
\newif\ifprof
%\proftrue
\proffalse

\usepackage[%
    pdftitle={Devoirs Surveillé 1},
    pdfauthor={Xavier Pessoles},
    colorlinks=true,
    linkcolor=blue,
    citecolor=magenta]{hyperref}


\def\discipline{Informatique}
\def\xxtitre{\ifthenelse{\boolean{xp}}{
Devoir surveillé d'informatique 1}{
Chapitre  -- }}

\def\xxsoustitre{\ifthenelse{\boolean{xp}}{
CI 1 : Architecture matérielle et logicielle \\
CI 2 : Algorithmique et programmation  }{
Partie  -- }}

\def\xxauteur{\ifthenelse{\boolean{xp}}{
Xavier \textsc{Pessoles}}{
}}

\def\xxpied{\ifthenelse{\boolean{xp}}{
DS Informatique\\
\ifprof Corrige \else Sujet \fi}{
\xxtitre}}

\def\xxcathegorie{\ifthenelse{\boolean{xp}}{
2013 -- 2014 \\
Xavier \textsc{Pessoles}}{
Informatique - Cours}}





%---------------------------------------------------------------------------


\begin{document}

\ifthenelse{\boolean{xp}}{\input{style/enteteXP}}{\input{style/enteteDI}}


\ifprof
\begin{center}
\large{\textit{Éléments de corrigé}}
\end{center}
\else
\begin{center}
\large{\textit{Nom : .......................................}}
\end{center}
\fi

\section{Codage des nombres}
Pour tout ce devoir, on dispose d'une machine dont le codage est limité à 8 bits. 

\subsection{Capacités de l'espace machine}
\subparagraph{} \textit{Combien d'entiers est-il possible de coder ? Donner le plus petit et le plus grand nombre qu'il est possible de coder dans les systèmes décimal, binaire et hexadacimal.}

%%% Question 1
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 1}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\usebox{\codebox}
\ifprof
\begin{corrige}
\begin{itemize}
\item Il est possible de coder $2^8=256$ entiers. 
\item Le plus petit est nombre est $0$.
\item Le plus grand est $(255)_{10}=(1111\; 1111)_2 = (FF)_{16}$
\end{itemize}
\end{corrige}
\else
\vspace{3cm}
\fi
\end{minipage}
}}



\subparagraph{} \textit{Quel est le nombre maximum d'entiers relatifs qu'il est possible de coder ? Donner le nombre minimal et le nombre maximal dans le système décimal.}

%%% Question 2
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 2}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
\begin{itemize}
\item Il est possible de coder $2^8=256$ entiers relatifs. 
\item Le plus petit est nombre est $-128$.
\item Le plus grand est $127$.
\end{itemize}
\end{corrige}
\else
\usebox{\codebox}
\vspace{3cm}
\fi
\end{minipage}
}}

\ifprof
\else
\newpage
\fi

\subsection{Conversions}
Dans cette partie, les nombres sont tous des entiers relatifs codés en complément à 2.
 
\subparagraph{} \textit{Convertir le nombre 83 dans le système binaire et dans le système hexadécimal.}

%%% Question 3
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 3}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
$$
(83)_{10} = (0101\;0011)_2 = (53)_{16}
$$
\end{corrige}
\else
\usebox{\codebox}
\vspace{5cm}
\fi
\end{minipage}
}}



\subparagraph{} \textit{Peut-on réaliser la somme 83 + 200 ? Justifier.}

%%% Question 4
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 4}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
Il n'est pas possible de réaliser la somme $200+83$ car $283$ est en dehors des capacités du codage. 
\end{corrige}
\else
\usebox{\codebox}
\vspace{3cm}
\fi
\end{minipage}
}}

\ifprof
\else
\newpage
\fi

\subparagraph{} \textit{Réaliser l'opération 24 - 83. Donner le résultat en binaire.}

%%% Question 5
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 5}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
\begin{enumerate}
\item On a $24-83 =-59$. 
\item Conversion de 59 en binaire : $(59)_{10}=(00111011)_2$.
\item Inversion des bits : $(11000100)_2$.
\item Ajout de 1 :$(11000101)_2$.
\item Au final, $(-59)_{10}=(11000101)_2$.
\end{enumerate}

\end{corrige}
\else
\usebox{\codebox}
\vspace{10cm}
\fi
\end{minipage}
}}


\setcounter{subparagraph}{6}
%\subparagraph{} \textit{Convertir le nombre $(A3)_{16,\mathbb{Z}}$. Coder ce nombre dans le système décimal.}
%
%%%% Question 6
%\vspace{.3cm}
%\noindent\boxput*(-.85,1){
%\colorbox{white}{\textbf{Question 6}}}{
%\setlength{\fboxsep}{10pt}
%\fbox{\begin{minipage}{.95\linewidth}
%\usebox{\codebox}
%\vspace{10cm}
%\end{minipage}
%}}



\subsection{Algorithmique et programmation}
\ifprof
\else
Le but de cette partie est de réaliser un programme permettant de réaliser le codage d'un nombre entier relatif en utilisant le codage en complément à 2. 

\begin{py}
Une chaîne de caractère se comporte comme un liste. En effet prenons par exemple la chaîne de caractères \textsf{exemple} :

\begin{minipage}[c]{.95\linewidth}
\begin{python}
>>> chaine = ''exemple''
>>> print(chaine)
        exemple
>>> len(chaine)  # Retourne le nombre de caractères de la chaine : il y a 7 caractères dans le mot exemple
        7
>>> print(chaine[0]) # Affiche le premier e
        'e'
>>> print(chaine[6]) # Affiche le dernier e
        'e'
>>> for i in range(0,2,1) : # Pour i allant de 0 (inclus) à 2 (exclus) par pas de 1, faire : 
            print(str(i)+'' : ''+chaine[i])
            
        0 : e
        1 : x
>>> chaine = chaine+''s''
>>> print(chaine)
        exemples
>>> chaine = ''Les ''+chaine
>>> print(chaine)
        Les exemples
\end{python}
\end{minipage}
\end{py}
\fi
\subsubsection{Conversion d'un nombre décimal en binaire}
\ifprof
\else

On donne l'extrait de programme suivant permettant de convertir un nombre entier positif en nombre binaire binaire. 


\begin{py}
\begin{minipage}[c]{.5\linewidth}
\begin{python}
nb = 10
dividende = nb
diviseur = 2
resultat = ""
quotient = -nb
    
while quotient != 0 :
    quotient = int(dividende/diviseur)
    reste = dividende - diviseur * quotient
    dividende = quotient
    resultat = str(reste)+resultat
\end{python}
\end{minipage}
\end{py}
\fi

\subparagraph{}\textit{Quel est le type des variables \textsf{dividende} et \textsf{resultat}.}

%%% Question 7
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 7}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
\begin{itemize}
\item \textsl{dividende} est de type int (\textsl{integer}, entier).
\item \textsl{resultat} est de type str (\textsl{string}, chaîne de caractère).
\end{itemize}
\end{corrige}
\else
\usebox{\codebox}
\vspace{3cm}
\fi
\end{minipage}}}



\subparagraph{}\textit{Expliquer la ligne 7. Justifier ce choix.}

%%% Question 8
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 8}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
L'objectif de cette boucle est de déterminer le codage d'un nombre en base 2. Selon la méthode <<naïve>> il faut réaliser des divisions successives par 2  jusqu'à ce que le quotient de la division soit nul. 

La boucle se poursuit donc tant que le quotient est nul.
\end{corrige}
\else
\usebox{\codebox}
\vspace{3cm}
\fi
\end{minipage}}}

\ifprof
\else
\newpage
\fi

\subparagraph{}\textit{On cherche à analyser l'évolution des variables lors du parcours de la boucle \textsf{while}. Remplir les champs suivants.}


%%% Question 9
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 9}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}

\ifprof
\begin{corrige}
\begin{center}
\begin{tabular}{|p{6cm}|p{.3cm} c p{.3cm}|p{.3cm} c p{.3cm}|p{.3cm} c p{.3cm}|p{.3cm} c p{.3cm}|}
\hline
&&&&&&&&&&&& \\
&& \rotatebox{90}{Dividende}&& 
&\rotatebox{90}{Diviseur} &&
&\rotatebox{90}{Résultat} &&
&\rotatebox{90}{Quotient}&
\\
\hline \hline
&&&&&&&&&&&& \\
État des variables après la ligne 6 
&&10&&&2&&&'' ''&&&-10& \\
&&&&&&&&&&&& \\
\hline
&&&&&&&&&&&& \\
État des variables après la ligne 11 - Première itération de la boucle while 
&&5&&&2&&&''0''&&&5& \\
\hline
&&&&&&&&&&&& \\
État des variables après la ligne 11 - Seconde itération de la boucle while 
&&2&&&2&&&''10''&&&2& \\
\hline
&&&&&&&&&&&& \\
État des variables après la ligne 11 - Troisième itération de la boucle while 
&&1&&&2&&&''010''&&&1& \\
\hline
&&&&&&&&&&&& \\
État des variables après la ligne 11 - Quatrième itération de la boucle while 
&&0&&&2&&&''1010''&&&0& \\
\hline
\end{tabular}
\end{center}
\end{corrige}
\else
\textit{Remarque : le document réponse ne présume pas du nombre d'itérations de la boucle while.}
\begin{center}
\begin{tabular}{|p{6cm}|p{.3cm} c p{.3cm}|p{.3cm} c p{.3cm}|p{.3cm} c p{.3cm}|p{.3cm} c p{.3cm}|}
\hline
&&&&&&&&&&&& \\
&& \rotatebox{90}{Dividende}&& 
&\rotatebox{90}{Diviseur} &&
&\rotatebox{90}{Résultat} &&
&\rotatebox{90}{Quotient}&
\\
\hline \hline
&&&&&&&&&&&& \\
État des variables après la ligne 6 &&&&&&&&&&&& \\
&&&&&&&&&&&& \\
\hline
&&&&&&&&&&&& \\
État des variables après la ligne 11 - Première itération de la boucle while 
&&&&&&&&&&&& \\
\hline
&&&&&&&&&&&& \\
État des variables après la ligne 11 - Seconde itération de la boucle while 
&&&&&&&&&&&& \\
\hline
&&&&&&&&&&&& \\
État des variables après la ligne 11 - Troisième itération de la boucle while 
&&&&&&&&&&&& \\
\hline
&&&&&&&&&&&& \\
État des variables après la ligne 11 - Quatrième itération de la boucle while 
&&&&&&&&&&&& \\
\hline
&&&&&&&&&&&& \\
État des variables après la ligne 11 - Cinquième itération de la boucle while 
&&&&&&&&&&&& \\
\hline
&&&&&&&&&&&& \\
État des variables après la ligne 11 - Sixième itération de la boucle while 
&&&&&&&&&&&& \\
\hline
\end{tabular}
\end{center}
%\usebox{\codebox}
\fi
\end{minipage}}}



\subparagraph{}\textit{Parmi les lignes 8, 9 et 10, réaliser des modifications qui permettent de mieux utiliser les opérations disponibles en Pyhon. }


%%% Question 10
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 10}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
\begin{itemize}
\item quotient = dividende // diviseur
\item reste = dividende \% diviseur
\end{itemize}
\end{corrige}
\else
\usebox{\codebox}
\vspace{3cm}
\fi
\end{minipage}}}

\ifprof
\else
\newpage
\fi

\subparagraph{}\textit{Après exécution de la liste que contient la variable \textsf{resultat} ?
 Est-ce le résultat attendu ? Si ce n'est pas le résultat attendu, corriger l'algorithme en conséquence.} 
 
 
%%% Question 11
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 11}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
La variable \textsl{resultat} contient la chaîne de caractère \textsl{1010} ce qui est bien le résultat attendu. 
\end{corrige}
\else
\usebox{\codebox}
\vspace{4cm}
\fi
\end{minipage}}}


\subsubsection{Programme mystère}
On cherche à convertir le nombre $(-10)_{10}$ en base 2. Le système utilisé utilise un codage sur 8 bits. La conversion du nombre $(10)_{10}$ en binaire est $(1010)_{2}$.

\ifprof
\else
On donne cette partie de programme. 
\begin{py}
\begin{minipage}[c]{.75\linewidth}
\begin{python}
res_cv = ''1010''
nb_bits = 8
while(len(res_cv)!=nb_bits):
    res_cv = "0"+res_cv
\end{python}
\end{minipage}
\end{py}
\fi

\subparagraph{}
\textit{Quel est le but du programme précédent ? Que contient \textsf{res\_cv} après l'exécution du code ?}

%%% Question 12
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 12}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
Le programme précédent permet, lorsque les nombre sont codés sur $n$ bits, de compléter les 0 manquants. 

\textsf{res\_cv} contient $0000\;1010$.
\end{corrige}
\else
\usebox{\codebox}
\vspace{4cm}
\fi
\end{minipage}}}


\subsubsection{Inversion des bits}
On cherche maintenant à inverser les bits d'une séquence.
\ifprof
\else
\begin{py}
\begin{minipage}[c]{.75\linewidth}
\begin{python}
res_cv = "1010"
res_inv = ""
for i in range(len(res_cv)):
    if res_cv[i]=="0":
        res_inv=res_inv+"0"
    else :
        res_inv=res_inv+"1"
\end{python}
\end{minipage}
\end{py}
\fi

\ifprof
\else
\newpage
\fi

\subparagraph{}
\textit{Que contient \textsf{res\_inv} après l'exécution de la boucle ?}

%%% Question 13
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 13}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
Après exécution de la boucle, \textsf{res\_inv} contient la séquence ''1010''.
\end{corrige}
\else
\usebox{\codebox}
\vspace{2cm}
\fi
\end{minipage}}}


\subparagraph{}
\textit{Si le résultat obtenu n'est pas le résultat attendu, comment modifier la séquence précédente ?}

%%% Question 14
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 14}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
Le but de la séquence étant précédente étant d'inverser la séquence de bits, l'objectif n'est pas atteint. Il faudrait permuter les lignes 5 et 7. 
\end{corrige}
\else
\usebox{\codebox}
\vspace{2cm}
\fi
\end{minipage}}}


%\begin{center}
%\textbf{Fin des questions}
%\end{center}
\subsubsection{Additionner 1}
Voici une séquence de programme permettant d'ajouter 1 à un nombre codé en binaire.

\ifprof
\else
\begin{py}
\begin{minipage}[c]{.75\linewidth}
\begin{python}
# On ajoute +1
# Initialisation
retenue="1"
res=""
for i in range(len(res_inv)-1,-1,-1):
    if retenue=="0" and res_inv[i]=="0":
        retenue=="0"
        res = "0"+res
    elif retenue=="0" and res_inv[i]=="1":
        retenue ="0"
        res = "1"+res
    elif retenue=="1" and res_inv[i]=="0":
        retenue ="0"
        res = "1"+res
    elif retenue=="1" and res_inv[i]=="1":
        retenue ="1"
        res = "0"+res
\end{python}
\end{minipage}

\end{py}
\fi
  \begin{lrbox}{\codebox}
\begin{python}
\end{python}
\end{lrbox}

  
\subparagraph{}
\textit{Quelles sont les structures algorithmiques utilisées dans ce programme ? Expliquer l'existence des lignes 6, 9, 12 et 15.}

%%% Question 15
\vspace{.3cm}
\noindent\boxput*(-.85,1){
\colorbox{white}{\textbf{Question 15}}}{
\setlength{\fboxsep}{10pt}
\fbox{\begin{minipage}{.95\linewidth}
\ifprof
\begin{corrige}
Les structures algorithmiques utilisées sont : la boucle pour et la structure conditionnelle si ... sinon.

Les 4 combinaisons de si permettent de programme de façon naïve les règles de l'addition binaire : 
\begin{itemize}
\item le résultat de 0 + 0 est 0;
\item le résultat de 0 + 1 est 1;
\item le résultat de 1 + 1 est 0 et on retient 1. 
\end{itemize}

\end{corrige}
\else
\usebox{\codebox}
\vspace{4cm}
\fi
\end{minipage}}}
  

\end{document}
