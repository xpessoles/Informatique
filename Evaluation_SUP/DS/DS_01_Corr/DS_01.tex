\documentclass[11pt,oneside]{article}
\input{style/coursHeadings}
\input{style/programHeadings}


%Si le boolen xp est vrai : compilation pour xabi
%Sinon compilation Damien
\newboolean{xp}
\setboolean{xp}{true}

\newboolean{prof}
\setboolean{prof}{true}

\def\xxtitre{\ifthenelse{\boolean{xp}}{
}{
}}

\def\xxsoustitre{\ifthenelse{\boolean{xp}}{
Devoir Surveillé 1 -- 1 heure}{
Devoir Surveillé 1 -- 1 heure}}

\def\xxauteur{\ifthenelse{\boolean{xp}}{
Xavier \textsc{Pessoles} \\ Damien \textsc{Iceta}}{
Damien \textsc{Iceta} \\ Xavier \textsc{Pessoles}}}

\def\xxpied{\ifthenelse{\boolean{xp}}{
DS 01 -- CI 1 \& CI2 }{
\xxtitre}}

\def\xxcathegorie{\ifthenelse{\boolean{xp}}{
2013 -- 2014 \\
Xavier \textsc{Pessoles}}{
Informatique - DS 01}}

\ifthenelse{\boolean{xp}}{\input{style/enteteXP}}{\input{style/enteteDI}}


%---------------------------------------------------------------------------


\ifthenelse{\boolean{prof}}{
\begin{center}
 \large\textsc{Éléments de corrigés}
\end{center}
}{
\begin{center}
 \large\textsc{CI 1 : Architecture matérielle et logicielle}

 \large\textsc{CI 2 : Algorithmique et programmation}
\end{center}
}
\vspace{.5cm}






%\begin{obj}
%\begin{itemize}
%\item Comprendre un algorithme et expliquer ce qu'il fait
%\item Traduire un algorithme dans un langage de programmation
%\end{itemize}
%\end{obj}
 


%\setlength{\parskip}{0ex plus 0.2ex minus 0ex}
%\renewcommand{\contentsname}{}
%\renewcommand{\baselinestretch}{1}
%\tableofcontents

 \renewcommand{\baselinestretch}{1.2}
\setlength{\parskip}{2ex plus 0.5ex minus 0.2ex}

% \vspace{1cm}
%\textit{Ce document évolue. Merci de signaler toutes erreurs ou coquilles.}

\subsection*{Exercice 1 -- Représentation des nombres}

Notre système d'exploitation permet un codage des nombres entiers sur 8 bits. Les flottants sont codés en simple précision, c'est à dire sur 32 bits.

\ifthenelse{\boolean{prof}}{%
\begin{rem}
\begin{center}
\footnotesize{
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 \\
\hline
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & A & B & C & D & E & F \\
\hline
0000 & 0001 & 0010 & 0011 & 0100 & 0101 & 0110 & 0111 & 
1000 & 1001 & 1010 & 1011 & 1100 & 1101 & 1110 & 1111 \\
\hline
\end{tabular}}
\end{center}
\end{rem}
}{}
\subparagraph{}
\textit{Convertir $(73)_{10}$ et $(-12)_{10}$ en base 2 (binaire) puis en base 16 (hexadécimal).}

\ifthenelse{\boolean{prof}}{%
\begin{corrige}
$$
(73)_{10} =  64 + 8 + 1 =
0 \cdot 2^7 + 
1 \cdot 2^6 + 
0 \cdot 2^5 + 
0 \cdot 2^4 + 
1 \cdot 2^3 + 
0 \cdot 2^2 + 
0 \cdot 2^1 + 
1 \cdot 2^0 
=
(01001001)_2
= 
(49)_{16}
$$
$$
(12)_{10} =  8 + 4 =
0 \cdot 2^7 + 
0 \cdot 2^6 + 
0 \cdot 2^5 + 
0 \cdot 2^4 + 
1 \cdot 2^3 + 
1 \cdot 2^2 + 
0 \cdot 2^1 + 
0 \cdot 2^0 
=
(00001100)_2
= 
(0C)_{16}
$$
Pour coder le signe - on peut utiliser le complément à 2 puis ajouter un : 
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|}
\cline{2-9}
12 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\
\cline{2-9}
\multicolumn{9}{c}{}\\
%\cline{2-9}
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{+1} &
\multicolumn{1}{c}{+1} & 
\multicolumn{1}{c}{}  \\
\cline{2-9}
$\overline{12}$ & 1 & 1 & 1 & 1 & 0 & 0 & 1 & 1 \\
\cline{2-9}
\multicolumn{1}{c}{+1} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} & 
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} & 
\multicolumn{1}{c}{} &
\multicolumn{1}{c|}{+} & 1 \\
\cline{2-9}
\cline{2-9}
= & 1 & 1 & 1 & 1 & 0 & 1 & 0 & 0 \\
\cline{2-9}
\end{tabular}
\end{center}
\end{corrige}
}{}

\subparagraph{}
\textit{Réaliser l'opération $73-12$ en binaire et vérifier le résultat.}

\ifthenelse{\boolean{prof}}{%
\begin{corrige}
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|}
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{+1} &
\multicolumn{1}{c}{+1} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} & 
\multicolumn{1}{c}{}  \\
\cline{2-10}
$\overline{12}+1$ & & 1 & 1 & 1 & 1 & 0 & 1 & 0 & 0 \\
\cline{2-10}
+73 & & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 \\
\cline{2-10}\cline{2-10}
= & 1 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 1 \\
\cline{2-10}
\end{tabular}
\end{center}
Seuls les 8 derniers bits sont pris en compte, on a donc :
$$73 - 12 =61 = \left(00111101\right)_2 = 
0 \cdot 2^7 + 
0 \cdot 2^6 + 
1 \cdot 2^5 + 
1 \cdot 2^4 + 
1 \cdot 2^3 + 
1 \cdot 2^2 + 
0 \cdot 2^1 + 
1 \cdot 2^0 
= 32+16+ 8+4+1 = 61
$$
\end{corrige}
}{}

\begin{rem}
On rappelle que pour les nombres à virgule flottante codés en simple précision, l'exposant est codé sur 8 bits et la mantisse sur 23 bits.

Par ailleurs, 
$$
2^{-1} = 0,5 \quad 2^{-2} = 0,25 \quad 2^{-3} = 0,125 \quad 2^{-4} = 0,0625
$$
\end{rem}

\subparagraph{}
\textit{En utilisant la norme \textsf{IEEE-754}, convertir le nombre -73,3125 en binaire. Vous exprimerez donc le signe, l'exposant et la mantisse.}
\ifthenelse{\boolean{prof}}{%
\begin{corrige}
Exprimons 0,3125 en puissances négatives de 2 :
\begin{center}
\begin{tabular} {cccccc|c|cc}
\cline{7-7}
0,3125 & x & 2 & = & 0,625 & = & 0 & + & 0,625 \\
\cline{7-7}
0,625 & x & 2 & = & 1,25 & = & 1 & + & 0,25 \\
\cline{7-7}
0,25 & x & 2 & = & 0,5 & = & 0 & + & 0,5 \\
\cline{7-7}
0,5 & x & 2 & = & 1 & = & 1 & + & 0,0 \\
\cline{7-7}
\end{tabular}
\end{center}
Au final, 
$$
-73,3125
=(01001001,0101)_2
=(1,0010010101)_2\cdot 2^{6}
$$

L'exposant étant codé sur 8 bits, il faut donc le complémenter sur un octet :
$$ 6 + (2^{8-1}-1)=6+127 = 133 = 128 + 4 + 1 =
1 \cdot 2^7 + 
0 \cdot 2^6 + 
0 \cdot 2^5 + 
0 \cdot 2^4 + 
0 \cdot 2^3 + 
1 \cdot 2^2 + 
0 \cdot 2^1 + 
1 \cdot 2^0 =
(10000101)_2
$$

Au final, on a donc : 
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
1100 & 0010 & 1001 & 0010 & 0101 & 0000 & 0000 & 0000 \\
\hline
C & 2 & 9 & 2 & 5 & 0 & 0 & 0\\
\hline
\end{tabular}
\end{center}
\end{corrige}
}{}
\subparagraph{}
\textit{Transformer alors ce nombre en hexadécimal.}

\ifthenelse{\boolean{prof}}{%
\begin{corrige}
Au final, on a donc : 
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
1100 & 0010 & 1001 & 0010 & 0101 & 0000 & 0000 & 0000 \\
\hline
C & 2 & 9 & 2 & 5 & 0 & 0 & 0\\
\hline
\end{tabular}
\end{center}
\end{corrige}}{}

\subparagraph{}
\textit{Le nombre flottant est codé en hexadécimal de la façon suivante : $(41440000)_{16}$. Donner sa valeur dans le système décimal.}

\ifthenelse{\boolean{prof}}{%
\begin{corrige}
Commençons par convertir le nombre en binaire :
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
0100 & 0001 & 0100 & 0100 & 0000 & 0000 & 0000 & 0000 \\
\hline
4 & 1 & 4 & 4 & 0 & 0 & 0 & 0\\
\hline
\end{tabular}
\end{center}

Le premier 0 indique que le nombre est positif. 

L'exposant correspond aux chiffres suivants $(10000010)_2 = 128 + 2 =130$. 
L'exposant correspondant est donc $130-127=3$.

La mantisse est donnée par : $(10001000000000000000000)_2$. Le nombre correspondant est donc : $(1,10001)_2 \cdot 2^3 =(1100,01)_2 = 12,25$.

\end{corrige}}{}


\subsection*{Exercice 2 -- Programmation}
\textit{D'après P. Soleillant}
\setcounter{subparagraph}{0}

Le programme donné ci-dessous permet à un joueur de trouver un nombre entier choisi aléatoirement par l'ordinateur.

\begin{py}
\begin{python}
# Chargement des bibliotheques necessaires
from random import randint

""" Mise en oeuvre du jeu du plus-moins. 
L'utilisateur doit deviner le nombre entre 1 et 100 choisi par l'ordinateur. """		

inconnue=randint(1,100)
		
# Debut du jeu
b=int(input("Devinez le nombre entre 1 et 100 choisi"))
		
while b != inconnue :
    if b < inconnue :
        b=int(input("Perdu ! Le nombre a trouver est plus (1) ..."))
    else :
        b=int(input("Perdu ! Le nombre a trouver est plus (2) ..."))

# Lorsque le bon nombre est trouve c'est gagne	
print("Bingo ! Le nombre a deviner etait bien",inconnue)

\end{python}
\end{py}

\subparagraph{}
\textit{Expliquer la signification de la ligne suivante :}
\begin{py}
\begin{python}
while b != inconnue :
\end{python}
\end{py}

\ifthenelse{\boolean{prof}}{%
\begin{corrige}
On stocke le nombre aléatoire fixé par l'ordinateur dans la variable \textsf{inconnue}. La valeur saisie par l'utilisateur est stockée dans la variable \textsf{b}. 

Les instructions contenues dans le paragraphe indenté seront exécutées tant que le nombre proposé par le joueur sera différent du nombre aléatoire fixé par l'ordinateur.

\end{corrige}}{}


\subparagraph{}
\textit{Après avoir observé le programme donné, déterminer les informations à mettre en (1) et (2).}
\ifthenelse{\boolean{prof}}{%
\begin{corrige}

(1) : le nombre à trouver est plus grand

(2) : le nombre à trouver est plus petit

\end{corrige}}{}


\subparagraph{}
\textit{Modifier le programme pour que, lorsque le joueur propose un nombre $n$ tel que $|n-${\sffamily inconnue}$| \leq 5$, on lui précise qu'il est proche de {\sffamily inconnue}, tandis que, si $|n-${\sffamily inconnue}$| \geq 25$, on lui indique qu'il en est est loin.}



\ifthenelse{\boolean{prof}}{%
\begin{corrige}
\begin{py}
\begin{python}
b=int(input("Devinez le nombre entre 1 et 100 choisi"))
while b != inconnue :
    if b < inconnue :
        if inconnue-b<=5:
            b=int(input("Perdu ! Le nombre a trouver est peu un plus grand ..."))
        else :
            b=int(input("Perdu ! Le nombre a trouver est beaucoup plus grand ..."))
    else :
        if b-inconnue<=5:
            b=int(input("Perdu ! Le nombre a trouver est un peu plus petit ..."))
        else : 
            b=int(input("Perdu ! Le nombre a trouver est beaucoup plus petit ..."))
\end{python}
\end{py}
\end{corrige}
}{}





\subparagraph{}
\textit{Modifier le programme pour qu'il affiche, en fin de partie, le nombre de coups joués.}

%\ifthenelse{\boolean{prof}}{%
\begin{corrige}
\begin{py}
\begin{python}
b=int(input("Devinez le nombre entre 1 et 100 choisi"))
i=1 # Nombre de coups joues
while b != inconnue :
    i=i+1
    if b < inconnue :
        b=int(input("Perdu ! Le nombre a trouver est plus grand ..."))
    else :
        b=int(input("Perdu ! Le nombre a trouver est plus petit ..."))

print(i," coups ont ete joues")
\end{python}
\end{py}

\end{corrige}
%}{}

\subparagraph{}
\textit{Modifier le programme pour qu'il affiche, en fin de partie, le moyenne des nombres proposés par le joueur.}

%\ifthenelse{\boolean{prof}}{%
\begin{corrige}
\begin{py}
\begin{python}
b=int(input("Devinez le nombre entre 1 et 100 choisi"))
somme = b
i=1 # Nombre de coups joues
while b != inconnue :
    i=i+1
    if b < inconnue :
        b=int(input("Perdu ! Le nombre a trouver est plus grand ..."))
    else :
        b=int(input("Perdu ! Le nombre a trouver est plus petit ..."))
    somme = somme+b
print(i," coups ont ete joues")
print("Moyenne des coups joues :",somme/i)
\end{python}
\end{py}

\end{corrige}
%}{}



\end{document}
