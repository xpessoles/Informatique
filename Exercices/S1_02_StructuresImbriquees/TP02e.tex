\input entete

\large MPSI \hfill TP02: Algorithmes de recherche.

\newcommand{\indente}{\hspace*{1cm}}

\smallskip
\hline

\bigskip



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip1cm

\section{Trouver les deux valeurs les plus proches dans un tableau}


\be \q On se donne un tableau \texttt{T} unidimensionnel. \'Ecrire une fonction \texttt{distance\_min1(T)} qui renvoie les deux éléments qui sont les plus proches ie dont la valeur absolue de la différence est minimale. On indiquera les valeurs obtenues ainsi que les indices correspondants.

\q Pour un tableau à $n$ cases, montrer que le nombre de comparaisons $C(n)$ faites dans cette fonction est tel que la suite $\left(\Frac{C(n)}{n^2}\right)$ est bornée: on dit que la  \textbf{complexité est quadratique}.

\q Faire la même question pour un tableau bidimensionnel en écrivant une fonction \texttt{distance\_min2(T)}. Ici, \texttt{T} sera donc une matrice pas nécessairement carrée par exemple de la forme $$\texttt{T=[[1,2,3],[6,4,3],[3,8,9],[3,-2,0]]}:$$ chaque élément de \texttt{T} désignera une ligne du tableau. Le nombre de ligne est le nombre d'éléments de \texttt{T}, le nombre de colonnes est le nombre d'éléments de \texttt{T[0]}.


\ee

\section{Recherche d'un mot dans un texte}

\be\q \'Ecrire une fonction \texttt{est\_ici(texte,motif)} qui, étant données deux chaines de caractères \texttt{texte}  et \texttt{motif}, renvoie \texttt{True} ou \texttt{False} selon que mot est ou n'est pas dans texte. On n'utilisera pas de slicing mais on fera deux méthodes, l'une sans booléen explicite, l'autre avec.

\q \'Ecrire une fonction \texttt{est\_sous\_mot(texte,motif)} qui renvoie \texttt{True} ou \texttt{False} selon que motif est dans texte ou pas.

\q \'Ecrire une fonction \texttt{position\_sous\_mot(texte,motif)} qui renvoie la liste de toutes les occurences de l'indice de position du mot \texttt{motif} dans \texttt{texte}.

\ee

\section{Tri à bulles}


Le tri à bulles est un algorithme de tri classique. Son principe est simple, et il est très
facile à implémenter.
On considère un tableau de nombres $T$, de taille $N$. L'algorithme parcourt le tableau, et dès que deux éléments consécutifs ne sont pas ordonnés, les échange. Après un premier passage, on voit que le plus grand élément se situe bien en dernière position. On peut donc recommencer un tel passage, en s'arrêtant à l'avant-dernier élément, et ainsi de suite.

Au $i$-ème passage on fait remonter le $i$-ème plus grand élément du tableau à sa position définitive, un peu à la manière de bulles qu'on ferait remonter à la surface d'un liquide, d'où le nom d'algorithme de tri à bulles.

\begin{center}
    \includegraphics[scale=0.7]{TriBulles.png}
\end{center}

\be\q Appliquer l'algorithme de tri à Bulles <<à la main>> au tableau ci-dessous: $$\begin{array}{|c|c|c|c|c|c|}
    \hline2& 1 & 6 & 9 & 8 & 4 \\
    \hline\end{array}$$

\q Ecrire une fonction \texttt{est\_trie(T)} qui renvoie \texttt{True} ou \texttt{False} selon que le tableau \texttt{T} est trié ou pas.

\q Écrire une fonction \texttt{TriBulles(T)} triant le tableau \texttt{T} par l'algorithme de tri à
bulles \footnote{cette fonction doit agir sur place concernant le tableau \texttt{T} ie doit le modifier par effet de bord.}


\q Vérifier que la fonction ci-dessus est correcte en utilisant la fonction \texttt{EstTrie} sur des  tableaux de nombres aléatoires. On rappelle que la bibliothèque random permet de créer des nombres aléatoires. \texttt{random.randint(a,b)} renvoie un entier aléatoire compris entre $a$ et $b$.

\q Montrer que la complexité est quadratique (notion définie dans I)

\q Ecrire une fonction améliorée \texttt{TriBulles2(T)} qui sort de la fonction dès que le tableau a été parcouru sans faire d'échange (auquel cas, il est trié et donc inutile de continuer).

\q Une variante du tri à bulles est le tri cocktail: il consiste à changer de direction à chaque passage. Lors
du premier parcours, on se déplace du début du tableau vers la fin. Puis lors du second parcours on
part de la fin du tableau pour arriver au début. A la troisième itération on part du début et ainsi de
suite ... C'est une légère amélioration car il permet non seulement aux plus grands éléments de
migrer vers la fin de la série mais également aux plus petits éléments de migrer vers le début.

\medskip \'Ecrire une fonction \texttt{TriCocktail(T)} qui étant donné un tableau \texttt{T} le renvoie trié selon la méthode du tri cocktail.

Justifier en quoi cette variante peut être intéressante selon le type de tableau à trier mais vérifier néanmoins que la complexité reste quadratique.

\ee








 

 \fin
