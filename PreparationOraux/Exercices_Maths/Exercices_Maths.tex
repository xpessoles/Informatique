\documentclass[10pt,fleqn]{article} % Default font size and left-justified equations
\usepackage[%
    pdftitle={CIN : Cinématique du solide},
    pdfauthor={Xavier Pessoles}]{hyperref}
%\usepackage{pdfpages}

\input{style/new_style}
\input{style/macros_SII}

%\fichetrue
\fichefalse

%\proftrue
\proffalse

%\tdtrue
\tdfalse

\courstrue
%\coursfalse

% -------------------------------------
% Déclaration des titres
% -------------------------------------

\def\discipline{Informatique}
\def\xxtete{Informatique}

\def\classe{\textsf{PT -- PT} $\star$}
\def\xxnumpartie{Oral}
\def\xxpartie{Préparation aux oraux de la banque PT}

\def\xxnumchapitre{Préparation aux oraux de la banque PT}
\def\xxchapitre{\hspace{.12cm} Épreuve de << Mathématiques et Algorithmique >>}

\def\xxposongletx{2}
\def\xxposonglettext{1.45}
\def\xxposonglety{20}
\def\xxonglet{\textsf{Oral}}

\def\xxactivite{Exercices}
\def\xxauteur{\textsl{Xavier Pessoles} \\ D'après Banque PT et L'informatique pas à pas en prépa.}

\def\xxcompetences{%
%\textsl{%
%\textbf{Savoirs et compétences :}
%\begin{itemize}[label=\ding{112},font=\color{ocre}] 
%\item Mod-C11 : Modélisation géométrique et cinématique des mouvements entre solides indéformables 
%\begin{itemize}[label=\ding{112},font=\color{ocre}] 
%\item Mod-C11.2 : Champ des vecteurs vitesses des points d'un solide
%\item Mod-C11.4 : Composition des vitesses
%\item Mod-C11.6 : Champ des vecteurs accélérations des points d'un solide
%\item Mod-C11.6 : Composition des accélérations
%\item Mod-C11-S5 : Déterminer la trajectoire d’un point d’un solide
%\item Mod-C11-S8 : Écrire le vecteur accélération d’un point d’un solide
%\end{itemize}
%\end{itemize}
%%}
}

\def\xxfigures{
}%figues de la page de garde
\def\xxpied{%
Préparation aux oraux de la banque PT \\
Préparation à l'épreuve de << Mathématiques et Algorithmique >>%
}

%---------------------------------------------------------------------------


\begin{document}
\chapterimage{png/Fond_ALG}
\input{style/new_pagegarde}

\newpage
\def\columnseprulecolor{\color{ocre}}
\setlength{\columnseprule}{0.4pt} 

\section{Avant-propos}
Ce recueil d'exercices est réalisé à partir de 3 sources : 
\begin{itemize}
\item des exercices <<zeros>> de la banque PT; 
\item d'exercices retranscrits par vos prédécesseurs en 2015 (Lycée Mimard de Saint-Étienne et Lycée La Martinière Monplaisir);
\item d'exercices tirés du livre de Frédéric Butin : \textit{L'informatique pas à pas en prépa. Cours et exercices corrigés. Éditions ellipses.}
\end{itemize}

Ces exercices ont pour but de vous entrainer à la partie <<Informatique>> de l'épreuve de <<Mathématiques et d'algorithmique>> de la banque PT, anciennement << Maths II>>. Cette épreuve se déroule à l'école Arts et Métiers ParitTech de Paris.


\begin{warn}
\large{\textbf{
Afin de vous mettre dans les conditions de l'épreuve, je vous encourage très très très vivement à utiliser IDLE. IDLE est disponible avec toute installation de Python, Pyzo ou WinPython. 
Pour cela, aller dans le dossier contenant Pyzo puis dans le répertoire \texttt{Lib$\backslash$idlelib} et lancer le programme \texttt{idle.bat}.}

\textbf{Pour réaliser les exercices vous aurez accès à un aide-mémoire des fonctions Python  (qui devrait être agrafé à ce document si je n'oublie pas !}}
\end{warn}

\subsection*{Notes pour les PT $\star$ (et les autres)}

L'objectif pour vous est de réaliser le maximum d'exercices afin de vous entraîner afin que vous puissiez <<parler python couramment>>.  Vous aurez deux créneaux pour vous entrainer (ce qui ne vous dispense pas de vous entrainer chez vous). Un créneau en parallèle du TD de maths avec Mme Gaggioli. Pendant ce créneau vous travaillerez en autonomie. Un créneau le vendredi matin où je serai là pour vous aider ou pour répondre à vos questions. 


\subsection*{Remarques concernant les corrigés}
Je n'ai pas eu le temps de réaliser les corrigés de chacun des exercices. Concernant les corrigés des exercices de F. Butin, or mention spéciale, les corrigés sont ceux que je propose. Pour les exercices sans corrigé, on peut donc les retrouver dans le bouquin. 

Pour les exercices retranscrits, il se peut qu'il y ait des erreurs de texte (de ma part ou de la part des anciens élèves). Merci de me les rapporter à l'adresse \textbf{\url{xpessoles.ptsi@free.fr}}. 

Par ailleurs, vous pouvez proposer des corrigés que j'ajouterai à ce document ce qui vous vaudra d'avoir votre non cité dans ce recueil ainsi que mon entière considération !

\subsection*{Remarques concernant les exercices retranscrits}

Comme vous le voyez, cette préparation repose en partie sur le retranscription des exercices de vos prédécesseurs. Afin d'améliorer la préparation des futurs élèves, je vous demande donc, à votre tour, à la fin de l'épreuve, de noter immédiatement le texte des exercices et de me les envoyer (ainsi qu'à Madame Gaggioli !). 

\subsection*{Conseils divers et variés}
\begin{itemize}
\item Exercez-vous !
\item Pratiquez du Python !!
\item Ne vous jetez pas sur les corrigés, mais réfléchissez !
\item Réfléchissez encore un peu !!
\item Variez les plaisirs en faisant un peu d'arithmétique, un peu d'équa diff, un peu de courbes ...
\item Exercez-vous à utiliser les bibliothèques de \texttt{numpy} pour manipuler les vecteurs et les matrices.
\item Exercez-vous à utiliser les bibliothèques de \texttt{scipy} pour résoudre les équations différentielles.
\end{itemize}

\subsection*{Liens...}

Le PDF à jour des différentes modifications est disponible ici : \url{https://goo.gl/8mK4tx}

Les différents corrigés Python ou fichiers nécessaires à certains exercices sont disponibles ici : \url{https://goo.gl/XiIWH7}


\begin{flushright}
\textbf{Pour finir, à la fin des épreuves, n'oubliez pas de m'envoyer vos exercices, impressions \textit{etc.}}

\textbf{Et surtout... m**** pour vos épreuves !}

\textbf{Xavier Pessoles}
\end{flushright}

\newpage


\begin{multicols}{2}
\section{Recueil d'exercices issus de la banque PT}

\addcontentsline{toc}{subsection}{Exercice 1 -- Arithmétique}
\subsection*{Exercice 1 -- Arithmétique}
\begin{enumerate}
\item Soit l’entier $n = 1234$. Quel est le quotient, noté $q$, dans la division euclidienne de $n$ par $10$ ? Quel est
le reste ? Que se passe-t-il si on recommence la division par 10 à partir de $q$ ?
\item Écrire la suite d’instructions calculant la somme des cubes des chiffres de l’entier 1234.
\item Écrire une fonction \texttt{somcube}, d’argument \texttt{n}, renvoyant la somme des cubes des chiffres du nombre
entier \texttt{n}.
\item Trouver tous les nombres entiers inférieurs à 1000 égaux à la somme des cubes de leurs chiffres.
\item En modifiant les instructions de la fonction \texttt{somcube}, écrire une fonction \texttt{somcube2} qui convertit
l’entier \texttt{n} en une chaîne de caractères permettant ainsi la récupération de ses chiffres sous forme de
caractères. Cette nouvelle fonction renvoie toujours la somme des cubes des chiffres de l’entier \texttt{n}.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 2 -- Intégration}
\subsection*{Exercice 2 -- Intégration}
On cherche à calculer une valeur approchée de l’intégrale d’une fonction donnée par des points dont les coordonnées sont situées dans un fichier.
\begin{enumerate}
\item Le fichier \texttt{ex\_01.txt}, situé dans le sous-répertoire \texttt{data} du répertoire de travail, contient une quinzaine de lignes selon le modèle suivant :

\begin{center}

\texttt{0.0;1.00988282142}

\texttt{0.1;1.07221264497}

\end{center}

Chaque ligne contient deux valeurs flottantes séparées par un point-virgule, représentant respective-
ment l’abscisse et l’ordonnée d’un point. Les points sont ordonnés par abscisses croissantes.
Ouvrir le fichier en lecture, le lire et construire la liste \texttt{LX} des abscisses et la liste \texttt{LY} des ordonnées contenues dans ce fichier.
\item Représenter les points sur une figure.
\item Les points précédents sont situés sur la courbe représentative d’une fonction \texttt{f}. On souhaite déterminer une valeur approchée de l’intégrale \texttt{I} de cette fonction sur le segment où elle est définie. Écrire une fonction \texttt{trapeze}, d’arguments deux listes \texttt{y} et \texttt{x} de même longueur \texttt{n}, renvoyant :

$$
\sum\limits_{i=1}^{n-1} \left(x_i - x_{i-1} \right) \dfrac{y_i +y_{i-1}}{2}.
$$

\texttt{trapeze(LY,LX)} renvoie donc une valeur approchée de l’intégrale $I$ par la méthode des trapèzes.
\item En utilisant la méthode d’intégration numérique \texttt{trapz} de la sous-bibliothèque \texttt{scipy.integrate} du langage Python ou la méthode \texttt{inttrap} du logiciel Scilab, retrouver la valeur approchée de l'intégrale $I$.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 3 -- Graphe}
\subsection*{Exercice 3}
On considère le graphe \texttt{G} suivant, où le nombre situé sur l'arête joignant deux sommets est leur distance, supposée entière :
\begin{center}
\includegraphics[width=.75\linewidth]{images/exo_3}
\end{center}

\begin{enumerate}
\item Construire la matrice $\left( M_{ij}\right)_{0\leq i,j\leq 4}$, matrice de distances du graphe \texttt{G}, définie par :

<< pour tous les indices $i$, $j$, $M_{ij}$ représente la distance entre les sommets $i$ et $j$,
ou encore la longueur de l'arête reliant les sommets $i$ et $j$ >>.

On convient que, lorsque les sommets ne sont pas reliés, cette distance vaut -1. La distance du
sommet $i$ à lui-même est, bien sûr, égale à 0.
\item Écrire une suite d'instructions permettant de dresser à partir de la matrice \texttt{M} la liste des voisins du sommet 4.
\item Écrire une fonction \texttt{voisins}, d'argument un sommet $i$, renvoyant la liste des voisins du sommet $i$.
\item Écrire une fonction \texttt{degre}, d'argument un sommet $i$, renvoyant le nombre des voisins du sommet $i$, c'est-à-dire le nombre d’arêtes issues de $i$.
\item Écrire une fonction \texttt{longueur}, d’argument une liste \texttt{L} de sommets de \texttt{G}, renvoyant la longueur du trajet d'écrit par cette liste \texttt{L}, c’est-à-dire la somme des longueurs des arêtes empruntées. Si le trajet n'est pas possible, la fonction renverra $-1$.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 4 -- Gestion de liste}
\subsection*{Exercice 4 -- Gestion de liste}
Soit un entier naturel $n$ non nul et une liste \texttt{t} de longueur $n$ dont les termes valent 0 ou 1. Le but de cet exercice est de trouver le nombre maximal de 0 contigus dans \texttt{t} (c’est-à-dire figurant dans des cases consécutives). Par exemple, le nombre maximal de zéros contigus de la liste \texttt{t1} suivante vaut 4 :
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline 
\texttt{i} & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\hline
\texttt{t1[i]} & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 1 \\
\hline
\hline
\texttt{i} & 8 & 9 & 10 & 11 & 12 & 13 & 14 \\
\cline{0-7} 
\texttt{t1[i]} & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\
\cline{0-7}  
\end{tabular}
\end{center}

\begin{enumerate}
\item Écrire une fonction \texttt{nombreZeros(t,i)}, prenant en paramètres une liste \texttt{t}, de longueur n, et un indice i compris entre 0 et $n-1$, et renvoyant :
$$
\left\{
\begin{array}{l}
0, \text{ si } t[i]=1 \\
\text{le  nombre de zéros consécutifs dans t} \\ \text{à partir de t[i] inclus, si t[i] = 0}.
\end{array}
\right.
$$
Par exemple, les appels \texttt{nombreZeros(t1,4)}, \texttt{nombreZeros(t1,1)} et \texttt{nombreZeros(t1,8)} renvoient respectivement les valeurs 3, 0 et 1.
\item Comment obtenir le nombre maximal de zéros contigus d’une liste \texttt{t} connaissant la liste des \texttt{nombreZeros(t,i)} pour $0\leq i \leq n-1$ ?
En déduire une fonction \texttt{nombreZerosMax(t)}, de paramètre \texttt{t}, renvoyant le nombre maximal de 0 contigus d’une liste \texttt{t} non vide. On utilisera la fonction \texttt{nombreZeros}.
\item Quelle est la complexité de la fonction \texttt{nombreZerosMax(t)} construite à la question précédente ?
\item Trouver un moyen simple, toujours en utilisant la fonction \texttt{nombreZeros}, d’obtenir un algorithme plus performant.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 5 -- Probabilités}
\subsection*{Exercice 5 -- Probabilités}
Soient $n$ un entier naturel strictement positif et $p$ un réel compris entre 0 et 1.
On considère $X$ et $Y$ deux variables aléatoires à valeurs dans $\mathbb{N}$ sur un espace probabilisé donné. $X$ suit une
loi de Poisson de paramètre $\lambda = np$ et $Y$ suit une loi binomiale de paramètres $(n, p)$.

\begin{enumerate}
\item Définir une fonction \texttt{Px}, d’arguments $k$, $n$ et $p$, renvoyant la valeur de $P(X = k)$. $k!$ (factorielle k) s’obtient par \texttt{factorial(k)} en Python (bibliothèque math) et \texttt{prod(1 : k)} en Scilab.
Déterminer, pour $n = 30$ et $p = 0,1$, la liste des valeurs de $P(X = k)$ pour $k \in \mathbb{N}$, $0 \leq k \leq 30 $.
\item Définir une fonction \texttt{Py}, d’arguments $k$, $n$ et $p$, renvoyant la valeur de $P(Y = k)$.
On pourra utiliser \texttt{comb} de la sous-bibliothèque \texttt{scipy.misc} en Python et \texttt{binomial} en Scilab.

Déterminer, pour $n = 30$ et $p = 0,1$, la liste des valeurs de $P(Y = k)$ pour $k \in \mathbb{N}$, $0 \leq k \leq 30$.
\item Soit $k \in \mathbb{N}$. On rappelle que, sous certaines conditions sur $n$ et $p$, la probabilité $P(Y = k)$ peut être
approchée par $P(X = k)$. Déterminer une fonction \texttt{Ecart} d’arguments $n$ et $p$, renvoyant le plus grand
des nombres $|P(Y = k) - P(X = k)|$, pour $0 \leq k \leq n$.
\item Soit $e$ un réel strictement positif. Déterminer une fonction \texttt{N}, d’arguments $e$ et $p$, renvoyant le plus
petit entier $n$ tel que \texttt{Ecart(n, p)} soit inférieur ou égal à $e$.
\item Faire l’application numérique dans les quatre cas suivants :
\begin{itemize}
\item $p = 0,075$ avec $e = 0,008$ et $e = 0,005$;
\item $p = 0,1$ avec $e = 0,008$ et $e = 0,005$. Interpréter le dernier résultat.
\end{itemize}
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 6 -- Tracer de fonction -- $f(x)=0$}
\subsection*{Exercice 6 -- $f(x)=0$}
On considère la fonction $g$ définie sur $[0 , 2[$ par :
$$ g(x) =
\left\{
\begin{array}{ll}
x &\text{ pour } 0\leq x < 1 \\
1 &\text{ pour } 1\leq x < 2 
\end{array}
\right.
$$
\begin{enumerate}
\item Définir la fonction $g$. Tracer sa courbe représentative sur $[0 , 2[$, c’est-à-dire la ligne brisée reliant les points $(x, g(x))$ pour $x$ variant de 0 à 1,99 avec un pas de 0,01.
\item Définir une fonction $f$ donnée de manière récursive sur $[0 , +\infty[$ par :
$$ f(x) =
\left\{
\begin{array}{ll}
g(x) &\text{ pour } 0\leq x < 2 \\
\sqrt{x} f(x-2) &\text{ pour } x \geq 2
\end{array}
\right.
$$
\item Tracer la courbe représentative de $f$ sur $[0,6]$.
\item Écrire les instructions permettant de calculer, à $10^{-2}$ près, la plus petite valeur $\alpha > 0$ telle que $f(\alpha) > 4$.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 7 -- Algorithmique }
\subsection*{Exercice 7 -- Algorithmique }

On considère le code Python de la fonction \texttt{d} suivante :

\begin{py}
\begin{python}
def d(n):
    L =[1]
    for nombre in range(2,n+1):
        if n%nombre == 0:
            L.append(nombre)
    return L
\end{python}
\end{py}

\begin{enumerate}
\item Quel est le résultat de l’appel \texttt{d(4)} ? Puis de l’appel \texttt{d(10)} ?
Que fait la fonction \texttt{d} ?
\item Un diviseur non-trivial d’un entier \texttt{n} est un diviseur de \texttt{n} différent de 1 et de \texttt{n}. Écrire une fonction \texttt{DNT}, d’argument \texttt{n}, renvoyant la liste des diviseurs non-triviaux de l’entier \texttt{n}.
\item Écrire une fonction \texttt{sommeCarresDNT}, d’argument \texttt{n}, renvoyant la somme des carrés des diviseurs non-triviaux de l’entier \texttt{n}.
\item Écrire la suite des instructions permettant d’afficher tous les nombres entiers inférieurs à 1000 et égaux à la somme des carrés de leurs diviseurs non-triviaux. Que peut-on conjecturer ?
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 8 -- Chiffrer -- déchiffrer}
\subsection*{Exercice 8 -- Chiffrer -- déchiffrer}
Soit n un entier vérifiant $n \leq 26$. On souhaite écrire un programme qui code un mot en décalant chaque lettre de l'alphabet de $n$ lettres.
Par exemple pour $n = 3$, le décalage sera le suivant :
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|}
\hline
Avant décalage & a & b & c & ... & x & y & z \\
\hline
Après décalage & d & e & f & ... & a & b & c \\
\hline
\end{tabular}
\end{center}
Le mot \texttt{oralensam} devient ainsi \texttt{rudohqvdp}.
\begin{enumerate}
\item Définir une chaîne de caractères contenant toutes les lettres dans l’ordre alphabétique (caractères en
minuscule).
\item Écrire une fonction \texttt{decalage}, d’argument un entier \texttt{n}, renvoyant une chaîne de caractères contenant
toutes les lettres dans l’ordre alphabétique, décalées de \texttt{n}, comme indiqué ci-dessus.
\item Écrire une fonction \texttt{indices}, d’arguments un caractère \texttt{x} et une chaîne de caractères \texttt{phrase}, renvoyant
une liste contenant les indices de \texttt{x} dans \texttt{phrase} si \texttt{x} est une lettre de phrase et une liste vide sinon.
\item Écrire une fonction codage d’arguments un entier \texttt{n} et une chaîne de caractères \texttt{phrase}, renvoyant
\texttt{phrase} codé avec un décalage de \texttt{n} lettres.
\item Comment peut-on décoder un mot codé ?
\end{enumerate}



\addcontentsline{toc}{subsection}{Exercice 9 --  Fractale de Mandelbrot}
\subsection*{Exercice 9 -- Fractale de Mandelbrot}

On pose $M = 20$ et $m = 10$. À un nombre $c$ quelconque, on associe la suite $(u_n)_{n\geq 0}$ définie par $u_0 = 0$ et $u_{n+1} = u_n^2 + c$ pour $n \geq 0$.

S’il existe, on note $k$ le plus petit entier tel que l’on ait $0 \leq k \leq m$ et $|u_k| > M$.
On définit alors la fonction $f$ par 
$$
f : c \mapsto 
\left\{
\begin{array}{l}
k \text{ s'il existe} \\
m+1  \text{ sinon.}
\end{array}
\right.
$$

\begin{enumerate}
\item  Donner le code définissant la fonction $f$.
\item  Tracer l’allure de la courbe représentative de la fonction $f$ sur $[-2; 2]$, en créant une liste \texttt{LX} de 401 valeurs équiréparties entre -2 et 2 inclus et en utilisant les fonctions \texttt{plot} et show de la sous-bibliothèque \texttt{matplotlib.pyplot}.
\item  Construire le tableau des valeurs $f(x+i y)$ où $x$ prend 101 valeurs comprises entre -2 et 0,5 et $y$ prend
101 valeurs entre -1,1 et 1,1. \textit{On rappelle que le nombre complexe $i$ est représenté par $1j$. Par exemple,
le complexe $1 + 2 i$ est représenté par $1+2j$.}
\item  Tracer l’image que code ce tableau. On pourra utiliser les fonctions \texttt{imshow} et \texttt{show} de la sous-
bibliothèque \texttt{matplotlib.pyplot}. Quels paramètres peut-on modifier pour obtenir une meilleure résolution ?
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 10 -- Calcul matriciel}
\subsection*{Exercice 10 -- Calcul matriciel}
\textit{Dans cet exercice, avec Python on pourra utiliser la fonction \texttt{array} de la bibliothèque \texttt{numpy}, ainsi que la
fonction \texttt{eig} de la sous-bibliothèque \texttt{numpy.linalg}. Avec Scilab, on utilisera \texttt{spec}.}

\begin{enumerate}
\item Créer deux matrices $R=\begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6  \end{pmatrix}$ et 
$S =\begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6\\ 7 & 8 & 9  \end{pmatrix}$ et les faire afficher.
\item Créer une fonction \texttt{test}, d’argument $M$, renvoyant la valeur \texttt{n} si $M$ est une matrice carrée d’ordre \texttt{n} (entier naturel non nul) et zéro dans tous les autres cas.
Vérifier la fonction test sur $R$ et sur $S$.
\item Le fichier \texttt{ex\_006.txt}, situé dans le sous-répertoire \texttt{data} du répertoire de travail, contient un tableau de valeurs flottantes. Lire ce tableau dans le fichier et vérifier qu’il correspond bien à une matrice carrée d’ordre 5 que l’on désignera par \texttt{M1}. 
\item Déterminer les valeurs propres de la matrice \texttt{M1}.
\item Créer une fonction \texttt{dansIntervalle}, d’arguments une liste $L$ et deux réels $a$ et $b$, renvoyant la valeur \texttt{True} si tous les éléments de la liste $L$ sont dans l’intervalle $[a, b]$ et \texttt{False} sinon. Vérifier que toutes les valeurs propres de la matrice \texttt{M1} sont dans l’intervalle $[0, 1]$.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 11 -- Tri de liste}
\subsection*{Exercice 11 -- Tri de liste}
Soit $N$ un entier naturel non nul. On cherche à trier une liste L d’entiers naturels strictement inférieurs à $N$.
\begin{enumerate}
\item Écrire une fonction comptage, d’arguments $L$ et $N$, renvoyant une liste $P$ dont le $k$-ième élément désigne le nombre d’occurences de l’entier $k$ dans la liste $L$.
\item Utiliser la liste $P$ pour en déduire une fonction \texttt{tri}, d’arguments $L$ et $N$, renvoyant la liste $L$ triée dans l’ordre croissant.
\item Tester la fonction \texttt{tri} sur une liste de 20 entiers inférieurs ou égaux à 5, tirés aléatoirement.
\item Quelle est la complexité temporelle de cet algorithme ? La comparer à la complexité d’un tri par insertion ou d’un tri fusion.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 12 -- Courbes paramétrées}
\subsection*{Exercice 12 -- Courbes paramétrées}
\begin{enumerate}
\item Deux paramètres $b$ et $w$ valant respectivement 0,5 et 6,0, définir trois fonctions d’une variable $t$ renvoyant des couples :
$$
\left\{
\begin{array}{ll}
p : t \mapsto &\left(\cos(t) +b \cos(wt),      \sin(t) + b \sin (wt) \right) \\
v : t \mapsto &\left(-\sin(t)  -bw \sin(wt),\right. \\     
& \quad \left. \cos(t) + b w\cos (wt) \right) \\
a : t \mapsto &\left(-\cos(t)-bw^2 \cos(wt),\right. \\ 
& \quad \left.-\sin(t) - b w^2 \sin (wt) \right) \\
\end{array}
\right.
$$
Vérifier ces fonctions sur un exemple.

$p(t)=(x(t),y(t))$ désigne la position dans le plan d'une masse ponctuelle mobile au cours du temps, $v(t)=(x'(t),y'(t))$, sa vitesse, et $a(t)=(x''(t),y''(t))$, son accélération.
\item Construire la liste \texttt{L} des points $p(t)$, pour $t$ variant de $-\pi$ à $\pi$ avec un pas de discrétisation $\delta t$ vérifiant $\delta t = 0,01 \; \pi$.
\item Faire tracer dans le plan muni d’un repère orthonormal la ligne polygonale reliant les points $p(t)$ de la liste \texttt{L}.
\item Définir puis tester la fonction $c$ d’une variable $t$ qui renvoie le couple des coordonnées du centre de courbure donnée par :
$$
c(t)=\left(x(t)-dy'(t),y(t)+dx'(t)\right) $$ 
où
$$
d= \dfrac{x'(t)^2+y'(t)^2}{x'(t)y''(t)-y'(t)x''(t)}.
$$
\item Rajouter sur le graphique précédent la ligne décrite par les centres de courbure, avec la même
discrétisation en temps.
\item Calculer la longueur de la ligne polygonale reliant les points $p(t)$, pour différents pas de discrétisation $\delta t$. Observer l'évolution de cette longueur lorsque $\delta t$ diminue.
\end{enumerate}
\end{multicols}


\newpage 
\begin{multicols}{2}
\section{Exercices de la Banque PT -- 2016}
\addcontentsline{toc}{subsection}{Exercice 1}
\subsection*{Exercice 1}

Un pays ne produit que des billets de 57 62 et 72 unités.
\begin{enumerate}
\item Peut-on atteindre les sommes de 400 et 600 avec ces billets ?
\item Écrire la fonction comptage qui permet de dire si une somme est décomposable en billets et de combien de manière différentes. 
\item Un enfant achète un croissant qui coûte 4 unités il utilise deux valeurs de billets le boulanger lui rend que des billets combien l'enfant a-t-il donné au boulanger (le détail) ?
\end{enumerate}

\end{multicols}

\addcontentsline{toc}{subsection}{Exercice 2}
\subsection*{Exercice 2}

On donnait un programme (utilisant des nombres complexes, \texttt{numpy} et \texttt{numpy.rand}).
\begin{enumerate}
\item Que fait ce programme ? (Il donnait une liste de complexes de parties réelles aléatoires, centrées autour de 50, et de partie imaginaires aléatoires centrées autour de 20). Représenter sa sortie (un nuage de point).
\item  Écrire une fonction bornes d'argument une liste de complexes \texttt{L} donnant les abscisses et ordonnées maximales des éléments de \texttt{L} dans le plan complexe
\item  Tracer le rectangle basé sur les points obtenus par la fonction précédente à partir des points donnés par le programme donné.
\item  On souhaite minimiser l'aire du rectangle encadrant le nuage de points. Pour cela on va écrire un programme d'argument une liste de complexes \texttt{L} et un entier \texttt{n}.
On va procéder à des rotations d'angle $-a$ du repère, pour $a$ entre 0 inclus et $2\pi$ exclus, avec un pas de $\dfrac{2\pi}{n}$. À chaque étape on trace le rectangle qui colle au mieux, puis on garde celui d'aire minimale. Ensuite, tracer ce rectangle.
\item La même question mais en traçant un rectangle (je ne l'ai pas faite).
\end{enumerate}
\newpage 
\begin{multicols}{2}
\section{Exercices de la banque PT retranscrits par vos prédécesseurs -- 2015}
\begin{rem}
Les exercices vous sont retranscrits tels que vos prédécesseurs nous les ont retranscrits. 
\end{rem}
\addcontentsline{toc}{subsection}{Exercice 1}
\subsection*{Exercice 1}
Nombre de manières de payer $n$ euros avec des pièces de \texttt{L} (liste de valeurs).  

\addcontentsline{toc}{subsection}{Exercice 2}
\subsection*{Exercice 2 -- Nombres riches ?}
Écrire une fonction qui donne les diviseurs d'un entier $n$, puis qui donne les $k$ premiers nombres riches et leur nombre de diviseurs sous forme d'une liste contenant des groupes comme \texttt{[2,2]} ? Question sur les facteurs premiers.

\addcontentsline{toc}{subsection}{Exercice 3}
\subsection*{Exercice 3}
<< C'était une histoire de n listes de taille n dans une liste et je devais construire par récursivité un programme qui me donnait le nombre maximal de listes possibles de taille \texttt{p} dans ma liste de liste.>>


\addcontentsline{toc}{subsection}{Exercice 4}
\subsection*{Exercice 4}
On considère la somme $S=\sum\limits_{n=1}^{+\infty} \dfrac{(-1)^n}{n}$.
\begin{enumerate}
\item Montrer que le reste de la série vérifie $\left| R_n \right| \leq \dfrac{1}{1+n}$.
\item Écrire une fonction qui calcule la somme $S$ à $10^{-6}$ près.
\item Tracer $S_n$ en fonction de $n$ (on rendra une centaine de points).
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 5}
\subsection*{Exercice 5}
Dans un ensemble $E=\left\{ a_1, a_2, ..., a_n\right\}$, $A_i$ représente une partie de  $E$ et est représenté par le code $c_i$ tel que $c_i[k]=0$ si $a_k \in A_i$ et 1 sinon.
\begin{enumerate}
\item Écrire la fonction \texttt{reunion} d'arguments $c_1$ et $c_2$ codes respectifs de $A_1$ et $A_2$ et retournant le code de $A_1 \bigcup A_2$. 
\item Écrire la fonction \texttt{estrec} d'argument \texttt{L} une liste de codes associés à des sous ensembles de $E$ et retournant le booléen \texttt{True} su la réunion de ces sous ensembles vaut \texttt{E} ou \texttt{False} sinon.
\item Soit $R$ un ensemble de parties de $E$ représenté par une liste $L$ de codes. On dit que $R$ est un recouvrement minimal de $E$ si la réunion des parties de $R$ est $E$ et que pour tout $R'$ inclus dans $R$ et différent de $R$, $R'$ n'est pas un recouvrement de $E$ (la réunion des parties de $R'$ est différente de $E$. 
\item Écrire la fonction \texttt{estRecMin} d'argument \texttt{L} une liste de codes représentant $R$, qui retourne le booléen \texttt{True} si $R$ est un recouvrement minimal de $E$ \texttt{False} sinon. 
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 6}
\subsection*{Exercice 6}
Soit $s$ définie par $s_0=1$,  $s_1=1$, et pour tout $n$, $s_{2n}s_n+s_{n+1}$. 
\begin{enumerate}
\item Calculer les 8 premiers termes de la suite.
\item Écrire la fonction \texttt{LS} d'argument $N$ et renvoyant les $N+1$ premiers éléments de la suite $s$. Calculer $L_{128}=LS(128)$. 
\item On sépare la liste $L_{128}$ de 1 à 2, de 2 à 4, de 4 à 8... Quelle symétrie y a-t-il pour chaque paquet ? Extraire ces paquets.
\item Écrire la fonction \texttt{LP} d'argument $N$ et renvoyant les $N+1$ premières lignes du triangle de Pascal. On rappelle que $\begin{pmatrix}n+1 \\ p \end{pmatrix}=\begin{pmatrix}n \\ p-1 \end{pmatrix}+\begin{pmatrix}n \\ p \end{pmatrix}$ et $\begin{pmatrix}n \\ 0 \end{pmatrix} = \begin{pmatrix}n \\ n \end{pmatrix}=1$.
On a par exemple, $TP(4)=[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]$.
\item ...
\end{enumerate} 


\addcontentsline{toc}{subsection}{Exercice 7}
\subsection*{Exercice 7}
<< Il m'était demandé de créer une liste regroupant les abscisses et ordonnées pour $k$ allant de 1 à 12, des points complexes de module variant entre 0 et 1, d'angle $\dfrac{k\pi}{6}$ et ensuite de tracer ces points. Je suis arrivé à le faire mais j'ai été obligé de me faire confirmer par l'examinateur ce qu'il fallait faire car l'énoncé me bloquait.
>>

\addcontentsline{toc}{subsection}{Exercice 8}
\subsection*{Exercice 8}
\begin{rem}
Exercice tombé au moins deux fois.
\end{rem}

Un segment $[a,b]$ est noté comme une liste \texttt{[a,b]}. Soient $I_1$ et $I_2$ deux segments. Ils sont disjoints si leur intersection est vide. 

\begin{enumerate}
\item Écrire une fonction \texttt{disjoint} d'arguments $i_1$ et $i_2$ (deux listes représentant des segments) et retournant \texttt{True} s'ils sont disjoints, \texttt{False} sinon. 
\item La fusion de deux segments correspond à un segment qui a pour min le plus petit des deux min et pour max le plus grand des deux max. Écrire une fonction \texttt{fusion} d'arguments $i_1$ et $i_2$ et qui retourne la liste correspondant à la fusion de ces deux segments. 
\item On dit qu'une liste de segments est bien fondée si les segments de cette liste sont disjoints et rangés dans l'ordre croissant. (On dit que $I_1=[a,b]$ est inférieur à $I_2=[c,d]$ si $b<c$.)
\begin{enumerate}
\item Les listes suivantes sont-elles bien fondées : $L=[[0,3],[6,7],[2,5]]$ et $L=[[0,1],[2,3],[4,5]]$ ?
\item Écrire une fonction récursive \texttt{verif} qui dit si une liste est bien fondée ou non.
\end{enumerate}
\end{enumerate}



\addcontentsline{toc}{subsection}{Exercice 9}
\subsection*{Exercice 9}
Voici un théorème d'arithmétique : tous les nombres entiers sont au plus décomposables en une somme de 9 cubes. 
\begin{enumerate}
\item Définir une fonction \texttt{estcube(n)} qui retourne \texttt{True} si $n$ est un cube, \texttt{False} sinon. Afficher tous les cubes inférieurs ou égaux à 250.
\item Définir une fonction \texttt{S2cube(n)} qui retourne \texttt{True} si $n$ est la somme de deux cubes, \texttt{False} sinon. Afficher tous les entiers inférieurs ou égaux à 250 qui sont somme de deux cubes.
\item Définir une fonction \texttt{S4cube(n)} qui retourne \texttt{True} si $n$ est la somme de quatre cubes, \texttt{False} sinon. Afficher tous les entiers inférieurs ou égaux à 250 qui ne sont pas somme de deux cubes.
\item Définir une fonction \texttt{S8cube(n)} qui retourne \texttt{True} si $n$ est la somme de huit cubes, \texttt{False} sinon. Afficher tous les entiers inférieurs ou égaux à 250 qui ne sont pas somme de deux cubes.
\item Expliquer pourquoi les nombres qui ne sont pas somme de 8 cubes sont sommes de 9 cubes. 
\item Conclure.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 10}
\subsection*{Exercice 10}
On dit qu'un mot est un palindrome s'il est le même lorsqu'on le dit à l'envers. Par exemple le mot <<radar>> est un palindrome. Le mot <<nul>> donne <<lun>> à l'nvers et n'est pas un palindrome. 
\begin{enumerate}
\item Écrire une fonction \texttt{inverse} d'argument une chaine de caractères \texttt{mot} et renvoyant la chaîne écrite à l'envers. 
\item Écrire une fonction \texttt{palindrome} d'argument une chaine de caractères \texttt{mot} et renvoyant le booléen \texttt{True} si le mot est un palindrome, \texttt{False} sinon.
\item Par extension on dit qu'un nombre est un palindrome s'il est égal au nombre obtenu en écrivant les chiffres en ordre inverse. Écrire une fonction \texttt{pat\_nombre} d'argument $N$ et renvoyant la liste des nombres palindromes inférieurs ou égaux à $N$.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 11}
\subsection*{Exercice 11}
\begin{enumerate}
\item Créer une fonction \texttt{partage} prenant en argument une liste $L$ et un entier $a$ retournant 2 listes $Linf$ et $Lsup$ respectivement les listes des éléments de $L$ inférieurs à $a$ et et ceux supérieurs à $a$.
\item Créer une fonction \texttt{trirapide} utilisant la précédente. 
\item Modifier les deux fonctions précédentes afin de connaître le nombre de comparaisons effectuées. 
\item Tester votre fonction avec une liste de 4000 valeurs entre -999 et 999. Utiliser \texttt{randint(p,q)} pour créer cette liste.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 12}
\subsection*{Exercice 12}
On qualifie un vecteur de creux lorsque le nombre de zéros qu'il contient est au moins supérieur à la moitié de son nombre de coordonnées. Par exemple $v=\left(1,2,0,4,7,0,0,0,0\right)$ est creux (5 zéros et 9 coordonnées). Son codage est creux est $v=\left[9,[1,2,4,7],[0,1,3,4]\right]$ (nombre de coordonnées, liste des éléments non nuls, liste des indices de ces éléments).
\begin{enumerate}
\item Définir la fonction \texttt{creux} d'argument une liste $v$ représentant un vecteur et retournant un booléen indiquant si le vecteur est creux ou non.
\item Définir la fonction \texttt{coder} d'argument une liste $v$ représentant un vecteur et retournant le codage creux du vecteur.
\item Définir une fonction \texttt{decoder}.
\item Définir une fonction \texttt{simul} d'argument le codage \texttt{C} d'un vecteur $v$ et un scalaire $a$ retournant le cordage creux du vecteur $av$.
\item Définir une fonction \texttt{coefficient(j,C)} qui renvoie la coordonnée $j$ du vecteur creux associé au code $C$.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 13}
\subsection*{Exercice 13}
\begin{enumerate}
\item Créer une fonction $\texttt{C}$ d'argument un entier $d$ et qui renvoie un entier formé par les chiffres de $d$ dans l'ordre croissant. Par exemple, $C(1542)=1245$.
\item Créer une fonction $\texttt{D}$ qui fait la même chose que $\texttt{C}$ mais dans l'ordre décroissant. 
\item On définit une suite $u_n$ par $u_0=a \in \mathbb{N}$ et $u_{n+1}=D(u_n)-C(u_n)$. Écrire une fonction qui calcule les termes de cette suite.
\item ...
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 14}
\subsection*{Exercice 14}
\begin{enumerate}
\item Créer une fonction \texttt{nbits} d'argument un entier \texttt{n} qui renvoie le plus petit entier $i$ tel que $n \leq 2^i$. 
\item Créer une fonction \texttt{sansrep} d'argument une liste $L$ d'entiers et qui retourne la liste des éléments de $L$ en unique exemplaire. Exemple : \texttt{sansrep([5,0,0,0,3,3,5])=[5,0,5]}. On utilisera la fonction \texttt{in}.
\item Créer une fonction \texttt{position} d'argument une liste $L$ d'entiers et $e$ un entier, retournant la première position de $e$ dans $L$ (en supposant que $e$ est dans $L$).
\item Retourner l'écriture binaire de la position de $e$ dans la liste. On utilisera \texttt{nb.format(i)}.

\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 15}
\subsection*{Exercice 15}
Soit $n$ un entier fixé. On étudie le codage de listes d'entiers de longueur.  On dispose d'une liste représentant le codage $\texttt{C}$ de longueur $n$ contenant des 0 et des 1.  Une liste $\texttt{E}$ d'entiers de longueurs $n$ est la liste codée d'une liste $A$ telle que $A$ contient les éléments de la liste $E$ dont les indices sont ceux pour lesquels $\texttt{C}$ contient 1. 
Ainsi si \texttt{E=[2,4,6,7]} et \texttt{C=[0,1,1,0]} alors \texttt{A=[4,6]}.
\begin{enumerate}
\item Créer une fonction \texttt{decoder} d'arguments deux listes \texttt{E} et \texttt{C} qui renvoie la liste \texttt{A}.
\item Créer une fonction \texttt{coder} d'arguments \texttt{E} et \texttt{A} retournant \texttt{C}.
\item Créer une fonction \texttt{incrementer} d'argument \texttt{C} et retournant une liste \texttt{C'} contenant l'écriture binaire du nombre $N+1$ avec $N$ nombres dont l'écriture binaire est $C$ (si \texttt{C=[0,1,1,0]}, \texttt{N=6} donc \texttt{N+1=7} et \texttt{C'=[0,1,1,1]}.
\end{enumerate}


%\addcontentsline{toc}{subsection}{Exercice 15}
%\subsection*{Exercice 15}
%\textit{NDLR : Je ne sais pas si c'était un exo de maths ou de Python.}
%<< J'ai eu un exercice de proba: 
%un ordinateur et deux réseau dont le choix est indépendant 
%on choisi a 70\% le $A$ et proba d'avoir une erreur avec $A$ $e=0,1$ avec $B$ $e=0.05$.
%\begin{enumerate}
%\item Calculer la proba d'avoir une erreur.
%\item On a une erreur. Calculer la proba d'avoir choisi A. \\
%
%On considère une liste par exemple AAAABBA..., L1 liste d'avoir 4 fois le réseau A, L2, 2fois le réseau B.
%
%\item Montrer que la série des L1 (pour $k\geq 1$) est égale à 1.
%\item L1 admet-elle une espérance ? Si oui la calculer.
%\item Calculer la proba de (L1,L2).
%\item ???
%\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 15}
\subsection*{Exercice 15}
Soit $T_n$, le reste de la division euclidienne par 2 de la somme des chiffres représentant $n$ en base 2.
(exemple : 13 s'écrit 1101 donc on regarde le reste de la division de 1+1+0+1 par 2, donc $T(13)=1$). 

\begin{enumerate} 
\item \begin{enumerate}
\item Trouver une relation entre $T_{2n}$ et $T_n$.
\item De-même, trouver une relation entre $T_{2n+1}$ et $T_n$.
\item Créer une fonction récursive pour calculer $T_n$
\end{enumerate}
\item Afficher les lignes suivantes: 
\begin{itemize}
\item $T_0$, $T_1$
\item $T_0$  $T_1$ ; $T_2$ $T_3$;
\item $T_0$ $T_1$ $T_2$    ; $T_3$ $T_4$ $T_5$.
\end{itemize} 
Remarquer une particularité et en déduire une manière simple de calculer les $2^p$ premiers termes de la suite $T_n$.
\item Montrer que : $\sum\limits_{n=0}^{+\infty} = \dfrac{T_n}{2^{n+1}}$ converge.
\item Calculer numériquement une valeur approchée de la somme à $10^(-6)$ près.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 16}
\subsection*{Exercice 16}
\begin{enumerate}
\item Créer une fonction qui compte le nombre d'éléments pairs d'une liste. 
\item Créer une fonction qui crée la liste des éléments pairs d'une liste. 
\item Créer une fonction qui renvoie le booléen \texttt{True} si la liste ne contient que des chiffres pairs, \texttt{False} sinon. 
\item Créer une fonction qui donne la position du maximum dans la liste. 
\item Créer une fonction qui donne la médiane de la liste. 
\item Créer une liste de 20 nombres aléatoires entre 0 et 100. Tester les fonctions. 
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 17}
\subsection*{Exercice 17}
\begin{enumerate}
\item Écrire une fonction \texttt{binaire} d'argument $n\in\mathbb{n}$, renvoyant sous forme de liste l'écriture binaire de $n$/
\item Écrire une fonction \texttt{nombreDeUn} d'argument $n\in \mathbb{N}$, renvoyant le nombre de 1 dans \texttt{binaire(n)}. 
\item La définition du <<n-palindrome>> était donnée dans l'énoncé.
\begin{enumerate}
\item Écrire une fonction \texttt{Palindrome} d'argument $n\in \mathbb{N}$ permettant de déterminer si n est un 2-palindrome.
\item Donner les 2-palindromes entre 0 et 100.
\end{enumerate}
\end{enumerate}



\addcontentsline{toc}{subsection}{Exercice 18}
\subsection*{Exercice 18}
Les nombres sont écrits sous forme de chaîne de caractères.
\begin{enumerate}
\item Déterminer tous les entiers inférieurs à 10000 égaux à la puissance 4 de la somme de leurs chiffres.
\item Écrire une fonction \texttt{DixVersDeux} qui prend comme argument un nombre en base 10 (chaine de caractères) et envoie le nombre en base 2. 
\item Écrire une fonction \texttt{DeuxVersDix} réciproque de la fonction précédente. 
\item Déterminer tous les entiers inférieurs à 10 000 égaux à la puissance 4 de la somme de leurs chiffres en base 2.
\item Écrire une fonction  \texttt{DixVersBase(chaine,base)}. 
\item Refaire la question 4 avec les bases 3 à 9.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 18 -- Bis}
\subsection*{Exercice 18 -- Bis}
On écrit 18 par une chaine de caractères : \texttt{'18'} en base 10 et \texttt{'10010'} en base 2. 
\begin{enumerate}
\item Écrire une fonction \texttt{somchi} d'argument une chaine de caractères et retournant la somme de ses chiffres  (exemple \texttt{somchi('18')} retourne 9).
\item Donner la liste des nombres entiers égaux à la somme de leurs chiffres à la puissance 4. 
\item Écrire la fonction \texttt{DixVersDeux}, d'argument une chaine de caractère d'un nombre en en base 10 et retournant le nombre en base 2. 
\item Écrire la fonction réciproque \texttt{DeuxVersDix}.
\item Donner la liste des nombres entiers en base 2 égaux à la puissance 4 de la somme de leur chiffre.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 19}
\subsection*{Exercice 19}

\begin{itemize}
\item Deux algorithmes à expliquer (l’un transforme un nombre en une liste de ses chiffres et
l’autre est la fonction inverse) exemple : 2015 : alg1 $\rightarrow$  [2, 0, 1, 5] --  alg2  $\rightarrow$ 2015.
\item Écrire la fonction récursive \texttt{perm} d’argument une liste \texttt{L} qui renvoi toute les permutations
de cette liste.
\item 2 autres questions non traitées.
\end{itemize}

\addcontentsline{toc}{subsection}{Exercice 20}
\subsection*{Exercice 20}
Soit $x$ un réel, $v_0=x$, $a_n = \lfloor v_n \rfloor$, $v_{n+1} = \left\{ \begin{array}{l} 0 \\ \dfrac{1}{a_n -1} \end{array} \right.$ si $a_n>1$.
\begin{enumerate}
\item Calculer les 10 premiers termes de la suite pour $x=\sqrt{3}$. 
\item Définir $A(x)$, la fonction qui définit la suite et renvoie les 10 premiers termes de la suite. La tester avec $\sqrt{2}$, $\dfrac{1+\sqrt{5}}{2}$, $\sqrt{5}$. 
\item Définir la fonction $Nb(x)$ qui renvoie le numérateur et le dénominateur de $a+\dfrac{b}{n}$. 
\item Définir le quotient de la fonction $Q(x)$ qui renvoie le quotient $a_0+\dfrac{1}{a_1+\dfrac{1}{a_2+\dfrac{1}{a_3+...\dfrac{1}{a_r}}}}$ avec $r$ le plus petit entier tel que $a_r<1$.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 21}
\subsection*{Exercice 21}
\begin{center}
\includegraphics[width=.8\linewidth]{images/exo_21_pt_el.png}
\end{center}
Une carte numérotant des pays est numérotée de 0 à $i$.  Chaque pays se voit attribuer une couleur. Le but est que des pays voisins n'aient pas la même couleur. 

\begin{enumerate}
\item Écrire la liste carte constituée elle-même de liste donnant pour chaque pays le numéro des pays dont le numéro est supérieur à ce pays et ayant une frontière commune avec ce pays. Exemple : \texttt{carte[3]=[6]}, \texttt{carte[5]=[6,7]}.
\item Définir une fonction \texttt{voisins} de paramètres \texttt{(i,j,carte)} avec $i\neq j$. Cette fonction doit renvoyer un booléen \texttt{True} ou \texttt{False} si les pays $i$ et $j$ ont une frontière commune.
\item On attribue une couleur à chaque pays. Les couleurs sont représentées par des entiers naturels. On définit la liste \texttt{color} qui attribue pour chaque pays un numéro correspondant à sa couleur. Si le pays n'a pas de couleur, son numéro est $-1$. 

Définir la fonction \texttt{donnecouleur} de paramètre \texttt{p} pour le numéro de pays, \texttt{carte} et \texttt{color}. La fonction doit changer la liste couleur de façon à attribuer au pays \texttt{p} la couleur la plus petite tel qu'il ait une couleur différente de ses voisins. 

Exemple avec 3 : le pays 3 correspond à \texttt{p=2}. Admettons que les pays 2 et 4 aient respectivement les couleurs 1 et 2, on attribue à 4 la couleur 2. 
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 22}
\subsection*{Exercice 22}
Soit \texttt{L} une liste triée et \texttt{a} un réel. 
\begin{enumerate}
\item Écrire la fonction \texttt{ajout(L,a)} qui insère \texttt{a} dans \texttt{L} au bon endroit. 
\item Écrire la fonction \texttt{fusion(L1,L2)} qui classe en une liste triée la somme de \texttt{L1} et \texttt{L2}.
\end{enumerate}



\addcontentsline{toc}{subsection}{Exercice 23}
\subsection*{Exercice 23}
On étudie les entiers tels que $n=a^3+b^3$. 
\begin{enumerate}
\item Montrer que $3$ ne s'écrit pas comme la somme de 2 cubes.
\item Écrire un programme afin de déterminer la liste des entiers $n$ tels que $n=a^3+b^3$ avec $n<100$.
\item Écrire une fonction renvoyant un booléen nous indiquant si $n$ est la somme de deux cubes. 
\item Écrire une fonction qui indique si $n$ est la somme de 2 cubes et l'ensemble des couples \texttt{(a,b)} tels que $n=a^3+b^3$.
\end{enumerate}

\end{multicols}


\newpage 


\begin{multicols}{2}

\section{Exercices issus de <<L'informatique pas à pas en prépa, éditions ellipses>>, Frédéric Butin}

\addcontentsline{toc}{subsection}{Exercice 1 -- Opérations sur les polynômes}
\subsection*{Exercice 1 -- Opérations sur les polynômes -- 2.11.3 p.50}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
Un polynôme $P=\sum\limits_{j=0}^{n}a_j X^j \in \mathbb{R}[X]$ de degré $n$ est représenté dans cet exercice par le tableau $P=[a_0,...,a_n]$.

\begin{enumerate}
\item Créer une fonction \texttt{affiche\_poly} qui permet d'afficher un polynôme sous la forme $P=\sum\limits_{j=0}^{n}a_j X^j$.
\item Créer une fonction \texttt{degre\_poly} qui calcule le degré d'un polynôme.
\item Implémenter la somme, le produit et la multiplication par un scalaire comme des fonctions notées \texttt{add\_poly}, \texttt{mul\_poly} et \texttt{mul\_sca\_poly}.
\item Créer une fonction \texttt{prsc\_poly} qui calcule le prduit scalaire canonique de deux polynômes.
\item Créer une fonction \texttt{deriv\_poly} qui calcule la dérivée d'un polynôme.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 2 -- Produits polynômes}
\subsection*{Exercice 2 -- Produits polynômes -- 2.11.20 p.65}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
Un polynôme $P=\sum\limits_{j=0}^{n}a_j X^j \in \mathbb{R}[X]$ de degré $n$ est représenté dans cet exercice par le tableau $P=[a_0,...,a_n]$.

\begin{enumerate}
\item Créer une fonction \texttt{affiche\_poly} qui permet d'afficher un polynôme sous la forme $P=\sum\limits_{j=0}^{n}a_j X^j$.
\item Créer une fonction \texttt{degre\_poly} qui calcule le degré d'un polynôme.
\item Implémenter le produit de deux polynômes. On notera \texttt{mul\_poly} cette fonction. Donner sa complexité.
\end{enumerate}
On suppose désormais que $n=2^k=2m$. La méthode qui suit permet de calculer le produit de deux polynômes en utilisant le principe <<diviser pour régner>>. 

On pose $P=P_1+X^m P_2$ et $Q=Q_1+X^mQ_2$, où $P_1$ et $Q_1$ sont de degré strictement inférieur à $m$. Ainsi, $PQ=P_1Q_1+X^m\left(P_1Q_2 + Q_1P_2\right)+X^n P_2 Q_2$. 

\begin{enumerate}
\item Calculer le produit de deux polynômes de degré strictement inférieur à $n$ revient donc à calculer 4 produits de deux polynômes de degré inférieur à $\dfrac{n}{2}$. Implémenter cet algorithme en une fonction \texttt{mul\_poly\_div}. Quelle est sa complexité ? Qu'en conclure ?
\item Une autre méthode de calcul consiste à poser $R_1=P_1Q_1$, $R_2=P_2Q_2$ et $R_3=\left(P_1+P_2 \right)\left(Q_1+Q_2 \right)$. Expliciter $PQ$ en fonction des polynômes $R_1$, $R_2$, $R_3$. En déduire un algorithme (appelé algorithme de Karatsuba) permettant le calcul de $PQ$ que l'on implémentera en une fonction \texttt{mul\_poly\_kara}. Comparer la complexité de cet algorithme à celle des algorithmes des questions précédentes. 
\item Que faire quand $n$ n'est pas de la forme $2^k$.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 3 -- Courbes en polaires}
\subsection*{Exercice 3 -- Courbes en polaires -- 4.6.25 p.111}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

Pour tout $n \in \mathbb{N}^*$, on considère $\Gamma_n$ en coordonnées polaires définie par :
$$
\sigma_n(\theta) = \cos^3 \left( n\theta\right) - \sin^3 \left( n\theta\right).
$$
\begin{enumerate}
\item Représenter la courbe $\Gamma_0$.
\item Représenter sur un même graphique les courbes $\Gamma_j$, pour $j \in \llbracket 0,3\rrbracket $.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 4 -- Fonction de Takagi}
\subsection*{Exercice 4 -- Fonction de Takagi -- 4.6.26 p.112}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

La fonction de Takagi est définie sur $[0,1]$ par $T:x\mapsto \sum\limits_{k=0}^{\infty} \dfrac{d\left( 2^k x \right)}{2^k}$, où $d(y)$ représente la distance de $y$ à l'entier le plus proche. On peut montrer que cette fonction est continue sur $[0,1]$ mais nulle part dérivable.
\begin{enumerate}
\item Pour tout entier $n\in \mathbb{N}$, majorer $||T-T_n||_{\infty}=\sup\limits_{x\in[0,1]} |T(x)-T_n(x)|$ où $T_n:x \mapsto \sum\limits_{k=0}^{n} \dfrac{d\left( 2^k x \right)}{2^k}$.
\item Représenter le graphe de cette fonction, appelé la courbe du blanc-manger.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 5 -- Modèle logistique}
\subsection*{Exercice 5 -- Modèle logistique -- 4.6.27 p.113}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

Pour tout $a\in]0,3]$,  on considère la suite récurrente $(u_n)_{n\in\mathbb{N}}$ définie par $u_0 \in \left[ 0,1+\dfrac{1}{a}\right]$ et pour tout $n\in\mathbb{N}^*$, $u_{n+1}=\left(1+a\left(1-u_n \right) \right)u_n$. Cette suite représente, à un facteur près, la population d'une espèce.

\begin{enumerate}
\item Pour $a=1$ et $u_0=0,5$, représenter graphiquement les 10 premiers termes de la suite.
\item On fixe $u_0=0,5$. Créer une procédure qui reçoit en arguments $a_1$, $c$, $a_2$ et permet de représenter les termes $u_n$ pour $n\in \llbracket 100,200 \rrbracket$ et $a=a_1+jc$, $j\in\llbracket 0,\lfloor \dfrac{a_2-a_1}{c}\rfloor \rrbracket$ (les points sont à tracer sont des points de coordonnées $(a,u_n)$.
\item Exécuter cette procédure avec $a_1=2$, $c=0,005$, $a_2=3$ puis avec $a_1=2.84$, $c=0,0001$, $a_2=2,86$.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 6 -- Enveloppe d'une famille de droites}
\subsection*{Exercice 6 -- Enveloppe d'une famille de droites -- 4.6.28 p.115}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

Doit $\left(D_t\right)_{t\in I}$ une famille de droites du plan affine, où $I$ est un intervalle de $\mathbb{R}$. On munit le plan d'un repère, de sorte que la droite $D_t$ a pour équation :
$$
u(t) x+v(t) y + w(t) = 0.
$$

On suppose que les applications $u$, $v$, $w$ sont de classe $\mathcal{C}^1$ sur $I$ et qu'elles ne s'annulent pas en même temps. 

On cherche une courbe paramétrée $f:I \to \mathbb{R}^2$ telle que pour tout $t\in I$, 
\begin{itemize}
\item $f(t)\in D_t$;
\item $D_t$ est tangente à la courbe en $f(t)$.
\end{itemize}
Quand elle existe, cette courbe est appelée l'enveloppe de la famille de droits $\left(D_t\right)_{t\in I}$. 
\begin{enumerate}
\item On note $f(t)=\left(x(t),y(t)\right)$. Montrer que $\left(x(t),y(t)\right)$ est solution du système :
$$
\left\{
\begin{array}{l}
u(t) x(t) + v(t) y(t)= -w(t) \\
u'(t) x(t) + v'(t) y(t)= -w'(t) \\
\end{array}
\right. .
$$
En déduire qu'au voisinage de tout point $t_0 \in I$ tel que :
$$
\left| 
\begin{array}{cc}
u(t_0) & v(t_0) \\
u'(t_0) & v'(t_0)
\end{array}
\right|
\neq 0
$$,
le système précédent a une unique solution, donnée par :
$$
x(t)=\dfrac{\left| 
\begin{array}{cc}
-w(t) & v(t) \\
-w'(t) & v'(t)
\end{array}
\right|
}{\left| 
\begin{array}{cc}
u(t) & v(t) \\
u'(t) & v'(t)
\end{array}
\right|},
y(t)=\dfrac{\left| 
\begin{array}{cc}
u(t) & -w(t) \\
u'(t) & -w'(t)
\end{array}
\right|
}{\left| 
\begin{array}{cc}
u(t) & v(t) \\
u'(t) & v'(t)
\end{array}
\right|}.
$$
\item Déterminer une paramétrisation de l'enveloppe $E$ de la famille des droites $\left(D_t\right)_{t\in \mathbb{R}}$ d'équation :
$$
\sin(t) x - \cos(t) y -\sin^2(t)=0.
$$
\item Représenter, sur un même graphique, $E$ et plusieurs droites $D_t$.
\end{enumerate}



\addcontentsline{toc}{subsection}{Exercice 7 -- Hypocycloïde}
\subsection*{Exercice 7 -- Hypocycloïde -- 4.6.29 p.117}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

Un cercle $ \Gamma\left(\Omega,r\right)$ roule sans glisser à l'intérieur du cercle $C\left(O,R\right)$ (où $R>r$). On note $M=M(\theta)$ un point de $\Gamma$ dont étudie la trajectoire. On note $\theta$ l'angle $\left( \widehat{\vect{i},\vect{O\Omega}}\right)$ et $\varphi$ l'angle $\left( \widehat{\vect{\Omega I},\vect{\Omega M}}\right)$. Initialement, $\Omega$ est situé sur l'axe horizontal et $M$ est situé en $I_0$.

\begin{center}
\begin{tikzpicture}
\draw(0,0) circle (2);
\draw({1.6*sqrt(2)/2},{1.6*sqrt(2)/2}) circle (.4);
\draw (-2,0) -- (2,0) node [right] {\small $I_0$};
\draw (0,-2) -- (0,2);
\draw (0,0) node [above left] {$O$} -- ({2*sqrt(2)/2},{2*sqrt(2)/2}) node [above] {\small $I$};
\draw [-latex] (0.5,0) arc (0:45:0.5);
\draw (0.5,0.25) node [right] {$\theta$};
\draw({1.6*sqrt(2)/2},{1.6*sqrt(2)/2}) -- ++ ({.4*sqrt(2)/2},{-.4*sqrt(2)/2}) node [below]{\small $M$};
\draw ({1.6*sqrt(2)/2},{1.6*sqrt(2)/2}) node [above] {\small $\Omega$};
\draw [-latex] ({1.8*sqrt(2)/2},{1.8*sqrt(2)/2}) arc (45:-45:0.2);
\draw (1.24,1.15) node [right] {\footnotesize$\varphi$};
\end{tikzpicture}
\end{center}

\begin{enumerate}
\item Montrer que l'affixe de $M$ est donnée par $z(\theta)=\left(R-r\right) \exp\left(i\theta \right) + r \exp\left(i  m \theta \right)$ où $m=1-\dfrac{R}{r}$. Ainsi, $M$ a pour coordonnées :
$$
\left\{
\begin{array}{l}
x(\theta)= \left(R-r\right) \cos \theta +r \cos \left(m \theta \right) \\
y(\theta)= \left(R-r\right) \sin \theta +r \sin \left(m \theta \right) 
\end{array}
\right. .
$$
\item On choisit $R=4$ et $r=\dfrac{R}{4}$. Représenter la trajectoire de $M$. La courbe obtenue est appelée astroïde. 
\item On choisit $R=4$ et $r=\dfrac{R}{p}$ où $p\in \mathbb{N}$. Représenter, pour différentes valeurs de $p$, $\Gamma\left(\Omega,r\right)$ roulant sur $C\left(O,R\right)$, ainsi que la trajectoire de $M$. La courbe obtenue est appelée hypocycloïde à $p$ rebroussements. 
\item Vérifier que ces points sont effectivement des points de rebroussement.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 8 -- Ensembles de Mandelbrot et de Julia}
\subsection*{Exercice 8 -- Ensembles de Mandelbrot et de Julia -- 4.6.30 p.119}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

L'ensemble de Mandelbrot est la partie $M$ du plan complexe définie par $M=\left\{c \in \mathbb{C} / \right.$ la suite $\left(z_n \right)_{n\in\mathbb{N}}$ définie par $z_0=0$ et $z_{n+1}=z_n^2+c$ est bornée \}.

De même, pour tout $c \in \mathbb{C}$, l'ensemble de Julia de paramètre $c$ est défini par 
$J_c=\left\{z \in \mathbb{C} / \right.$ la suite $\left(z_n \right)_{n\in\mathbb{N}}$ définie par $z_0=z$ et $z_{n+1}=z_n^2+c$ est bornée \}.

On souhaite représenter l'ensemble de Mandelbrot. On fixe un entier $p$ assez grand, et pour chaque point $c\in\mathbb{C}$, on s'intéresse à la suite $\left(z_n \right)_{n\in\mathbb{N}}$ définie par $z_0=0$ et pour tout $n\in\mathbb{N}$, $z_{n+1}=z_n^2+c$. On considère que cette suite n'est pas bornée s'il existe $k\leq p$ tel que $|z_k| \geq 4$.

\begin{enumerate} 
\item Représenter l'ensemble de Mandelbrot. On pourra utiliser la fonction \texttt{imshow} qui permet de représenter, par une couleur différente, chaque valeur de $k_0$, où $k_0$ est le plus petit entier tel que $|z_{k0}|\geq 4$.
\item En procédant de même, représenter l'ensemble de Julia $J_c$ pour différentes valeur de $c$.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 9 -- Courbe de Peano}
\subsection*{Exercice 9 -- Courbe de Peano -- 4.6.31 p.122}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

La courbe de Peano est construite à partir d'un motif de base dans le lequel on remplace chacun des 9 segments par le motif complet auquel on a appliqué une homothétie de rapport $\dfrac{1}{3}$. 

\begin{enumerate}
\item S'approprier le module \texttt{turtle} en réalisant un cercle avec la tortue.
\item En utilisant la tortue de Python, écrire une procédure récursive qui reçoit un entier $n$ et trace la courbe obtenue en itérant $n$ fois le procédé décrit ci-dessus.
\end{enumerate}
\begin{rem}
Pour utiliser le module \texttt{turtle} :
\begin{itemize}
\item importer le module : \texttt{import turtle};
\item cacher la tortue : \texttt{turtle.hideturtle()};
\item choisir la vitesse de la tortue : \texttt{turtle.speed(10)};
\item faire en sorte que la tortue laisse un trait sur son chemin : \texttt{tortue = turtle.Pen()};
\item faire avancer la tortue de 5 : \texttt{tortue.forward(5)};
\item faire tourner la tortue de 90 degrés vers la gauche : \texttt{tortue.left(90)}.
\end{itemize}
\end{rem}

\begin{center}
\includegraphics[width=.55\linewidth]{images/peano}
\end{center}

\addcontentsline{toc}{subsection}{Exercice 10 -- Flocon de Koch}
\subsection*{Exercice 10 -- Flocon de Koch -- 4.6.32 p.123}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
Le flocon de Koch est construit à partir d'un triangle équilatéral sur chacun des trois côtés duquel on applique les transformations suivantes : 
\begin{itemize}
\item on divise le côté en trois segments de même longueur;
\item on construit un triangle équilatéral ayant pour base le segment du milieu dont on supprime la base.
\end{itemize}
\begin{enumerate}
\item Si cela n'a pas été fait, s'approprier le module \texttt{turtle} en réalisant un cercle avec la tortue.
\item En utilisant la tortue de Python, écrire une procédure récursive qui reçoit un entier $n$ et trace le flocon de Koch en itérant $n$ fois le procédé décrit ci-dessus.
\end{enumerate}

\begin{center}
\begin{tabular}{ccc}
\includegraphics[width=.25\linewidth]{images/exo_FB_10_K1} &
\includegraphics[width=.25\linewidth]{images/exo_FB_10_K2} & 
\includegraphics[width=.25\linewidth]{images/exo_FB_10_K3} \\
\end{tabular}
\begin{tabular}{ccc}
\includegraphics[width=.4\linewidth]{images/exo_FB_10_K4} & 
\includegraphics[width=.4\linewidth]{images/exo_FB_10_K5}
\end{tabular}
\end{center}

\addcontentsline{toc}{subsection}{Exercice 11 -- Intégration numérique}
\subsection*{Exercice 11 -- Intégration numérique -- 4.6.33 p.124}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

On considère la fonction $f:x \mapsto \ln x$.
\begin{enumerate}
\item Calculer $I=\int\limits_1^4 f(x) \text{d}x$.
\item Comparer l'erreur entre $I$ et la valeur approchée de $I$ obtenue par les méthodes des rectangles et des trapèzes en approchant un nombre de points $n$ où $n$ parcourt la suite $[10,20,40,100,200, 400, 500, 600, 700, 800, 900, 1000,$ $5000, 10000, 20000, 100000]$.
\item Représenter graphiquement cette erreur en prenant une échelle $\log$ -- $\log$. Expliquer les graphes obtenus.
\end{enumerate}

\begin{rem}
Tracé en diagramme log -- log :

\texttt{plt.loglog(x,y)}.
\end{rem}

\addcontentsline{toc}{subsection}{Exercice 12 -- Équation différentielle}
\subsection*{Exercice 12 -- Équation différentielle -- 4.6.34 p.125}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

Pour $n \in \mathbb{N}$, on considère l'équation différentielle : 
$$
x''(t) +10 x'(t) - x(t)=\sin \left( nt \right).
$$
\begin{enumerate}
\item Résoudre cette équation différentielle avec les conditions initiales $x(0)=0$ et $x'(0)=1$.
\item Représenter le graphe des solutions pour $n\in \llbracket 0,10 \rrbracket$ et $t \in[0,7]$.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 13 -- Suite de Fibonacci}
\subsection*{Exercice 13 -- Suite de Fibonacci -- 4.6.41 p.135}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

La suite de Fibonacci est la suite $\left( F_n \right)_{n \in \mathbb{N}}$ définie par $F_0=1$, $F_1=1$ et pour tout $n\in \mathbb{N}$, $F_{n+2}=F_{n+1}+F_{n}$.

\begin{enumerate}
\item Écrire une fonction qui calcule $F_n$ à l'aide de produits de matrice.
\item Déterminer la complexité de la procédure de la question précédente en nombre d'additions et en nombre de multiplications. On distinguera les cas où :
\begin{itemize}
\item la méthode d'exponentiation naïve est utilisée;
\item la méthode d'exponentiation rapide est utilisée.
\end{itemize}
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 14 -- Produits de matrices}
\subsection*{Exercice 14 -- Produits de matrices -- 4.6.42 p.136}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
\begin{enumerate}
\item Calculer la complexité, en termes d'opérations sur les coefficients, de l'addition et de la multiplication de deux matrices de $M_n\mathbb{R}$ par la méthode naïve qui consiste à utiliser la définition du produit.

On suppose désormais que $n=2^k=2m$.
\item Une méthode de calcul de produit de deux matrices qui repose sur le principe << diviser pour régner >> est la suivante. On pose : 
$$
M=
\begin{bmatrix}
M_{11} & M_{12} \\
M_{21} & M_{22}
\end{bmatrix} 
\quad
\text{et}
\quad
N=
\begin{bmatrix}
N_{11} & N_{12} \\
N_{21} & N_{22}
\end{bmatrix} .
$$
On a donc :
$$
P=MN = 
\begin{bmatrix}
P_{11} & P_{12} \\
P_{21} & P_{22}
\end{bmatrix}
$$
avec :
$$
\begin{array}{ll}
P_{11} = M_{11}N_{11} + M_{12}N_{21} & 
P_{12} = M_{11}N_{12} + M_{12}N_{22} \\
P_{21} = M_{21}N_{11} + M_{22}N_{21} & 
P_{22} = M_{21}N_{12} + M_{12}N_{22}.
\end{array}
$$
Ainsi calculer le produit de deux matrices $M_n\mathbb{R}$ revient à calculer 8 produits de deux matrices de $M_{n/2}\mathbb{R}$.

Implémenter cet algorithme en une fonction \texttt{prod\_div}. Quelle est sa complexité ? Qu'en conclure ?
\item Une autre méthode de calcul consiste à poser 
$C_1 =M_{11}\left(N_{12} - N_{22} \right)$, 
$C_2 =N_{22}\left(M_{11} + M_{12} \right)$, 
$C_3 =N_{11}\left(M_{21} + M_{22}\right)$, 
$C_4 =M_{22}\left(N_{21} - N_{11} \right)$, 
$C_5 =\left(M_{11} + M_{22} \right) \left(N_{11} + N_{22} \right)$, 
$C_6 =\left(M_{12} - M_{22} \right)\left(N_{21} + N_{22} \right)$
et
$C_7 =\left(M_{11} - M_{21} \right)\left(N_{11} + N_{12} \right)$. Expliciter $P_{11}$, $P_{12}$, $P_{21}$ et $P_{22}$ en fonction des matrices $C_1$, ..., $C_7$. En déduire un algorithme (appelé algorithme de Strassen) permettant le calcul de $P=MN$ que l'on implémentera en une fonction \texttt{prod\_strassen}. Comparer la complexité de cet algorithme à celle des algorithmes des questions précédentes. 
\item Que faire quand $n$ n'est pas de la forme $2^k$ ?
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 15 -- Équations différentielles}
\subsection*{Exercice 15 -- Équations différentielles -- 4.6.46 p.144}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
On souhaite résoudre par différences finies l'équation :
$$
u''(x)+2u(x) = 2 \cos x + \sin^2 x
$$
sur $[0,\pi]$ avec les conditions aux limites $u(0)=0$ et $u(\pi)=0$.

On considère la subdivision $0=x_0<x_1<...<x_n<x_{n+1} = \pi$ de l'intervalle $[0,\pi]$ où $x_i=ih$ et $h=\dfrac{\pi}{n+1}$. Pour tout $i$, on note $u_i$ la valeur approchée cherchée de $u(x_i)$ et on approche la dérivée seconde $u''(x)$ par :
$$
\dfrac{u_{i-1}-2u_i+u_{i+1}}{h^2}.
$$

\begin{enumerate}
\item Montrer que le système d'équation obtenu s'écrit matriciellement $AU=F$, où 
$$
A= 
\begin{bmatrix}
2h^2 - 2 & 1        & & & \\
1           & \ddots & \ddots & &  \\
& \ddots & \ddots &\ddots  & \\
& & \ddots & \ddots &1\\  
&& & 1 & 2h^2-2 \\
\end{bmatrix}
$$

$$
F=
\begin{bmatrix}
h^2 f(x_1) \\
\vdots \\
h^2 f(x_n)
\end{bmatrix}
\quad
U=
\begin{bmatrix}
u_1 \\
\vdots \\
u_n
\end{bmatrix}
$$
avec $f:x\mapsto 2 \cos x + \sin^2 x$.
\item Résoudre le système linéaire et représenter graphiquement la solution. 
\item La solution exacte de l'équation est :
$$
\begin{array}{lcl}
u(x)&=&\dfrac{\sin \left(\sqrt{2} x\right)  \left( 3+5 \cos \left(\sqrt 2 \pi \right)\right)}{2\sin \left(\sqrt{2} \pi\right)} \\
&&- \dfrac{5\cos \left(\sqrt{2} x\right)}{2}
+ \dfrac{\cos x}{2} \left( 4+\cos x\right)
\end{array}.
$$
Superposer le graphe de la solution exacte au graphe de la solution approchée.
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 16 -- Équations des ondes}
\subsection*{Exercice 16 -- Équations des ondes -- 4.6.47 p.146}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
On souhaite résoudre par différences finies l'équation des ondes : 
$$
\partial_{tt} u(x,t) - c^2 \partial_{xx} u(x,t) = 0
$$

sur $[-5,5] \times [0,0.1]$ avec les conditions initiales $u(x,0)=\exp\left( {-10 x^2}\right)$ et 
$\partial_t u(x,0)=0$, et les conditions aux limites $u(-5,t)=u(5,t)=0$. 

On considère la subdivision $-5=x_0<x_1<\ldots <x_n <  x_{n+1} =5$ (resp. 
$0=t_0<t_i<\ldots<t_{m-1}<t_m=0,1$) de l'intervalle $[-5,5]$ (resp. $[0,0.1]$) où 
$x_i=-5+ih$ (resp. $t_k=kl$) et $h=\dfrac{10}{n+1}$ (resp. $l=\dfrac{0,1}{m}$).

Pour tout $(i,k) \in \llbracket 0,n+1 \rrbracket \times\llbracket 0,m \rrbracket $, on note $z_{i,k}$ la valeur approchée cherchée de $u\left(x_i,t_k\right)$ et l'on approche la dérivée première 
$\partial_{t} u(x_i,t_k)$ par $\dfrac{z_{i,k+1}-z_{i,k}}{l}$ et la dérivée seconde $\partial_{tt} u(x_i,t_k)$ par $\dfrac{z_{i,k+1}-2z_{i,k}+z_{i,k-1}}{l^2}$. On choisit $n=m=100$ et $c=31,6$.

\begin{enumerate}
\item Résoudre l'équation par différences finies en utilisant le schéma explicite, qui consiste à approcher la dérivée seconde $\partial_{xx} u(x_i,t_k)$ par l'expression $\dfrac{z_{i-1,k}-2z_{i,k}+z_{i+1,k}}{h^2}$.
\item Créer une animation permettant de visualiser la solution obtenue quand $t$ varie. 
\item Résoudre l'équation par différences finies en utilisant le schéma implicite, qui consiste à approcher la dérivée seconde $\partial_{xx} u(x_i,t_k)$ par l'expression :
$\dfrac{z_{i-1,k+1}-2z_{i,k+1}+z_{i+1,k+1}}{h^2}$.
\item Créer une animation permettant de visualiser la solution obtenue quand $t$ varie. 
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 17 -- Position d'une membrane}
\subsection*{Exercice 17 -- Position d'une membrane -- 4.6.49 p.153}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

On considère une membrane élastique dont le bord est fixé à un cadre carré horizontal. La membrane est soumise à une force verticale $f$. On peut montrer que l'altitude$z(x,y)$ de la membrane en un point du carré de coordonnées $(x,y)$ vérifie l'équation de Laplace :
$$
\Delta z\left( x,y\right) = f(x,y)
$$
 avec les conditions aux limites $z(x,y)=0$ sur le bord du carré. 
 
 On se place dans le cas où le cadre est le carré $[0,1]^2$ et où$f$ est constante, par exemple $f(x,y)=-4$ pour tout $(x,y)\in[0,1]^2$. 
 
 Pour résoudre cette équation par la discrétisation, on pose $h=\dfrac{1}{n+1}$ et pour tout $(i,j)\in \llbracket 0,n+4 \rrbracket^2$, $x_i=ih$ et $y_j=jh$: on obtient ainsi un quadrillage du carré $[0,1]^2$. On a déjà $z\left(x_i,y_j\right)=0$  si $i\in \{0,n+1\}$ ou $j \in \{0,n+1\}$ par hypothèse. On note $z_{i,j}$ l'approximation cherchée de $z\left(x_i,y_j\right)$ par $z_{i,j}$ et le laplacien $\Delta z\left(x_i,y_j\right)$ par son approximation à 5 points : 
 
 $$
 \dfrac{1}{h^2}\left( z_{i-1,j}+z_{i+1,j}+z_{i,j-1}+z_{i,j+1}-4z_{i,j}\right).
 $$
 
 On résout alors le système formé par les équations obtenues, qui est un système linéaire dont les inconnues sont les $z_{i,j}$ pour $(i,j)\in 
  \llbracket 0,1 \rrbracket^2$.
\begin{enumerate}
\item Étant donné $A=\left(a_{i,j}\right)_{(i,j)\in\llbracket 1,n \rrbracket^2 }$ et $B=\left(b_{i,j}\right)_{(i,j)\in\llbracket 1,n \rrbracket^2 }$ deux matrices de $M_n\mathbb{R}$, le produit de Kronecker $de$ A par $B$ est la matrice de $M_{n^2}\mathbb{R}$ définie par :
$$
A\otimes B = 
\begin{bmatrix}
a_{1,1}B & a_{1,2}B & \ldots & a_{1,n}B \\
a_{2,1}B & a_{2,2}B & \ldots & a_{2,n}B \\
\vdots  & & & \vdots  \\
a_{n,1}B & a_{n,2}B & \ldots & a_{n,n}B \\
\end{bmatrix} .
$$
La commande \texttt{kron} de numpy permet de calculer le produit de Kronecker. Observer que le système linéaire peut se mettre sous la forme $\left(A_n\otimes I_n+ I_n\otimes A_n\right)Z=F$ où $A_n$ est la matrice du laplacien de taille $n$, c'est à dire : 
$$
A_n = 
\begin{bmatrix}
2  & -1 & & \\
-1 & \ddots & \ddots & \\
   & \ddots &\ddots & -1\\
   &  & -1& 2\\
\end{bmatrix} .
$$
\item Résoudre l'équation par discrétisation, comme expliqué ci-dessus.
\item Représenter la membrane en 3d.
\end{enumerate}  


\addcontentsline{toc}{subsection}{Exercice 18 -- Polygones orthogonaux}
\subsection*{Exercice 18 -- Polygones orthogonaux -- 4.6.50 p.155}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
\begin{enumerate}
\item Pour $n=16$, créer en Python la base canonique de $\mathbb{R}_n[X]$. 
\item Définir le produit scalaire $\varphi : \left( P,Q\right) \mapsto \int\limits_{-1}^{1} P(t) Q(t) \text{d}t$ et la norme euclidienne associée sur $\mathbb{R}_n[X]$. 
\item En utilisant le procédé de Gram-Schmidt, orthonormaliser la  base canonique pour le produit scalaire $\varphi$.
\item Calculer la projection orthogonale de $h:x\mapsto \cos \left( 4\pi x\right)$ sur $\mathbb{R}_n[X]$ (approximation de $h$ au sens des moindres carrés).
\end{enumerate}


\addcontentsline{toc}{subsection}{Exercice 19 -- Système proies -- prédateurs}
\subsection*{Exercice 19 -- Système proies -- prédateurs -- 4.6.37 p.129}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
Le système proies-prédateurs est régit par les équations de Volterra qui forment le système non linéaire :
$$
\left\{
\begin{array}{l}
x'(t)=ax(t)-bx(t)y(t) \\
y'(t)=-cy(t)+dx(t)y(t) \\
\end{array}
\right. ,
$$
où $a$, $b$, $c$ et $d$ sont des réels strictement positifs. 
\begin{enumerate}
\item On pose $X=(x,y)^t$. Créer une fonction $f$ qui à $(X,t,a,b,c,d)$ fait correspondre $(ax-bxy,-cy+dxy)$.
\item Résoudre le système dans les conditions suivantes : $X=(1,2)$ et $a,b,c,d=1,1,1,1$. 
\item Représenter $x$ et $y$ sur un même graphique. 
\item Représenter les courbes paramétrées par $x$ et $y$, qui donne l'évolution des deux populations.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 20 -- Transformée de Fourier}
\subsection*{Exercice 20 -- Transformée de Fourier -- 4.6.65 p.241.}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
Implémenter en Python l'algorithme naïf de calcul de la transformée de Fourier d'un vecteur de $\mathbb{C}^N$.

\addcontentsline{toc}{subsection}{Exercice 21}
\subsection*{Exercice 21 -- 6.5.66 p.242.}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
Soit $f:\mathbb{R} \to \mathbb{R}$ l'application $2\pi$-périodique définie par :
$$
f(x)=\left\{
\begin{array}{l}
1  \quad \text{si} \quad x\in[0,\pi[ \\
10  \quad \text{si} \quad x\in[\pi,2\pi[
\end{array}
\right. .
$$
\begin{enumerate}
\item En utilisant la FFT, calculer des valeurs approchées des coefficients de Fourier de $f$. 
\item Représenter sur un même graphique $f$ et la somme approchée de sa série de Fourier.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 22 -- Débruitage d'un signal}
\subsection*{Exercice 22 -- Débruitage d'un signal -- 6.5.65 p.243.}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
On considère un signal donné par l'application :
$$
f:t \mapsto 3 \cos \left( 3t\right)+2\sin \left( 2t\right)-\dfrac{1}{2}\cos t
$$
échantillonné sur $n=100$  points équidistants $(t_k)_{k\in \llbracket 1,n\rrbracket}$ du segment $[0,2\pi]$. On introduit sur ce signal un bruit donné par une loi uniforme sur $[-1,1]$ : ainsi pour tout point $t_k$ d'échantillonnage, la valeur du signal n'est pas $f(t_k)$, mais $g(t_k) = f(t_k) + b_k$, où $b_k$ est une réalisation d'une loi uniforme sur $[-1,1]$.

\begin{enumerate}
\item Représenter sur un même graphique le signal $f$ et le signal bruité $g$.
\item Appliquer la FFT au signal bruité. Construire alors un nouveau signal débruité $h$ en supprimant les fréquences d'indices trop grands (on peut par exemple ne garder qu'un quart des fréquences).
\item Représenter $h$ sur le même graphique que $f$ et $g$.
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 23 -- Taches solaires}
\subsection*{Exercice 23 -- Taches solaires -- 4.6.65 p.244.}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}
Nous nous intéressons ici aux mesures de l'activité des taches solaires de l'année 1700 à l'année 2004. On appelle nombre de Wolf le nombre de taches solaires observées en une année. %Les données, écrites sous la forme [année, nombre Wolf], sont regrou

La transformée de Fourier, qui permet de passer du domaine temporel au domaine fréquentiel, donne la possibilité de savoir s'il existe une fréquence prédominante, c'est-à-dire si les données sont périodiques.

\begin{enumerate}
\item Représenter graphiquement le nombre Wolf en fonction de l'année. 
\item Effectuer la FFT de la liste des nombres de Wolf. On la note $Y$.Représenter alors $\mathfrak{I}\left(Y\right)$ en fonction de $\mathfrak{R}\left(Y\right)$.
\item On souhaite construire un chronogramme, c'est-à-dire une graphe de la puissance du signal en fonction de la fréquence (la puissance de la FFT étant égale au carré du signal de la FFT). 

Tracer ce chronogramme en utilisant uniquement les coefficients de $Y$ compris entre 1 et $E\left(\dfrac{n}{2}\right)$, où $n$ est le nombre de relevés (les coefficients situés au-delà de $E\left(\dfrac{n}{2}\right)$ correspondant à des coefficients de Fourier d'indices négatifs) : la plage de fréquences est donc :

$$
\left( \dfrac{k}{n} \right)_{k\in \llbracket 1, E\left(\dfrac{n}{2}\right) \rrbracket} = \left[ \dfrac{1}{n},\dfrac{2}{n},\ldots E\left(\dfrac{n}{2}\right) \dfrac{1}{n}\right].
$$

Tracer le graphe de la puissance du signal en fonction de la période. Que constate-t-on ?
\end{enumerate}

\addcontentsline{toc}{subsection}{Exercice 24 -- Traitement d'image -- Filtre}
\subsection*{Exercice 24 -- Traitement d'image -- Filtre -- 6.5.69 p.247.}
\begin{flushright}
\textit{D'après Frédéric Butin, l'informatique pas à pas en prépa, éditions ellipses.}
\end{flushright}

\begin{enumerate}
\item Créer une fonction qui permet d'afficher la composante rouge d'une image. 
\item Créer une fonction qui permet d'afficher la composante cyan.
\end{enumerate}

\end{multicols}



\newpage 
%\begin{multicols}{2}

\section{Corrigés -- Banque PT}
\addcontentsline{toc}{subsection}{Exercice 1 -- Arithmétique -- Corrigé}
\subsection*{Exercice 1 -- Arithmétique -- Corrigé}

\begin{corrige}
$\quad$
\begin{python}
# Question 1
n = 1234
q = n//10
r =  n%q

# r contient le nombre d'unités de n
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
s=0
while n!=0:
    q=n//10
    r = n%10
    #print(r)
    s=s+r**3
    n=q
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 3
def somcube(n):
    """
    Entrées :
     * n, int : nombre
    Sortie : 
     * s, int : somme des cubes du chiffre n
    """
    s=0
    while n!=0:
        q=n//10
        r = n%10
        s=s+r**3
        n=q
    return s
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 4
res = []
for i in range (10001):
    if i == somcube(i):
        res.append(i)
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 5
def somcube2(n):
    """
    Entrées :
     * n, int : nombre
    Sortie : 
     * s, int : somme des cubes du chiffre n
    """
    nombre=str(n)
    s=0
    for chiffre in nombre :
        s = s+int(chiffre)**3
    return s
    
print(somcube2(1234))
\end{python}
\end{corrige}

%\vfill

%%\columnbreak

\addcontentsline{toc}{subsection}{Exercice 2 -- Intégration -- Corrigé}
\subsection*{Exercice 2 -- Intégration -- Corrigé}

\begin{corrige}
$\quad$
\begin{python}
# Question 1
# ==========
# Le répertoire courant est Exercice_02.
# Le sous-répertoire data contient le
# fichier ex_02.txt.

# On ouvre le fichier en lecture)
fid = open("data\ex_02.txt")

# On charge le fichier dans une liste.
# Chaque élément de la liste correspond à 
# chaque ligne sous forme de chaîne de caractère.
file = fid.readlines()
# On ferme le fichier
fid.close()

LX=[]
LY=[]
for ligne in file :
    ligne = ligne.split(';')
    LX.append(float(ligne[0]))
    LY.append(float(ligne[1]))
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
# ==========
# Ne pas oublier de charger préalablement 
# import matplotlib.pyplot as plt

plt.plot(LX,LY)
plt.show()
\end{python}
\end{corrige}
\begin{center}
\includegraphics[width=6cm] {images/exo_02}
\end{center}


\begin{corrige}
$\quad$
\begin{python}
# Question 3
# ==========
def trapeze(x,y):
    res = 0 
    for i in range(1,len(LX)):
        res = res+(LX[i]-LX[i-1])*0.5*(LY[i]+LY[i-1])
    return res
print(trapeze(LX,LY))

>>> 75.13635
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 4
# ==========
from scipy.integrate import trapz
# Attention à l'ordre des arguments dans 
# la fonction trapz : les_y puis les_x
# Après l'import, help(trapz) permet d'avoir 
# de l'aide sur la fonction.
print(trapz(LY,LX))

>>> 75.13635
\end{python}
\end{corrige}

\addcontentsline{toc}{subsection}{Exercice 3 -- Graphe -- Corrigé}
\subsection*{Exercice 3 -- Graphe -- Corrigé}

\begin{corrige}
$\quad$
\begin{python}
# Question 1
# ==========
# Matrices avec des listes
M=[[0,9,3,-1,7],
      [9,0,1,8,-1],
      [3,1,0,4,2],
      [-1,8,4,0,-1],
      [7,-1,2,-1,0]]
\end{python}
\end{corrige}
%\newpage

\begin{corrige}
$\quad$
\begin{python}
# Question 2 & 3
# ==============
def voisins(M,i):
    """
    Entrées : 
      * M(lst) : graphe
      * i : noeud considéré
    Sortie :
      * v(lst) : liste des voisins
    """
    v = []
    # On cherche les voisins sur une ligne 
    # (on pourrait le faire sur une colonne)
    for j in range(len(M[i])):
        if M[i][j]>0:
            v.append(j)
    return v
    
# print(voisins(M,0))
\end{python}
\end{corrige}


\begin{corrige}
$\quad$
\begin{python}
# Question 4
# ==========
def degre(M,i):
    """
    Entrées : 
      * M(lst) : graphe
      * i : noeud considéré
    Sortie :
      * (int) : nomnbre de voisins
    """
    return len(voisins(M,i))
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 5
# ==========
def longueur(M,chemin):
    l = 0
    for i in range(len(chemin)-1):
        if M[chemin[i]][chemin[i+1]]<0:
            return -1
        else :
            l=l+M[chemin[i]][chemin[i+1]]
    return l
    
chemin = [1,2,3,1,4]
print(longueur(M,chemin))        
chemin = [0,4,2,1,0]
print(longueur(M,chemin))
\end{python}
\end{corrige}

\vfill

%\columnbreak
\addcontentsline{toc}{subsection}{Exercice 4 -- Corrigé}
\subsection*{Exercice 4 -- Corrigé}
\begin{corrige}
$\quad$
\begin{python}
# Question 1 
# ==========
def nombreZeros(t,i):
    if t[i]==1:
        return 0
    else : 
        res = 1
        j=i+1
        while j<len(t) and t[j]==0:
            res = res+1
            j=j+1
    return res
# t1=[0,1,1,1,0,0,0,1,0,1,1,0,0,0,0]
# print(nombreZeros(t1,4))
# print(nombreZeros(t1,1))
# print(nombreZeros(t1,8))
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
# ==========
def nombreZerosMax(t):
    max=nombreZeros(t,0)
    for i in range(1,len(t)):
        tmp = nombreZeros(t,i)
        if tmp>max:
            max = tmp
    return max
print(nombreZerosMax(t1))
\end{python}
\end{corrige}

\begin{corrige}
La complexité est quadratique ($\mathcal{O}^2$)  du fait de la boucle \texttt{for} et de la boucle \texttt{while} imbriquée.

Pour diminuer la complexité, il est possible de parcourir une seule fois la liste. On lit alors les termes un à un. Quand on détecte un zéro, on compte alors le nombre de zéros consécutifs et on poursuit jusqu'à la fin...

\end{corrige}

\addcontentsline{toc}{subsection}{Exercice 5 -- Corrigé}
\subsection*{Exercice 5 -- Corrigé}
D'après Mme Barré \url{http://www.lycee-lesage.net/}.


\begin{corrige}
$\quad$
\begin{python}
import math
import scipy.misc as scim
# Question 1 
# ==========
def Px_poisson(k, n, p):
    """
    Entrée : 
     * k(int)
     * n(int) : strictement positif
     * p(flt) : réel compris entre ]0, 1[
    X suit une loi de Poisson P(n*p)
    Sortie : 
     * flt : (np)^k exp(-np)/k!
    """
    np = n * p
    return (np)**k * math.exp(- np) / math.factorial(k)

n, p = 30, 0.1
lst_px = [Px_poisson(k, n, p) for k in range(n + 1)]
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
# ==========
def Py_binomiale(k, n, p):
    """
    Entrée : 
     * k(int)
     * n(int) : strictement positif
     * p(flt) : réel compris entre ]0, 1[
    Y suit une loi binomiale B(n,k)
    Sortie : 
     * int : B(n,k)*p^k *(1-p)^(n-k)
    """
    return scim.comb(n,k)*p**k*(1-p)**(n-k)

n, p = 30, 0.1
lst_py = [Py_binomiale(k, n, p) for k in range(n + 1)]
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 3
# ==========
def ecarts(n,p):
	"""
	Entrée :
     * n(int) : strictement positif
     * p(flt) : réel compris entre ]0, 1[
    Sortie : 
     * maxi(flt) écart maxi entre P(Y=k) et P(X=k)
    """
     
	lst_px = [Px_poisson(k, n, p) for k in range(n + 1)]
    lst_py = [Py_binomiale(k, n, p) for k in range(n + 1)]
    maxi = max([abs(lst_py[i]-lst_px[i]) for i in range(len(lst_px))])
    return maxi
    
#print(ecarts(n,p))
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 4
# ==========
def E(e,p):
	"""
	Retourne le plus petit entier naturel n tq ecart(n,p)<=e
	Entrée : 
	 * e(flt) : >0
	 * p(flt) : réel compris entre ]0, 1[
    Sortie :
     n(int)
	"""
	n=1
	while (ecarts(n,p))>e :
		n=n+1
	return n
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 5
# ==========
print(E(0.008,0.075))
print(E(0.005,0.075))
print(E(0.008,0.1))
#print(E(0.005,0.1))
\end{python}
\end{corrige}



%\columnbreak 

\addcontentsline{toc}{subsection}{Exercice 6 -- Corrigé}
\subsection*{Exercice 6 -- Corrigé}
\begin{corrige}
$\quad$
\begin{python}
# Import de fonctions
import matplotlib.pyplot as plt
from math import sqrt
# Question 1 
# ==========
def g(x):
    if x>= 0 and x<1 :
        return x
    elif x>1 and x<2 :
        return 1
xx = [0]
t=0
while t<=1.99:
    t=t+0.01
    xx.append(t)
yy = [g(x) for x in xx]
plt.plot(xx,yy)
plt.show()
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
# ==========
def f(x):
    if x>=0 and x<2 :
        return g(x)
    else : # x>=2
        return sqrt(x)*f(x-2)
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 3
# ==========
xxx = [0]
t=0
while t<=6:
    t=t+0.01
    xxx.append(t)
yyy = [f(x) for x in xxx]
plt.plot(xxx,yyy)
plt.show()
\end{python}
\end{corrige}

%\columnbreak 

\begin{corrige}
$\quad$
\begin{python}
# Question 4
# ==========
# On cherche à résoudre f(x)-4 = 0 sur
# l'intervalle [5,6]
def h(x):
    res = f(x)-4
    return res

a = 5.
b = 6.
while (b-a)>0.01:
    m=(a+b)/2
    if h(m)>0:
        b=m
    else :
        a=m
m=(a+b)/2

if h(m)<0:
    m= m+ abs(b-a)
print(m,h(m))
\end{python}
\end{corrige}
 

\addcontentsline{toc}{subsection}{Exercice 7 -- Corrigé}
\subsection*{Exercice 7 -- Corrigé}

\begin{corrige}
$\quad$
\begin{python}
# Question 1 
# ==========
def d(n):
    """
    Retourne la liste de tous les diviseurs de n.
    Entrée : 
     * n(int) : entier.
    Sortie : 
     * L(lst) : liste des diviseurs de n.
    """
    L =[1]
    for nombre in range(2,n+1):
        if n%nombre == 0:
            L.append(nombre)
    return L
print(d(4),d(10))
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2 
# ==========
def DNT_01(n):
    return d(n)[1:-1]
def DNT_02(n):
    L =[]
    for nombre in range(2,n):
        if n%nombre == 0:
            L.append(nombre)
    return L
print(DNT_01(4),DNT_02(4))
print(DNT_01(10),DNT_02(10))
\end{python}
\end{corrige}


\begin{corrige}
$\quad$
\begin{python}
# Question 3
# ==========
def sommeCarresDNT_01(n):
    L = DNT_01(n)
    res = [x**2 for x in L]
    return sum(res)
def sommeCarresDNT_02(n):
    L = DNT_01(n)
    res = 0
    for x in L:
        res = res + x*x
    return res
def sommeCarresDNT_03(n):
    L = DNT_01(n)
    res = 0
    for i in range(len(L)):
        res = res + L[i]**2
    return res
print(sommeCarresDNT_01(15),sommeCarresDNT_02(15),
    sommeCarresDNT_03(15))
\end{python}
\end{corrige}


\begin{corrige}
$\quad$
\begin{python}
# Question 4
# ==========
from math import sqrt
for i in range(1001):
    if i == sommeCarresDNT_01(i) :
        print(str(i)+"\t"+str(sqrt(i)))
# Conjecture les nombres recherchés sont 
# les carrés des nombres premiers. 
\end{python}
\end{corrige}


\addcontentsline{toc}{subsection}{Exercice 8 -- Corrigé}
\subsection*{Exercice 8 -- Corrigé}
\begin{corrige}
$\quad$
\begin{python}
# Question 1 
# ==========
chaine = "abcdefghijklmnopqrstuvwxyz"
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
# ==========
def decalage(chaine,n):
    chaine = chaine[n:-1]+chaine[0:n]
    return chaine
print(chaine,decalage(chaine,3))
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 3
# ==========
def indices(x,phrase):
    """
    Recherche des indices de x dans phrase
    Entrée : 
     * x(str) : un caractère
     * phrase(str)
    Sortie : 
     * res(lst) : liste des indices de x
    """
    res = []
    for i in range(len(phrase)):
        if phrase[i] == x:
            res.append(i)
    return res

print(indices("a","akjlkjalkjlkjalkjlkja"))
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 4
# ==========
def codage(n,phrase):
    ch = "abcdefghijklmnopqrstuvwxyz"
    ch_c = decalage(ch,n)
    print(ch_c)
    phrase_c=""
    for c in phrase :
        i = indices(c,ch)
        i = i[0]
        phrase_c = phrase_c+ch_c[i]
    return phrase_c
print(codage(3,"oralensam"))
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 5
# ==========
# Solution 1 : essayer les 26 permutations, 
# jusqu'à trouver une phrase qui est du sens.
# Solution 2 : statistiquement le e est la lettre
# la plus présente dans la langue française. On
# peut donc déterminer la fréquence d'apparition 
# des lettres. # La lettre la plus fréquente 
# peut être assimilée au "e".
# On calcule ainsi le décalage...
\end{python}
\end{corrige}

\addcontentsline{toc}{subsection}{Exercice 9 -- Fractale de Mandelbrot -- Corrigé}
\subsection*{Exercice 9 -- Fractale de Mandelbrot -- Corrigé}
\begin{corrige}
$\quad$
\begin{python}
# Question 1 
# ==========
def suite_u(c,n):
    """
    Calcul de la suite u au rang n.
    Entrées : 
     * c(flt) : nombre quelconque
     * n(int)
    Sortie : 
     * res(flt) : valeur de u(n)
    """
    res = 0
    i=0
    while i!=n:
        res = res*res+c
        i=i+1
    return res
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
def recherche_k(m,M,c):
    """ Recherche de k """
    k=0
    while k<=m:
        if abs(suite_u(c,k))>M:
            return k
        k=k+1
    return -1
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
def fonction_f(m,M,c):
    """ Fonction """
    k = recherche_k(m,M,c)
    if k>=0:
        return k
    else :
        return m+1
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
#===========
import matplotlib.pyplot as plt
m,M=10,20
LX = [-2+4*x/400 for x in range(401)]
LF = [fonction_f(m,M,x) for x in LX]
plt.plot(LX,LF,"*")
plt.show()
\end{python}
\end{corrige}
\begin{center}
\includegraphics[width=.4\linewidth]{programmes/Exercice_09/figure_1}
\end{center}
\begin{corrige}
$\quad$
\begin{python}
# Question 3
#===========
LX = [-2+2.5*x/100 for x in range(101)]
LY = [-1.1+2.2*x/100 for x in range(101)]
XY = [[[x,y] for x in LX] for y in LY]

for i in range(len(LX)):
    for j in range(len(LY)):
        XY[i][j]=fonction_f(
            m,M,complex(XY[i][j][0],XY[i][j][1]))
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}

# Question 4
#===========
res = 100
LX = [-2+2.5*x/res for x in range(res+1)]
LY = [-1.1+2.2*x/res for x in range(res+1)]
XY = [[[x,y] for x in LX] for y in LY]

for i in range(len(LX)):
    for j in range(len(LY)):
        XY[i][j]=fonction_f(
        m,M,complex(XY[i][j][0],XY[i][j][1]))

# plt.imshow(XY)
# plt.show()
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}

# Bilan 
#=======
def affichage(m,M,res):
    m = m
    M = M
    LX = [-2+2.5*x/res for x in range(res+1)]
    LY = [-1.1+2.2*x/res for x in range(res+1)]
    XY = [[[x,y] for x in LX] for y in LY]
    for i in range(len(LX)):
        for j in range(len(LY)):
            XY[i][j]=fonction_f(
                m,M,complex(XY[i][j][0],XY[i][j][1]))
    plt.imshow(XY)
    plt.show()
\end{python}
\end{corrige}

\begin{center}
\begin{tabular}{ccc}
\includegraphics[width=.3\linewidth]{programmes/Exercice_09/10_20_100} &
\includegraphics[width=.3\linewidth]{programmes/Exercice_09/10_20_500} & 
\includegraphics[width=.3\linewidth]{programmes/Exercice_09/20_40_500} \\
\textit{$m=10$, $M=20$} &
\textit{$m=10$, $M=20$} &
\textit{$m=20$, $M=40$} \\
\textit{100 points par 100 points} & 
\textit{500 points par 500 points} & 
\textit{500 points par 500 points} \\
\end{tabular}
\end{center}


%\columnbreak 

\addcontentsline{toc}{subsection}{Exercice 10 -- Corrigé}
\subsection*{Exercice 10 -- Corrigé}
\begin{corrige}
$\quad$
\begin{python}
import numpy as np
# Question 1
R = np.array([[1,2,3],[4,5,6]])
S = np.array([[1,2,3],[4,5,6],[7,8,9]])
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
def test(M):
    """
    Fonction permettant de tester si la
    matrice est carrée et retournant sa taille.
    Entrée : 
     * M(numpy.ndarray) : matrice
    Sortie :
     * 0 si taille non carrée
     * n(int) : taille de M si elle est carrée
    """
    l = M.shape[0]
    c = M.shape[1]
    if l==c :
        return l
    else : 
        return 0
print(test(R),test(S))
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 3
fid = open("data/ex_006.txt",'r')
M1 = []
for ligne in fid :
    l = ligne.rstrip().split(" ")
    Ligne = [float(x) for x in l]
    M1.append(Ligne)
fid.close()
M1 = np.array(M1)
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 4
if test(M1)>0:
    valeurs_propres = np.linalg.eig(M1)[0]
    print(valeurs_propres)
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 5
def dansIntervalle(L,a,b):
    """
    Vérifier que chaque élément de L est dans 
    l'intervalle [a,b]
    Entrées : 
     * L(lst) : liste de nombres
     * a,b(flt) : nombres
    Sortie : 
     * True si chaque élément est dans [a,b]
     * False sinon. 
    """   
    for e in L :
        if e<a or e> b:
            return False
    return True
print(dansIntervalle(valeurs_propres,0,1))
\end{python}
\end{corrige}

\addcontentsline{toc}{subsection}{Exercice 11 -- Tri de liste -- Corrigé}
\subsection*{Exercice 11 -- Tri de liste -- Corrigé}

\begin{corrige}
$\quad$
\begin{python}
# Question 1 
# ==========
def comptage(L,n):
    """
    Comptage des éléments de L.
    Entrées :
     * n(int) : entier
     * L(lst) : liste d'éléments inférieurs à n
    """
    P = [0 for i in range(n+1)]
    # P = [0]*(n+1)
    for e in L:
        P[e]=P[e]+1
    return P
from random import randint
maxi = 5
LL = [randint(0,maxi) for x in range(20)]
P = comptage(LL,maxi)
# print(LL)
# print(P)
\end{python}

\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
# ==========
def tri(L,n):
    """
    Tri une liste.
    Entrées :
     * n(int) : entier
     * L(lst) : liste d'éléments inférieurs à n
    Sortie : 
     * T(lst) : liste triée.
    """
    P = comptage(L,n)
    T = []
    for i in range(len(P)):
        for j in range(P[i]):
            T.append(i)
    return T
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 3
# ==========
from random import randint
maxi = 5
LL = [randint(0,maxi) for x in range(20)]
T = tri(LL,maxi)
print(LL)
print(T)
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 4
# ==========
# Complexité quadratique : C(n)=O(n+n^2)=O(n^2)
# n : complexité de comptage
# n^2 : complexité des deux boucles imbriquées du 
# tri
# Ce tri s'exécutera toujours dans le pire des cas.
# Dans le cas moyen : tri fusion O(nlogn)
# Dans le cas moyen : tri insertion O(n^2)
\end{python}
\end{corrige}
 
%\columnbreak

\addcontentsline{toc}{subsection}{Exercice 12 -- Corrigé}
\subsection*{Exercice 12 -- Corrigé}

\begin{corrige}
$\quad$
\begin{python}
b,w = 0.5,6
# Question 1 
# ==========
import numpy as np
def fonc_p(t):
    return [np.cos(t)+b*np.cos(w*t),np.sin(t)
    			+b*np.sin(w*t)]
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
def fonc_v(t):
    return [-np.sin(t)-b*w*np.sin(w*t),np.cos(t)
    			+b*w*np.cos(w*t)]
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
def fonc_a(t):
    return [-np.cos(t)-b*w*w*np.cos(w*t),
    		 -np.sin(t)-b*w*w*np.sin(w*t)]
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
# ==========
L=np.linspace(-np.pi,np.pi,200)
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 3
# ==========
import matplotlib.pyplot as plt
p = fonc_p(L)
#plt.plot(p[0],p[1])
#plt.axis("equal")
#plt.show()
\end{python}
\end{corrige}

\begin{center}
\includegraphics[width=.4\linewidth]{programmes/Exercice_12/figure_1}
\end{center}

\begin{corrige}
$\quad$
\begin{python}
# Question 4
# ==========
def fonc_d(t):
    xp,yp = fonc_v(t)
    xpp,ypp = fonc_a(t)
    return (xp**2 + yp**2)/(xp*ypp-yp*xpp)
def fonc_c(t):
    fd = fonc_d(t)
    x,y = fonc_p(t)
    xp,yp = fonc_v(t)
    return [x-fd*yp,y+fd*xp]
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 5
# ==========
les_xc  = []
les_yc  = []
c = fonc_c(L)
#plt.plot(c[0],c[1])
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 6
# ==========
from math import sqrt
def distance(p):
    """
    Calcule la longueur du profil p.
    Entrée : 
     * p(lst) : liste [les_x,les_y]
    Sortie : 
     * L(flt) : longueur du profil.
    """
    L=0
    for i in range(len(p[0])-1):
        x0 = p[0][i]
        y0 = p[1][i]
        x1 = p[0][i+1]
        y1 = p[1][i+1]
        L = L+ sqrt((x1-x0)**2+(y1-y0)**2)
    return L
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
les_dt = []
les_dist = []
for i in range(10,2000,1) :
    dt = 2*np.pi/i
    L=np.linspace(-np.pi,np.pi,i)
    p = fonc_p(L)
    d = distance(p)
    les_dt.append(dt)
    les_dist.append(d)
plt.plot(les_dt,les_dist)
plt.show()       
\end{python}
\end{corrige}


\begin{center}
\includegraphics[width=.4\linewidth]{programmes/Exercice_12/figure_2}

\textit{Évolution de la longueur du polynôme en fonction de $\delta t$.}
\end{center}


%\end{multicols}

\newpage 

\section{Correction -- Adaptés des exercices de F. Butin}

\begin{multicols}{2}
\addcontentsline{toc}{subsection}{Exercice 10 -- Corrigé}
\subsection*{Exercice 10 -- Corrigé}
\textit{D'après Lucie Bathie, PT$\star$ 2015--2016.}


\begin{corrige}
$\quad$
\begin{python}
##Exo 10: palindrome
#1.
def inverse(mot):
    """renvoie la chaine de caractères écrite à l'envers"""
    liste = []
    for k in range(len(mot)):
        liste.append(mot[k])
    inverse = ''
    for i in range(1,len(liste)+1):
        inverse = inverse + liste[-i]
    return(inverse)
#print(inverse('bonjour'))
#ruojnob
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
#2.
def palindrome(mot):
    return(inverse(mot)==mot)
#print(palindrome('kayak'))
#True
#print(palindrome('bonjour'))
#False
\end{python}
\end{corrige}


\begin{corrige}
$\quad$
\begin{python}
#3.
def pat_nombre(N):
    """renvoie la liste de palindromes 
    inférieurs ou égaux à N"""
    L =[]
    for n in range(N+1):
        if palindrome(str(n)) == True:
            L.append(n)
    return(L)

#print(pat_nombre(100))
#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 
#   33, 44, 55, 66, 77, 88, 99]
\end{python}
\end{corrige}


\end{multicols}


\addcontentsline{toc}{subsection}{Exercice 12 -- Corrigé}
\subsection*{Exercice 12 -- Corrigé}
\textit{D'après Lucie Bathie, PT$\star$ 2015--2016.}

\begin{multicols}{2}

\begin{corrige}
$\quad$
\begin{python}
#1.
v = [1,2,0,4,7,0,0,0,0]

def creux(v):
    """renvoie True si le vecteur est creux, 
    false sinon"""
    nombre_zeros = 0
    for k in range(len(v)):
        if v[k] == 0:
            nombre_zeros +=1
    return(nombre_zeros >= (len(v)-nombre_zeros)/2)

#print(creux(v))
#True
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
#2.
def coder(v):
    code = [len(v)]
    indices = []
    valeurs = []
    for k in range(len(v)):
        if v[k] != 0:
            indices.append(k)
            valeurs.append(v[k])
    code.append(valeurs)
    code.append(indices)
    return(code)
    
#print(coder(v))
#[9, [1, 2, 4, 7], [0, 1, 3, 4]]    
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
#3. 
def decoder(code):
    """permet de décoder un codage creux"""
    v=[0]*code[0]
    for k in range(len(code[2])):
        v[code[2][k]] = code[1][k]
    return(v)

code1=[9,[1,2,4,7],[0,1,3,4]]
##print(decoder(code1))
##[1,
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
#4.
def simul(C,a):
    """C  codage de v
renvoie le codage de av"""
    v = decoder (C)
    for k in range(len(v)):
        v[k] = a*v[k]
    return(coder(v))

#print(simul(code1,2))
#[9, [2, 4, 8, 14], [0, 1, 3, 4]]
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
#5
def coefficient(j,C):
    vecteur = decoder(C)
    return(vecteur[j])

#print(coefficient(1,code1))
#2
\end{python}
\end{corrige}

\end{multicols}
\newpage
\section{Correction -- Adaptés des exercices de F. Butin}
\addcontentsline{toc}{subsection}{Exercice 1 -- Corrigé}
\subsection*{Exercice 1 -- Corrigé}
\begin{corrige}
$\quad$
\begin{python}
# Question 1 
# ==========
def affiche_poly(P):
    """
    Affiche un polynome sous la forme 
    a0*X^0+a1*X^1+a2*X^2+...
    Entrée : 
     * P(lst) : liste des coefficients du polynome 
       [a0,a1,...,an]
    Sortie : 
     * Rien. Affichage
    """
    ch=""
    for i in range(len(P)):
        signe="+"
        if P[i]<0 :
            signe="-"
        
        ch=ch+signe+str(abs(P[i]))+"*X^"+str(i)
    print(ch)
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
# ==========
def degre_poly(P):
    """
    Calcule le degré d'un polynome.
    On se base uniquement sur la taille de la liste 
    à cause de la comparaison à zero
    Entrée : 
     * P(lst) : liste des coefficients du polynome 
       [a0,a1,...,an]
    Sortie : 
     * deg(int) : dege du polynome
    """
    return len(P)-1
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 3
# ==========
def add_poly(P1,P2):
    """
    Calcule la somme de deux polynomes.
    Attention à bien faire une copie...
    Entrée : 
     * P1, P2(lst) : liste des coefficients du 
        polynome [a0,a1,...,an]
    Sortie : 
     * P(lst) : liste des coefficients du 
        polynome [a0+b0,a1+b1,...,an+bn]
    """
    # On cherche le polynome le plus grand
    if degre_poly(P1)>=degre_poly(P2):
        P=P1.copy()
        for i in range(len(P2)):
            P[i]=P[i]+P2[i]
    else :
        P=P2.copy()
        for i in range(len(P1)):
            P[i]=P[i]+P1[i]
    return P
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
def mul_poly(P1,P2):
    """
    Calcule la multiplication de deux polynomes.
    Entrée : 
     * P1, P2(lst) : liste des coefficients du 
       polynome [a0,a1,...,an]
    Sortie : 
     * P(lst) : produits des polynomes
    """
    P=[0]*(degre_poly(P1)+degre_poly(P2)+1)
    for i in range(len(P1)):
        for j in range(len(P2)):
           P[i+j] = P[i+j]+ P1[i]*P2[j]
    return P
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
def mul_poly(P1,P2):
    """
    Calcule la multiplication de deux polynomes.
    Entrée : 
     * P1, P2(lst) : liste des coefficients du 
        polynome [a0,a1,...,an]
    Sortie : 
     * P(lst) : produits des polynomes
    """
    P=[0]*(degre_poly(P1)+degre_poly(P2)+1)
    for i in range(len(P1)):
        for j in range(len(P2)):
           P[i+j] = P[i+j]+ P1[i]*P2[j]
    return P
\end{python}
\end{corrige}



\begin{corrige}
$\quad$
\begin{python}
# Question 4
# ==========
def prsc_poly(P1,P2):
    """
    Calcule le produit scalaire de deux polynomes.
    Attention à bien faire une copie...
    Entrée : 
     * P1, P2(lst) : liste des coefficients du 
       polynome [a0,a1,...,an]
    Sortie : 
     * P(flt) :produit des coefficients des 
        polynomes a0*b0+a1*b1+...
    """
     # On cherche le polynome le plus grand
    if degre_poly(P1)>=degre_poly(P2):
        P=P1.copy()
        for i in range(len(P2)):
            P[i]=P[i]*P2[i]
    else :
        P=P2.copy()
        for i in range(len(P1)):
            P[i]=P[i]*P1[i]
    return sum(P)
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 5
# ==========
def deriv_poly(P):
    """
    Calcule la dérivée d'un polynome.
    Entrée : 
     * P(lst) : liste des coefficients du 
        polynome [a0,a1,...,an]
    Sortie : 
     * coefficients du polynome dérivé
    """
    return [P[i]*i for i in range(1,len(P))]
\end{python}
\end{corrige}




%\columnbreak
\addcontentsline{toc}{subsection}{Exercice 3 -- Corrigé}
\subsection*{Exercice 3 -- Corrigé}

\begin{corrige}
$\quad$
\begin{python}
import numpy as np
import matplotlib.pyplot as plt
# Question 1 
# ==========
def f_sigma(n,t):
    return (np.cos(n*t))**3-(np.sin(n*t))**3

x = np.linspace(0,10,1000)
y = f_sigma(1,x)

for i in range(4):
    x = np.linspace(0,10,1000)
    y = f_sigma(i,x)
    plt.plot(y*np.cos(x),y*np.sin(x),label=str(i))

plt.legend()
plt.axis("equal")    
plt.show()
\end{python}
\end{corrige}
\begin{center}
\includegraphics[width=.4\linewidth]{images/exo_FB_03}
\end{center}

%\columnbreak
\addcontentsline{toc}{subsection}{Exercice 7 -- Corrigé}
\subsection*{Exercice 7 -- Corrigé}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
# ==========
R=4
r=R/4
m = 1-R/r
theta = np.linspace(0,2*np.pi,1000)
x=(R-r)*np.cos(theta)+r*np.cos(m*theta)
y=(R-r)*np.sin(theta)+r*np.sin(m*theta)
plt.plot(x,y,label="R=4, r=1, m=-3")
\end{python}
\end{corrige}

\begin{center}
\includegraphics[width=.4\linewidth]{images/exo_FB_07_1}
\end{center}

\begin{corrige}
$\quad$
\begin{python}
# Question 3
# ==========
for p in [1, 5, 10, 100]:
    r=R/p
    m = 1-R/r
    theta = np.linspace(0,2*np.pi,1000)
    x=(R-r)*np.cos(theta)+r*np.cos(m*theta)
    y=(R-r)*np.sin(theta)+r*np.sin(m*theta)
    titre = "R="+str(R)+", r = "+str(r)+ ",m="+str(m)
    plt.plot(x,y,label=titre)

x=R*np.cos(m*theta)
y=R*np.sin(m*theta)
#plt.plot(x,y)

plt.axis("equal")
#plt.legend()
plt.show()
\end{python}
\end{corrige}

\begin{center}
\includegraphics[width=.4\linewidth]{images/exo_FB_07_2}
\end{center}




%\columnbreak 
\addcontentsline{toc}{subsection}{Exercice 9 -- Corrigé}
\subsection*{Exercice 9 -- Corrigé}

\begin{corrige}
$\quad$
\begin{python}
# EXERCICE 9
import numpy as np
import matplotlib.pyplot as plt
import turtle

# Question 1 
#============
turtle.hideturtle()
turtle.goto(100,0)
turtle.speed(1)
tortue = turtle.Pen()

t = np.linspace(0,2*np.pi,1000)
x=100*np.cos(t)
y=100*np.sin(t)
for i in range(len(x)):
    tortue.goto(x[i],y[i])
\end{python}
\end{corrige}


\begin{center}
\begin{tabular}{cc}
\includegraphics[width=.3\linewidth]{images/exo_FB_09_01}&
\includegraphics[width=.3\linewidth]{images/exo_FB_09_02}
\end{tabular}
\end{center}



\begin{corrige}
$\quad$
\begin{python}
# Question 2 
# ==========
def peano(n) : 
    if n==1 :
        tortue.forward(10)
    else : 
        peano(n-1)
        tortue.left(90)
        peano(n-1)
        tortue.left(-90)
        peano(n-1)
        tortue.left(-90)
        peano(n-1)
        tortue.left(-90)
        peano(n-1)
        tortue.left(90)
        peano(n-1)
        tortue.left(90)
        peano(n-1)
        tortue.left(90)
        peano(n-1)
        tortue.left(-90)
        peano(n-1)
        
peano(4)
turtle.hideturtle()
\end{python}
\end{corrige}


%\columnbreak 

\addcontentsline{toc}{subsection}{Exercice 10 -- Corrigé}
\subsection*{Exercice 10 -- Corrigé}


\begin{corrige}
$\quad$
\begin{python}
# EXERCICE 10 FB
import numpy as np
import matplotlib.pyplot as plt
import turtle
__author__ = "Frederic Butin"

# Question 1 
# ==========
turtle.hideturtle()
turtle.speed(10);
tortue = turtle.Pen()

def koch (n):
    if n==1 : 
        tortue.forward(3)
    else : 
        koch(n-1);
        tortue.left(60)
        koch(n-1);
        tortue.left(-120)
        koch(n-1);
        tortue.left(60)
        koch(n-1)
        

def flocon(n):
    tortue.clear()
    koch(n)
    tortue.left(-120)
    koch(n)
    tortue.left(-120)
    koch(n)
    tortue.hideturtle()

flocon(5)
\end{python}
\end{corrige}



\addcontentsline{toc}{subsection}{Exercice 11 -- Corrigé}
\subsection*{Exercice 11 -- Corrigé}

\begin{corrige}
$\quad$
\begin{python}
# EXERCICE 11
# Question 1 
# ==========
import matplotlib.pyplot as plt
import math

I_th = 8*math.log(2)-3
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 2
# ==========
def fonc(x):
    return math.log(x)
\end{python}
\end{corrige}


\begin{corrige}
$\quad$
\begin{python}    
def calc_int_trap(a,b,n):
    res = 0
    pas = (b-a)/n
    x = a+pas
    i=1
    while i<n:
        res = res + fonc(x)
        x = x + pas
        i=i+1
    res = pas*(res+(fonc(a)+fonc(b))/2)
    return res
\end{python}
\end{corrige}


\begin{corrige}
$\quad$
\begin{python}    
def calc_int_rect_g(a,b,n):
    res = 0
    pas = (b-a)/n
    x = a
    i=0
    while i<n:
        res = res + fonc(x)
        x = x + pas
        i=i+1
    return res*pas
\end{python}
\end{corrige}


\begin{corrige}
$\quad$
\begin{python}
N = [10,20,40,100,200, 400, 500, 600, 700, 800, 
        900, 1000, 5000, 10000, 20000, 100000]

calc_int_trap(1,4,10)
err_trap = [abs(I_th-calc_int_trap(1,4,n)) 
                                           for n in N]
err_rect = [abs(I_th-calc_int_rect_g(1,4,n)) 
                                           for n in N]

plt.loglog(N,err_trap,label = "Erreur trapèze")
plt.loglog(N,err_rect,label = "Erreur rectangle")
plt.legend()
plt.grid()
plt.show()

\end{python}
\end{corrige}

\begin{center}
\includegraphics[width=.4\linewidth]{images/exo_FB_11}
\end{center}


%\columnbreak

\addcontentsline{toc}{subsection}{Exercice 12 -- Corrigé}
\subsection*{Exercice 12 -- Corrigé}

\begin{corrige}
\textcolor{red}{A refaire ?}


On pose : 
$$\left\{
\begin{array}{l}
y_1(t) = x(t) \\
y_2(t) = x'(t)
\end{array}
\right.
$$

En utilisant le schéma d'Euler explicite, on a :
$$\left\{
\begin{array}{l}
y'_1(k)=\dfrac{y_1(k+1)-y_1(k)}{h} \\
y'_2(k)=\dfrac{y_2(k+1)-y_2(k)}{h}
\end{array}
\right.
$$

On a donc : 
$$\left\{
\begin{array}{l}
y'_1(t)=y_2(t) \\
y'_2(t)+10y_2(t) - y_1(t) = \sin \left(nt\right)
\end{array}
\right.
$$

En discrétisant l'équation on a donc : 
$$\left\{
\begin{array}{l}
y_2(k) =\dfrac{y_1(k+1)-y_1(k)}{h} \\
\dfrac{y_2(k+1)-y_2(k)}{h} +10y_2(k) - y_1(k) = \sin \left(nk\right)
\end{array}
\right.
$$

$$\Leftrightarrow
\left\{
\begin{array}{l}
y_1(k+1) = hy_2(k)+y_1(k) \\
y_2(k+1)  = h \left(  \sin \left(nk\right)+ y_1(k)-10y_2(k) \right)+y_2(k)
\end{array}
\right.
$$

\end{corrige}

\begin{corrige}
Mise en forme matricielle du problème : 
On pose : 
$$
X = \left[
\begin{array}{c}
x(t) \\
x'(t)
\end{array}
\right]
\Rightarrow
X' = \left[
\begin{array}{c}
x'(t) \\
x''(t)
\end{array}
\right]
$$

On a alors : $$
\left[
\begin{array}{c}
x'(t) \\
x''(t)
\end{array}
\right]
=
 \left[
\begin{array}{cc}
0 & 1 \\
 1 &- 10\\
\end{array}
\right]
\cdot
 \left[
\begin{array}{c}
x(t) \\
x'(t)
\end{array}
\right]
+
\left[
\begin{array}{c}
0 \\
\sin (nt)
\end{array}
\right]
$$

Le système peut donc se mettre sous la forme : 
$$
X'(t) = AX(t)+ B(t)
$$

En appliquant un schéma d'Euler explicite, on a donc :
$$
X'(t) \simeq \dfrac{X_{k+1}-X_{k}}{h}
$$ 

D'où :

$$
\dfrac{X_{k+1}-X_{k}}{h} = AX_k + B_k 
\Leftrightarrow 
X_{k+1} = (hA +1) X_k + hB_k
$$
\end{corrige}

%%\columnbreak


\begin{corrige}
Mise en forme du problème de Cauchy : 

En réutilisant la mise en forme matricielle précédente, on peut donc définit la fonction $f$ telle que : 
$$
f(X,t) \mapsto  AX(t) + B(t)
$$


\begin{python}
import matplotlib.pyplot as plt
import numpy as np
import scipy.integrate as spi
N=10000

def fonction_f(X,t,n):
   return [X[1],X[0]-10*X[1]+np.sin(n*t)]

les_t=np.linspace(0,7,N)
for i in range(0,11):
    res = spi.odeint(fonction_f,[0,1],les_t,(i,))
    plt.plot(les_t,res[:,0])
plt.show()
\end{python}
\end{corrige}

\begin{center}
\includegraphics[width=.4\linewidth]{images/exo_FB_12}
\end{center}


%\columnbreak
\addcontentsline{toc}{subsection}{Exercice 13 -- Corrigé en cours}
\subsection*{Exercice 13 -- Corrigé}

\begin{corrige}
On pose : 
$$
X_i =\begin{bmatrix}
F_{i+1} \\
F_{i}
\end{bmatrix} 
$$

Le problème peut être mis sous la forme matricielle suivante : 
$$
X_{i+1} =
\begin{bmatrix}
F_{i+2} \\
F_{i+1}
\end{bmatrix} 
=
\begin{bmatrix}
1 & 1  \\
1 & 0 
\end{bmatrix} 
\begin{bmatrix}
F_{i+1} \\
F_{i}
\end{bmatrix} 
\Leftrightarrow X_{i+1} = M X_{i}
$$

On  peut donc écrire que  :
$$
X_{i+1} =
\begin{bmatrix}
1 & 1  \\
1 & 0 
\end{bmatrix} 
\begin{bmatrix}
F_{i+1} \\
F_{i}
\end{bmatrix} 
=
\begin{bmatrix}
1 & 1  \\
1 & 0 
\end{bmatrix} 
\begin{bmatrix}
1 & 1  \\
1 & 0 
\end{bmatrix} 
\begin{bmatrix}
F_{i} \\
F_{i-1}
\end{bmatrix} 
$$
 On a donc :
 $$
X_{n} = M^n X_{0}
$$

\end{corrige}



\addcontentsline{toc}{subsection}{Exercice 19}
\subsection*{Exercice 19}

\begin{corrige}
$\quad$
\begin{python}
# EXERCICE 19
# Question 1 
# ==========
import numpy as np
import scipy.integrate as sci
import matplotlib.pyplot as plt

def fonction_PP(X,t,a,b,c,d):
    return [a*X[0]-b*X[0]*X[1],-c*X[1]+d*X[0]*X[1]]

def fonction_PP2(X,t):
    a,b,c,d = 1,1,1,1
    return [a*X[0]-b*X[0]*X[1],-c*X[1]+d*X[0]*X[1]]
\end{python}
\end{corrige}


\begin{corrige}
$\quad$
\begin{python}
# Question 2 
# ==========
# Conditions initiale : 
X0=[1,2]
t = np.linspace(0,20,1000)
res = sci.odeint(fonction_PP2,X0,t)
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 3 
# ==========
plt.figure()
plt.plot(t,res[:,0])
plt.plot(t,res[:,1])
\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}
# Question 4 
# ==========
plt.figure()
plt.plot(res[:,0],res[:,1])
plt.axis("equal")
\end{python}
\end{corrige}



\begin{center}
\includegraphics[width=.45\linewidth]{exo_fb_19_01.png}
\includegraphics[width=.45\linewidth]{exo_fb_19_02.png}
\end{center}
%\end{multicols}

%\includepdf[pages={1-4},]{images/MementoPythonScilab}
\end{document}




%\columnbreak
\addcontentsline{toc}{subsection}{Exercice 4}
\subsection*{Exercice 4}

\begin{corrige}
$\quad$
\begin{python}

\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}

\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}

\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}

\end{python}
\end{corrige}

\begin{corrige}
$\quad$
\begin{python}

\end{python}
\end{corrige}




