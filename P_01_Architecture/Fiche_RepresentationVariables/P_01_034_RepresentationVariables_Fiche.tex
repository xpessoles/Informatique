\documentclass[10pt,fleqn]{article} % Default font size and left-justified equations
\usepackage[%
    pdftitle={Informatique : Principe de la représentation des variables en mémoire},
    pdfauthor={Xavier Pessoles}]{hyperref}

\input{style/new_style}
\input{style/macros_SII}

\fichetrue
%\fichefalse

%\proftrue
\proffalse

%\tdtrue
\tdfalse

%\courstrue
\coursfalse

% -------------------------------------
% Déclaration des titres
% -------------------------------------

\def\discipline{Informatique}
\def\xxtete{Informatique}

\def\classe{Fiche PT}
\def\xxnumpartie{Partie 1}
\def\xxpartie{Architecture matérielle \& logicielle}

\def\xxnumchapitre{Chapitres 3 et 4}
\def\xxchapitre{\hspace{.12cm} Représentation des variables dans la mémoire}

\def\xxposongletx{2}
\def\xxposonglettext{1.45}
\def\xxposonglety{19}%16

\def\xxonglet{Part. 1 -- Ch. 3 et 4}

\def\xxactivite{Fiche}
\def\xxauteur{\textsl{Xavier Pessoles}}

\def\xxcompetences{%
\textsl{%
%\textbf{Savoirs et compétences :}\\
%\noindent \textbf{Résoudre :} à partir des modèles retenus :
%\begin{itemize}[label=\ding{112},font=\color{ocre}] 
%\item choisir une méthode de résolution analytique, graphique, numérique;
%\item mettre en \oe{}uvre une méthode de résolution.
%\end{itemize}
%\begin{itemize}[label=\ding{112},font=\color{ocre}] 
%\item \textit{Rés -- C1.1 :} Loi entrée sortie géométrique et cinématique -- Fermeture géométrique.
%\end{itemize}
%
%\noindent \textit{Mod2 -- C4.1 :} Représentation par schéma bloc.
}}

\def\xxfigures{
%incgraphics[width=.8\textwidth]{}%images/prot_01}
}%figues de la page de garde

\def\xxpied{%
Partie 1 -- Architecture matérielle \& logicielle \\
Ch. 3 et 4 : Représentation des variables dans la mémoire -- \xxactivite%
}

\setcounter{secnumdepth}{5}
%---------------------------------------------------------------------------


\begin{document}
%\chapterimage{png/Fond_Cin}
\input{style/new_pagegarde}
\vspace{2cm}
\pagestyle{fancy}
\thispagestyle{plain}

\subsection*{Représentation des nombres entiers}
\begin{defi}\textbf{Écriture d'un nombre dans une base}

Dans un système de numération en base $B$, un nombre noté $N_B$ peut s'écrire sous la forme : $N_B = \sum\limits_{k=0}^{n} a_k \cdot B^k $
s'écrit symboliquement sous la forme : 
$
N_B = \underbrace{\left(a_n a_{n-1} \cdot \cdot \cdot a_2 a_1 a_0\right)_B}_{n+1 \text{ chiffres}}
$
On note : 
\begin{itemize}
\item $B$ : la base ou nombre de chiffres différents qu'utilise le système de numération;
\item $a_k$ : chiffre de rang $k$;
\item $B^k$ la pondération associée à $a_k$.
\end{itemize}

\end{defi}

\subsection*{Représentation des nombres entiers relatifs}

\begin{methode} 
Pour représenter l’opposé d’un nombre positif par son complément à deux, on inverse les bits 0 et 1 et on ajoute 1 au mot binaire obtenu.
\end{methode}

\subsection*{Représentation des nombres réels}
\begin{methode}
\textbf{Conversion d'une partie fractionnaire en binaire}

\begin{enumerate}
\item On multiplie la partie fractionnaire par 2. 
\item La partie entière obtenue représente le poids binaire (limité aux seules valeurs 0 ou 1). 
\item La partie fractionnaire restante est à nouveau multipliée par 2.
\item On procède ainsi de suite jusqu’à ce qu’il n’y ait plus de partie fractionnaire ou que le nombre de bits obtenus correspond à la taille du mot mémoire dans lequel on stocke cette partie.
\end{enumerate}
\end{methode}


Pour représenter des réels, nombres pouvant être positifs, nuls, négatifs et non entiers, on utilise la représentation en virgule flottante (\textit{float} en anglais) qui fait correspondre au nombre 3 informations :

$$
-243,25_{(10)} = \underbrace{-}_{1}0,\underbrace{24325}_{2}\cdot10^{\underbrace{3}_{3}}
$$
On appelle alors : 
\begin{enumerate}
\item le signe (positif ou négatif);
\item la mantisse (nombre de chiffres significatifs);
\item l'exposant : puissance à laquelle la base est élevée. 
\end{enumerate}

Sous cette forme normalisée, il suffit de mémoriser le signe, l’exposant et la mantisse pour avoir une représentation du nombre en base 10. Il n’est pas utile de mémoriser le 0 avant la virgule puisque tous les nombres vont commencer par 0. En faisant varier l’exposant, on fait « flotter » la virgule décimale.

C’est cette méthode que l’on va adapter pour coder les réels en binaire naturel. Il faut au préalable les écrire sous la forme (norme IEEE 754 – Institute of Electrical and Electronics Engineers) :

\begin{center}
signe 1, mantisse x $2^{\text{exposant}}$
\end{center}

Le mot binaire obtenu sera la juxtaposition de 3 parties :

\begin{center}
\includegraphics[width=.7\textwidth]{images/reel_1}
\end{center}


\begin{minipage}[c]{.4\linewidth}
Le tableau décrit la répartition des bits selon le type de précision : la taille de la mantisse ($m$ bits) donne la précision mais suivant la valeur de l'exposant, la précision sera totalement différente. 


\end{minipage}\hfill
\begin{minipage}[c]{.59\linewidth}
\begin{center}
\begin{tabular}{| l |c|c|c|}
\hline

& Signe & Exposant & Mantisse \\ \hline
 Simple précision -- 32 bits & 1 & 8 & 23 \\ \hline
 Double précision -- 64 bits & 1 & 11 & 52 \\ \hline
 Précision étendue -- 80 bits & 1 & 15 & 64 \\ \hline
\end{tabular}
\end{center}
\end{minipage}


\vspace{.25cm}

Ainsi : 
\begin{itemize}
\item erreur relative : $2^{-m}$ (poids du dernier bit)
\item erreur absolue : erreur relative * $2^{\text{exposant}}$
\end{itemize}

Simple précision :  	$2^{- 23} = 1,192 … * 10^{- 7}$ 
Double précision :  	$2^{- 52} = 2,220 … * 10^{- 16}$


\subsection*{Procédure de conversion de réel en binaire (hexadécimale) }

\begin{methode}
\begin{enumerate}
\item Convertir en binaire les partie entière et fractionnaire du nombre sans tenir compte du signe.
\item Décaler la virgule vers la gauche pour le mettre sous la forme normalisée (IEEE 754).
\item Codage du nombre réel avec les conventions suivantes : 
\begin{itemize}
\item signe = 1 : Nombre négatif 	(Signe = 0 : Nombre positif);
\item le chiffre 1 avant la virgule étant invariant pour la forme normalisée, il n’est pas codé;
\item on utilise un exposant décalé au lieu de l’exposant simple (complément sur octet). Ainsi, on ajoute à l’exposant simple la valeur 127 en simple précision et 1023 en double précision (c’est à dire $2^{n-1}-1$ où $n$ est le nombre de bits de l’exposant);
\item la mantisse est complétée à droite avec des zéros.
\end{itemize}
\end{enumerate}
\end{methode}

\subsection*{Représentation chaînes de caractères}
Les fichiers texte stockés sur un périphérique de stockage sont encodés avec un encodage particulier (ANSI, UTF-8, ASCII...). L'encodage est une table de correspondance entre une séquence de bits et un caractère (visible -- une lettre -- ou non -- une tabulation--).

Par exemple, l'ASCII est un encodage fréquemment utilisé où les caractères sont codés sur 7 bits et permet donc d'encoder 127 caractères. Cependant, les informations étant très souvent regroupées par octets, un caractère ASCII occupe donc 8 bits. 
\begin{center}
\includegraphics[width=\linewidth]{images/ascii}
\end{center}
\end{document}


