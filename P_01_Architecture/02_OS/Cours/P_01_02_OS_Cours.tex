\documentclass[10pt,fleqn]{article} % Default font size and left-justified equations
\usepackage[%
    pdftitle={Informatique : Systèmes d'exploitation et environnement de développement},
    pdfauthor={Xavier Pessoles}]{hyperref}

\input{style/new_style}
\input{style/macros_SII}

%\fichetrue
\fichefalse

%\proftrue
\proffalse

%\tdtrue
\tdfalse

\courstrue
%\coursfalse

% -------------------------------------
% Déclaration des titres
% -------------------------------------

\def\discipline{Informatique}
\def\xxtete{Informatique}

\def\classe{PTSI}
\def\xxnumpartie{Partie 1}
\def\xxpartie{Architecture matérielle et logicielle}

\def\xxnumchapitre{Chapitre 2}
\def\xxchapitre{\hspace{.12cm} Systèmes d'exploitation et environnement de développement}

\def\xxposongletx{2}
\def\xxposonglettext{1.45}
\def\xxposonglety{25}%22
\def\xxonglet{Part. 1 -- Ch. 2}

\def\xxactivite{Cours}
\def\xxauteur{\textsl{Xavier Pessoles}}

\def\xxcompetences{%
\textsl{%
\textbf{Savoirs et compétences :}
\begin{itemize}[label=\ding{112},font=\color{ocre}] 
\item Le but de ce cours est d'avoir un aperçu sur les systèmes d'exploitation disponibles sur les PC.
\end{itemize}
}}

\def\xxfigures{
\begin{center}
\includegraphics[height=.6cm]{images/w8}
\end{center}
\begin{center}
\includegraphics[height=.8cm]{images/ios7}
\end{center}
\begin{center}
\includegraphics[height=1.4cm]{images/osx}
\end{center}
\begin{center}
\includegraphics[height=2cm]{images/gentoo}
\end{center}
\begin{center}
\includegraphics[height=2cm]{images/android}
\end{center}
\begin{center}
\includegraphics[height=2cm]{images/debian}
\end{center}
}%figues de la page de garde

\def\xxpied{%
Partie 1 -- Architecture matérielle et logicielle \\
Ch 2 : OS et Environnement de développement -- \xxactivite%
}

%---------------------------------------------------------------------------


\begin{document}
\chapterimage{png/Fond_Arch}
\input{style/new_pagegarde}



\section{Notion de système d'exploitation}

\subsection{Introduction}

Le système d'exploitation (\textit{Operating System -- OS}) est un programme chargé en mémoire vive dès le démarrage de l'ordinateur et qui reste en mémoire jusqu'à son extinction. 

Pour les \textbf{ordinateurs monoprocesseur} ce programme a pour but de donner l’illusion que l’ordinateur est multitâche lorsque plusieurs applications sont lancées en même temps. Pour cela, il stocke en mémoire les différentes applications que l’on veut exécuter. Il lance l’exécution d’une première application. Dès qu’il se produit une entrée-sortie ou, à défaut, lorsqu’un certain temps est écoulé (de l’ordre de la centaine de millisecondes), le noyau du système d’exploitation reprend la main et lance l’exécution d’une autre application. En pratique, le temps d’exécution d’une tâche dépasse rarement la dizaine de millisecondes.

Pour les \textbf{ordinateurs multiprocesseurs} ce programme a pour but de gérer les accés de chacun des processeurs à la mémoire et aux périphériques, ce qui permet
effectivement que l’ordinateur exécute plusieurs instructions à la fois. Les fabricants
de processeurs proposent même maintenant des processeurs qui contiennent en fait plusieurs
c\oe{}urs (dualcore, quadricore), c’est-à-dire que plusieurs processeurs (unité arithmétique
et logique et unité de contrôle) ont été regroupés sur un seul processeur.

Par ailleurs l'OS permet de manière générale de gérer l'organisation des données sur le disque dur ainsi que leur droit d'accès. Il gère aussi les différentes ressources et sert de garde-fou en cas de tentative de mauvaise utilisation des ressources de l'ordinateur.

Pour finir, l'OS permet à un ou plusieurs utilisateurs de s'identifier leur permettant ainsi d'utiliser un seul ordinateur sans nécessairement partager les données et les programmes. 


Il existe essentiellement deux grandes familles de systèmes d’exploitation. 

\begin{minipage}[c]{.7\linewidth}
Les systèmes d’exploitation de la famille Microsoft-Windows qui sont en situation de quasi-monopole sur les \textbf{ordinateurs personnels} (ils en équipent près de 90\%)

\end{minipage} \hfill
\begin{minipage}[c]{.25\linewidth}
\begin{center}
\includegraphics[width=.9\textwidth]{images/ms}
\end{center}
\end{minipage} 

\begin{minipage}[c]{.7\linewidth}
Les systèmes d’exploitation issus d’Unix (Mac OS X, iOS, GNU/Linux, Android, FreeBSD, NetBSD). Dans tous les domaines, sauf celui des ordinateurs personnels, les systèmes issus d’Unix sont majoritaires.  Linux s’est imposé comme un système universel puisqu’il équipe aussi bien les téléphones portables (Android) que les boîtiers prêtés par les fournisseurs d’accès à Internet, les ordinateurs personnels (Ubuntu/GNU Linux), les serveurs web et les supercalculateurs (plus de 90\% des calculateurs du TOP 500).

\end{minipage} \hfill
\begin{minipage}[c]{.25\linewidth}
\begin{center}
\includegraphics[width=.9\textwidth]{images/genlin}
\end{center}
\end{minipage} 

Il est possible d'installer plusieurs systèmes d'exploitation sur une même machine: double boot. Il est aussi possible d'émuler un système d'exploitation dans un autre système d'exploitation.

\subsection{Petit historique}

\begin{center}
\begin{tabular}{m{1cm}m{10cm}m{6cm}}
\textbf{1969} & 
Origines de UNIX. & 
\begin{center}
%\includegraphics[width=7cm]{images/dos.jpg}
\end{center}
\end{tabular}

\begin{tabular}{m{1cm}m{10cm}m{6cm}}
\textbf{1984} & 
Sortie du premier OS de Microsoft : MS-DOS. & 
\begin{center}
\includegraphics[width=6cm]{images/dos.jpg}
\end{center}
\end{tabular}

\begin{tabular}{m{1cm}m{10cm}m{6cm}}
\textbf{1984} & 
Richard Stallman\footnotemark[1] crée le projet GNU dans le but de développer un OS basé sur Unix, mais libre. & 
\begin{center}
\includegraphics[width=6cm]{images/richard.png}
\end{center}
\end{tabular}

\begin{tabular}{m{1cm}m{10cm}m{6cm}}
\textbf{1991} & 

Linus Torvalds\footnotemark[2] entreprend de créer sur son temps libre son propre système d'exploitation. Ce système a pris le nom de Linux (contraction de Linus et Unix). Ce projet est complémentaire du projet GNU : tandis que Richard Stallman créait les programmes de base (programme de copie de fichier, de suppression de fichier, éditeur de texte), Linus s'est lancé dans la création du « cœur » d'un système d'exploitation : le noyau.
 & 
\begin{center}
\includegraphics[width=3cm]{images/linux.png}
\end{center}
\end{tabular}

\end{center}

\footnotetext[1]{Chercheur en intelligence artificielle au MIT.}
\footnotetext[2]{\'Etudiant de l'Université de Helsinki (Finlande).}


%
%
%\begin{figure}[h]
%\begin{minipage}[c]{.49\linewidth}
%\begin{center}
%\includegraphics[width=.99\textwidth]{images/origine.png}
%\caption{Origine des systèmes d'exploitation}
%\label{}
%\label{essai1}
%\end{center}
%\end{minipage} \hfill
%\begin{minipage}[c]{.49\linewidth}
%Le projet GNU (programmes libres) et Linux (noyau d'OS) ont fusionné pour créer GNU/Linux.
%Théoriquement, on doit donc parler de GNU/Linux. C'est toutefois un peu difficile à écrire et prononcer, et par abus de langage, on dit souvent juste « Linux ». 
%\newline\newline
%Mac OS X est lui aussi basé sur Unix. En revanche, MS-DOS et Windows sont complètement à part.
%\end{minipage}
%\end{figure}
%




\begin{rem}
Un programme libre est un programme dont on peut avoir le code source, c'est-à-dire la « recette de fabrication ». Au contraire, Windows est un OS propriétaire dont le code source est conservé par Microsoft. On ne peut donc pas le modifier ou regarder comment il fonctionne à l'intérieur.

Un programme libre est donc la plupart du temps un programme gratuit. Mais c'est aussi un programme qu'on a le droit de copier, modifier, redistribuer. On dit aussi souvent que le programme est « Open Source » car son code source est ouvert ; tout le monde peut le voir.

Il existe quelques légères différences entre un programme « Open Source » et un programme « libre », mais nous n'entrerons pas dans les détails ici.
\end{rem}



\begin{rem}
\textit{Les distribution GNU/Linux}

Une distribution est un ensemble de logiciels articulés autour d'un noyau. GNU/Linux comprend un grand nombre de distributions. Elles diffèrent par la méthode d'installation, la gestion des programmes, la méthode pour installer des programmes. Attention, le terme distribution est différent du terme logiciel. De manière générale, un logiciel libre est installable sur n'importe quelle distribution. Dans le cas le plus défavorable, il sera nécessaire de \textbf{compiler} le logiciel.


%
%Pour simplifier la vie des utilisateurs et leur permettre de faire un choix, différentes distributions de Linux ont été créées. C'est un concept qui n'existe pas vraiment sous Windows. C'est un peu comme la différence entre Windows 7 Familial et Windows 7 Professionnel, mais cela va bien plus loin que ça.
%
%Voici ce qui peut différer d'une distribution à l'autre :
%\begin{itemize}
%\item l'installation : elle peut être très simplifiée comme très compliquée ;
%\item la gestion de l'installation des programmes. Si elle est bien faite et centralisée, elle peut rendre l'installation de nouveaux logiciels plus simple que sous Windows, comme nous le verrons plus loin !
%\item les programmes préinstallés sur l'ordinateur (Windows est par exemple livré avec Internet Explorer et Windows Media Player).
%\end{itemize}
%En fait, une distribution est en quelque sorte l'emballage de Linux. Le cœur, lui, reste le même sur toutes les distributions.
%
%Il existe un grand nombre de distributions Linux différentes:
%\begin{itemize}
%\item Slackware : une des plus anciennes distributions de Linux. Elle existe encore aujourd'hui !
%\item Mandriva : éditée par une entreprise française, elle se veut simple d'utilisation ;
%\item Red Hat : éditée par une entreprise américaine, cette distribution est célèbre et très répandue, notamment sur les serveurs ;
%\item SuSE : éditée par l'entreprise Novell ;
%\item Debian : la seule distribution qui soit gérée par des développeurs indépendants plutôt que par une entreprise. C'est une des distributions les plus populaires.
%\end{itemize}
%
%
%
%
%\begin{figure}[h]
%
%\begin{minipage}[c]{.49\linewidth}
%Prenons l'exemple de la distribution Debian.
%Les autres distributions sont gérées par des entreprises, ce qui ne les empêche pas d'être « Open Source » et gratuites, même si nous pouvons également les acheter pour avoir droit à une assistance (hotline…). Debian est donc la seule distribution éditée par des particuliers bénévoles à travers le monde. 
%Debian a tellement de succès que de nombreuses distributions sont basées sur Debian, ce sont donc des… distributions de distributions. 
%Ubuntu est une des distributions les plus populaires à l'heure actuelle.
%\end{minipage} \hfill
%\begin{minipage}[c]{.49\linewidth}

%\end{minipage}

%\begin{center}
%\includegraphics[width=.6\textwidth]{images/archilin.png}
%
%\textit{Différentes distributions GNU/Linux}
%
%\end{center}

\end{rem}




\subsection{À quoi ressemble Linux ?}


%\subsubsection{En mode console}

%\begin{figure}[h]
\begin{minipage}[c]{.49\linewidth}
Une des réticences à l'utilisation d'une distribution GNU/Linux est le mode console. 

Ce mode de fonctionnement peut paraître effrayant et peu accessible pour un utilisateur novice. Cependant, le mode console permet de faire une grande partie des opérations faisable avec la souris ce qui, avec l'expérience, améliore l'efficacité de l'utilisateur.
\end{minipage} \hfill
\begin{minipage}[c]{.49\linewidth}
\begin{center}
\includegraphics[width=.9\textwidth]{images/commande.jpg}
\end{center}
\end{minipage}
%
%\begin{warn}
%\textsc{ATTENTION}
%
%Ce serait une lourde erreur de croire que l'utilisation des interprètes de commandes en mode text  est
%dépassée. Leur usage demande certes plus de travail au départ que l'utilisation d'un shell
%graphique. Mais c'est l'une des façons les plus productives de faire exécuter des tâches à un
%ordinateur et pour l'administrateur d'un système, c'est bien souvent un outil indispensable.
%\end{warn}
%\end{minipage}
%\end{figure}

%\subsubsection{En mode graphique}

\vspace{.25cm}

Le mode graphique semble beaucoup plus accueillant pour quelqu'un venant de Windows. 
Il y a plusieurs modes graphiques, tous les modes graphiques sont basés sur un programme appelé X. On parle aussi de serveur d'affichage.

\begin{figure}[h]
\begin{minipage}[c]{.33\linewidth}
\begin{center}
\includegraphics[height=3.5cm]{images/unity.jpg}

\textit{Ubuntu}
%\caption{Kbuntu}
%\label{}
%\label{essai1}
\end{center}
\end{minipage} \hfill
\begin{minipage}[c]{.33\linewidth}
\begin{center}
\includegraphics[height=3.5cm]{images/kbuntu.jpg}
%\caption{Kubuntu, basé sur KDE}

\textit{Kubuntu, basé sur KDE}
%\label{}
%\label{essai1}
\end{center}
\end{minipage} \hfill
\begin{minipage}[c]{.33\linewidth}

\begin{center}
\includegraphics[height=3.5cm]{images/xbuntu.jpg}
%\caption{Xubuntu, basé sur XFCE}

\textit{Xubuntu, basé sur XFCE}
%\label{}
%\label{essai1}
\end{center}
\end{minipage} 
\end{figure}

\subsection{Identification des utilisateurs}

Les systèmes d'exploitation Unix comme Microsoft sont multi-utilisateur : chaque utilisateur
dispose d'un identifiant auprès du système (et en général, d’un mot de passe correspondant).

\begin{figure}[h]
\begin{minipage}[c]{.49\linewidth}
\begin{center}
\includegraphics[height=5cm]{images/loginWin.jpg}

\textit{Fenêtre d'identification de Windows}
%\caption{Fenêtre d'identification de Windows}
%\label{}
\end{center}
\end{minipage} \hfill
\begin{minipage}[c]{.49\linewidth}
\begin{center}
\includegraphics[height=5cm]{images/loginLin.jpg}

\textit{Fenêtre d'identification de Linux}
%\label{}
\end{center}
\end{minipage}
\end{figure}

%
%Vous disposez d'un compte Windows avec des droits d'utilisateur limités accessible depuis n’'importe quel ordinateur du lycée sur le réseau Pédagogique.
%\begin{itemize}
%\item login: prénom.nom
%\item mdp: date de naissance au format JJMMAAAA
%\end{itemize}
%
%Vous pouvez dès à présent changer votre mot de passe pour sécuriser l’accès à votre compte.
%
%
%Un compte utilisateur vous à été créé dans le système informatique, auquel est associé un identifiant,
%et un mot de passe. 
%De plus vous avez été déclaré comme
%étant membre d'un ou plusieurs groupes d'utilisateurs, ce qui va vous donner certains droits
%vis-à-vis du système informatique. 


%
%\subsection{Shell et interface graphique}
%
%Après avoir reconnu l'identifiant et le mot de passe comme valide le système
%d'exploitation lance un programme (ou un ensemble de programmes)
%qu'on appelle parfois shell. 
%Il existe aussi des shells en mode texte, on les appelle alors aussi interprètes de commandes :
%ce sont des programmes qui attendent une commande de l'utilisateur sous forme d'une
%ligne de texte, l'exécutent, attendent de nouveau une commande, l'exécutent, etc. Ils étaient
%historiquement utilisés sur des terminaux en mode texte, c'est-à-dire, une combinaison
%d’un clavier et d’un écran incapable d'afficher autre chose que du texte en orange sur fond
%noir (ou en vert sur fond noir). Aujourd'hui, ces terminaux ont quasiment disparu mais tous
%les systèmes Unix proposent des émulateurs de terminaux.
%
%
%\begin{figure}[h]
%\begin{minipage}[c]{.49\linewidth}
%
%Un tel émulateur est présenté
%ici. Les trois commandes pwd, ls et date on été tapé afin d'afficher le nom du répertoire de travail (print working directory), de lister son
%contenu et d'afficher la date et l'heure. Il a ensuite tapé une commande plus compliquée,
%qui permet en une ligne, certes complexe, de savoir combien de fichiers sont présents sur
%l'ordinateur (on peut lire à la suite la réponse de la machine).
%
%\end{minipage} \hfill
%\begin{minipage}[c]{.49\linewidth}
%\begin{center}
%\includegraphics[width=.8\textwidth]{images/shell.jpg}
%\caption{Exemple de shell}
%\label{}
%\label{essai1}
%\end{center}
%\end{minipage}
%\end{figure}



\subsection{La structure des dossiers et fichiers}

Le nombre de fichiers étant généralement élevé, ils sont organisés en une structure arborescente
de répertoires. Du point de vue de l'utilisateur, un répertoire est un ensemble de fichiers et de sous répertoires, désignés par des noms.
%
%\begin{savoir}
%\textsc{SAVOIR-FAIRE Utiliser un système de fichiers}
%
%Dans un système de fichiers préexistant, il faut savoir :
%\begin{itemize}
%\item Se repérer dans l'arborescence. Cela demande de connaître dans les grandes
%lignes la structure du système de fichiers, de savoir retrouver
%son répertoire personnel et d'en connaître également l'organisation.
%\item Se déplacer dans cette arborescence, au moyen des fenêtres d'un shell graphique
%ou d'une commande (cd dans la plupart des systèmes d'exploitation). 
%\end{itemize}
%
%\end{savoir}

Du point de vue conceptuel, un fichier est une séquence finie d'octets, sans signification
a priori : c'est le programme qui lira cette séquence d'octets qui décidera de la façon de
la comprendre. Il peut contenir des données de tout type : texte, son, vidéo et même des
programmes directement exécutables par le processeur (programmes dits « binaires » ou
« en langage machine »).

Les fichiers présents sur le disque dur sont répertoriés dans une ou plusieurs tables, stockées
à un endroit du disque conventionnellement fixé, qui donnent des informations relatives
à ces fichiers, appelées métadonnées, notamment :
\begin{itemize}
\item date de création, de dernière modification, de dernière lecture;
\item taille du fichier;
\item emplacement des données du fichier sur le disque;
\item suivant les systèmes de fichiers employés, un numéro identifiant le fichier, appelé
inode sous Unix.
\end{itemize}

La table des métadonnées est aussi appelée table des inodes. Du point de vue du système d'exploitation, un répertoire est juste un fichier particulier,
qui contient une liste de couples $(n, i)$ où $n$ est un nom de fichier et $i$ l'inode du fichier.
Une information supplémentaire est stockée dans la table des inodes pour indiquer, pour
chaque fichier, s'il s'agit d'un fichier de données ordinaire ou d'un répertoire.


\subsubsection{La racine}

Dans un système de fichiers, il y a toujours ce qu'on appelle une racine, c'est-à-dire un gros dossier de base qui contient tous les autres dossiers et fichiers.

Sous Windows, il y a en fait plusieurs racines. \textit{C:\textbackslash} est la racine de votre disque dur, \textit{D:\textbackslash} est la racine de votre lecteur CD (par exemple).

Sous Linux, il n'y a qu'une et une seule racine : « / ». Il n'y a pas de lettre de lecteur car justement, Linux ne donne pas de nom aux lecteurs comme le fait Windows. Il dit juste « La base, c'est / ».

Il n'y a pas de dossier de plus haut niveau que /, c'est-à-dire qu'il n'existe pas de dossier qui contienne le dossier /. Quand on est à la racine, on ne peut pas remonter en arrière car… on est déjà tout au début.

\subsubsection{Architecture des dossiers}

Sous Windows, un dossier peut être représenté de la manière suivante : \textit{C:\textbackslash Program Files\textbackslash Gimp 2}. On dit que Gimp 2 est un sous-dossier du dossier Program Files, lui-même situé à la racine.

Vous noterez que c'est l'antislash \textbackslash (aussi appelé backslash) qui sert de séparateur aux noms de dossiers. Sous Linux, c'est au contraire le / (slash) qui sert de séparateur.
Il n'y a pas de \textit{C:} sous Linux, la racine (le début) s'appelant juste /.

Le dossier de notre superprogramme ressemblerait plutôt à quelque chose comme cela : \textit{/usr/bin/}. On dit que \textit{bin} est un sous-dossier du dossier \textit{usr}, lui-même situé à la racine.

\begin{figure}[h]
\begin{minipage}[c]{.49\linewidth}
\begin{center}
\includegraphics[width=.9\textwidth]{images/archilin.png}
\textit{Organisation des dossiers de Linux}
\end{center}
\end{minipage} \hfill
\begin{minipage}[c]{.49\linewidth}

Sous Windows, on a l'habitude de trouver souvent les mêmes dossiers à la racine : Documents and Settings, Program Files, Windows… Sous Linux, vous vous en doutez, les dossiers sont complètement différents. 
\newline\newline

Quelques dossiers courants sous linux:
\begin{itemize}
\item \textit{boot} : fichiers permettant le démarrage de Linux;
\item \textit{etc} : fichiers de configuration;
\item \textit{home} : répertoires personnels des utilisateurs. On en a déjà parlé un peu avant : c'est dans ce dossier que vous placerez vos fichiers personnels, à la manière du dossier Mes documents de Windows.
\end{itemize}
\end{minipage}
\end{figure}


\subsubsection{Quelques commandes classiques pour se déplacer dans l'arborescence:}

\begin{itemize}
\item \textit{pwd} : afficher le dossier actuel
\item \textit{ls} : lister les fichiers et dossiers
\item \textit{cd}: changer de dossier
\item \textit{du}: taille occupée par les dossiers
\item \textit{cp} : copier un fichier
\item \textit{mv} : déplacer un fichier
\item \textit{rm} : supprimer des fichiers et dossiers
\item \textit{mkdir} : créer un dossier
\end{itemize}


Ces quelques fonctions peuvent s'avérer nécessaires car elles sont utilisables dans Python pour manipuler les fichiers. 

%Utiliser le joker *

Le symbole * est appelé joker, ou encore wildcard en anglais sous Linux. 

\begin{minipage}[c]{.46\linewidth}
\begin{term}

Le joker vous permet de copier par exemple tous les fichiers image .jpg dans un sous-dossier :
\begin{termi}[h]
cp *.jpg mondossier/
\end{termi}
\end{term}
\end{minipage}\hfill
\begin{minipage}[c]{.46\linewidth}
\begin{term}
Vous pouvez aussi vous en servir pour copier tous les fichiers dont le nom commence par « so » :
\begin{termi}[h]
cp so* mondossier/
\end{termi}
\end{term}
\end{minipage}

\subsection{Droits d’accès}

Les droits d'accès font partie des propriétés d'un fichier. On peut recenser 3 principaux droits pour un fichier : 
\begin{itemize}
\item le droit en lecture (\textit{r -- read}), qui permet à l'utilisateur de lire le contenu du fichier;
\item le droit en écriture (\textit{w -- write}), qui permet à l'utilisateur d'écrire dans le fichier;
\item le droit d'exécution (\textit{x -- execute}), qui permet à l'utilisateur d'exécuter le fichier.
\end{itemize}

Par ailleurs pour un même ordinateur, il peut exister plusieurs utilisateurs. Ces utilisateurs peuvent de plus appartenir à un groupe.

Ainsi il est possible de distribuer des droits à un utilisateur, à un groupe d'utilisateurs ou à tous les utilisateurs.  

\begin{minipage}[c]{.45\linewidth}
\begin{center}
\includegraphics[width=.85\textwidth]{images/droits_win.png}
\end{center}
\end{minipage}\hfill
\begin{minipage}[c]{.45\linewidth}
\begin{center}
\includegraphics[width=.8\textwidth]{images/droits_lin.png}
$$
-\underbrace{rw-}_{1}\underbrace{r--}_{2}\underbrace{r--}_{3}
$$
\begin{itemize}
\item 1 : droits pour l'utilisateur pessoles;
\item 2 : droits pour l'utilisateur user;
\item 3 : droits pour le reste du monde.
\end{itemize}
\end{center}
\end{minipage}

%Vous êtes inscrit dans un groupe associé à la classe dans laquelle vous êtes. Vous avez accès en lecture/écriture dans Poste de travail/groupes au répertoires d'échanges de la classe. C'est données son stockées sur un serveur distant est accessible sur tous les ordinateur du lycée.

\begin{warn}
Toutes les données que ce soit dans votre espace personnel ou sur les serveurs du lycée ne sont stockées qu'a titre provisoire. Il vous appartient de faire des sauvegardes régulières.
\end{warn}


\begin{warn}
Tenter d'accéder aux données d'autrui est considéré comme une atteinte à la vie privée.
\end{warn}

%Chaque entrée de la table des inodes comporte, en plus des métadonnées déjà mentionnées,
%les droits d'accès accordés aux utilisateurs du système. Ces droits, appelés aussi permissions,
%précisent qui a le droit de faire quoi sur le fichier ou le répertoire concerné (lecture/écriture/exécution). Pour
%voir ces permissions, il suffit d'effectuer un clic droit dans le gestionnaire de fichiers sur
%le répertoire, de choisir « Propriétés » dans le menu contextuel qui apparaît alors, puis de
%cliquer sur l’onglet « Permissions ». 


%\subsection{Lancement d'applications}
%
%\begin{savoir}
%\textsc{SAVOIR-FAIRE Lancer des applications}
%
%Pour lancer une application (un programme), on dispose essentiellement de deux
%possibilités :
%\begin{itemize}
%\item Cliquer sur un bouton, un menu ou un fichier du shell graphique. Cette méthode
%est en général à réserver pour des tâches simples ; elle offre l’avantage d’être
%intuitive et donc utilisable même par des utilisateurs débutants.
%\item Taper une commande dans un shell en mode texte. Dès que l'on veut exprimer des
%commandes plus complexes, comme par exemple passer des arguments à un
%programme ou manipuler des fichiers en masse, cette méthode s'avère quasi
%incontournable. Son utilisation est plus ou moins facilitée selon le système
%d'exploitation que l'on utilise.
%\end{itemize}
%
%Une fois que le système a constaté que l'utilisateur avait le droit d'exécution sur le programme,
%il réserve un espace dans la mémoire vive de l'ordinateur pour stocker les instructions
%du programme ainsi que ses données. Il copie le contenu du fichier exécutable en
%mémoire.
%Celui-ci n'est qu'une suite de bits qui codent les instructions dans le langage du processeur
%(on dit que le programme est en langage machine), il peut donc les exécuter en effectuant
%un branchement vers les premières instructions du programme.
%
%Lorsqu'on clique sur le nom ou l'icône d'un fichier, le gestionnaire de fichiers commence
%par déterminer de quel type de fichier il s'agit. Suivant les systèmes, il peut s'appuyer sur
%diverses informations :
%\begin{itemize}
%\item Le nom du fichier et tout particulièrement son suffixe. Ainsi un fichier dont le nom se
%termine par .odt sera t-il identifié comme un fichier OpenDocument (le gestionnaire
%consulte pour cela une table qui associe un type de fichier à chaque suffixe connu).
%\item Le contenu du fichier.
%\item Le fait que l'utilisateur ait ou non le droit d’exécuter ce fichier.
%\item Sur certains systèmes (Mac OS X en particulier) : métadonnées associées au fichier
%donnant son type.
%\end{itemize}
%Puis, une fois le type déterminé, il consulte une table (commune à tout le système ou
%spécifique au gestionnaire de fichiers, commune à tous les utilisateurs ou spécifique à l'utilisateur)
%indiquant à quelle application est associé ce type de fichier. Il lance alors l'application,
%en lui fournissant pour argument (c'est-à-dire comme information supplémentaire)
%le nom du fichier à ouvrir. Là encore, la situation est exactement la même que si on avait
%tapé ooffice nomdufichier dans un shell en mode texte.
%\end{savoir}
%
%
%\begin{savoir}
%\textsc{SAVOIR-FAIRE Écrire un programme et le lancer}
%
%Tout utilisateur peut écrire ses propres programmes. Il existe pour cela essentiellement
%trois possibilités :
%\begin{itemize}
%\item Les écrire en langage machine. C'est une tâche ardue car le langage machine est un
%langage de bas niveau dans lequel il est difficile ou au minimum fastidieux
%d'implanter des idées un tant soit peu complexes.
%\item Utiliser un compilateur. Il s'agit d'un outil traduisant un programme écrit dans un
%langage évolué en un programme en langage machine. Plus précisément, dans
%le cas du langage C par exemple, on pourra ainsi, à partir d'un fichier contenant
%le texte d'un programme C (appelé par exemple hello.c), produire un
%programme en langage machine (appelé par exemple hello).
%\item Faire appel à un interpréteur d'un langage évolué. Un interpréteur est un programme
%exécutable qui va lire le texte d'un programme dans un langage évolué
%pour l'exécuter pas à pas, sans passer par la phase intermédiaire de compilation.
%La compilation demande donc un traitement préliminaire avant de pouvoir exécuter le
%programme que l'on a écrit, mais produit en général des applications efficaces. À l'inverse,
%on peut interpréter un programme immédiatement après l'avoir écrit, mais il aura tendance
%à s'exécuter moins rapidement. \textbf{C'est vers cette solution que l'on va s'orienter au départ.}
%
%\end{itemize}
%
%Le choix entre compilation et interprétation dépend très largement du langage dans lequel
%on programme : certains ne proposent qu'une seule des deux possibilités, d'autres laissent
%le choix. Il existe même des situations intermédiaires où un programme peut être compilé
%dans un langage qui est plus proche du langage machine mais qui doit encore être interprété
%(on parle de bytecode).
%\end{savoir}


\section{Python}


\begin{minipage}[c]{.79\linewidth}

Python est un langage de programmation, dont la première version est sortie en 1991. Créé par Guido van Rossum, il a voyagé du Macintosh de son créateur, qui travaillait à cette époque au Centrum voor Wiskunde en Informatica aux Pays-Bas, jusqu'à se voir associer une organisation à but non lucratif particulièrement dévouée, la Python Software Foundation, créée en 2001. Ce langage a été baptisé ainsi en hommage à la troupe de comiques les « Monty Python ».

\subsection{À quoi peut servir Python ?}
\end{minipage} \hfill
\begin{minipage}[c]{.2\linewidth}
\begin{center}
\includegraphics[width=.99\textwidth]{images/monty.jpg}
%\label{}
\end{center}
\end{minipage}




Python est un langage puissant, relativement facile à apprendre et riche en possibilités. Il est possible d'étendre ses fonctionnalités. On peut aussi appeler des bibliothèques qui aident le développeur à travailler. 

%Dès l'instant où vous l'installez sur votre ordinateur, vous disposez de nombreuses fonctionnalités intégrées au langage que nous allons découvrir tout au long de ce livre.
%Il est, en outre, très facile d'étendre les fonctionnalités existantes, comme nous allons le voir. Ainsi, il existe ce qu'on appelle des bibliothèques qui aident le développeur à travailler sur des projets particuliers. Plusieurs bibliothèques peuvent ainsi être installées pour, par exemple, développer des interfaces graphiques en Python.

Python permet :
\begin{itemize}
\item de réaliser de petits programmes très simples, appelés scripts, chargés d'une mission très précise sur votre ordinateur;
\item des programmes complets, comme des jeux, des suites bureautiques, des logiciels multimédias, des clients de messagerie…
\item des projets très complexes, comme des progiciels (ensemble de plusieurs logiciels pouvant fonctionner ensemble, principalement utilisés dans le monde professionnel).
\end{itemize}

Voici quelques-unes des fonctionnalités offertes par Python et ses bibliothèques :
\begin{itemize}
\item créer des interfaces graphiques ;
\item faire circuler des informations au travers d'un réseau ;
\item dialoguer d'une façon avancée avec votre système d'exploitation ;
\item ...
\end{itemize}

\subsection{ Un langage de programmation interprété}
Python est un langage de programmation interprété, c'est-à-dire comme on l'a spécifié au que les instructions que vous lui envoyez sont « transcrites » en langage machine au fur et à mesure de leur lecture. D'autres langages (comme le C / C++) sont appelés « langages compilés » car, avant de pouvoir les exécuter, un logiciel spécialisé se charge de transformer le code du programme en langage machine. On appelle cette étape la « compilation ». À chaque modification du code, il faut rappeler une étape de compilation.

Les avantages d'un langage interprété sont la simplicité (on ne passe pas par une étape de compilation avant d'exécuter son programme) et la portabilité (un langage tel que Python est censé fonctionner aussi bien sous Windows que sous Linux ou Mac OS, et on ne devrait avoir à effectuer aucun changement dans le code pour le passer d'un système à l'autre). Cela ne veut pas dire que les langages compilés ne sont pas portables, loin de là ! Mais on doit utiliser des compilateurs différents et, d'un système à l'autre, certaines instructions ne sont pas compatibles, voire se comportent différemment.

En contrepartie, un langage compilé se révélera bien plus rapide qu'un langage interprété (la traduction à la volée de votre programme ralentit l'exécution), bien que cette différence tende à se faire de moins en moins sentir au fil des améliorations. De plus, il faudra installer Python sur le système d'exploitation que vous utilisez pour que l'ordinateur puisse comprendre votre code.

\subsection{Différentes versions de Python}

Lors de la création de la Python Software Foundation, en 2001, et durant les années qui ont suivi, le langage Python est passé par une suite de versions que l'on a englobées dans l'appellation Python 2.x (2.3, 2.5, 2.6…). Depuis le 13 février 2009, la version 3.0.1 est disponible. Cette version casse la compatibilité ascendante qui prévalait lors des dernières versions.

%Installation à la maison : https://code.google.com/p/pythonxy/wiki/Downloads?tm=2






\begin{thebibliography}{2}
\bibitem{Tous}{Wack, Conchon, Courant, deFalco, Dowek, Filliatre, Gonnord, Informatique pour tous en classes préparatoires aux grandes écoles, éditions Eyrolles.}
\bibitem{zero}{Apprenez à programmer en Python \url{http://www.siteduzero.com/}.}
\end{thebibliography}
\end{document}


\newpage

\section{Environnement de développement intégré}



\begin{figure}[h]
\begin{minipage}[c]{.79\linewidth}
Afin de faciliter la programmation on va utiliser un environnement de développement intégré.
On appelle environnement de développement intégré (parfois abrégé IDE) un logiciel qui
permet à la fois :
\begin{itemize}
\item d'écrire des programmes dans un éditeur adapté au langage ;
\item d'exécuter les programmes que l'on a écrits ;
\item de corriger des erreurs (déboguer) dans ces programmes ;
\item éventuellement de consulter de la documentation.
\end{itemize}

Il existe de nombreux environnement: IDLE, Eclipse, Emacs ou Vim ...

Nous allons utiliser  Spyder, qui est fourni avec plusieurs
distributions de Python (WinPython ou Python(x,y) sous Windows, via le projet Mac-
Ports sous MacOS, et enfin il existe des paquets pour la plupart des distributions Linux).

\textbf{Démarrer pythonxy puis dans la fenêtre ci-contre cliquer sur Spyder.}


\end{minipage} \hfill
\begin{minipage}[c]{.2\linewidth}

\begin{center}
\includegraphics[width=.99\textwidth]{images/int1.png}
\label{}
\end{center}
\end{minipage}
\end{figure}

\begin{figure}[h]
\begin{minipage}[c]{.49\linewidth}

La fenêtre de Spyder est divisée en trois parties :
\begin{itemize}
\item L'éditeur à gauche, dans lequel on écrira les programmes.
\item L'explorateur en haut à droite, que nous utiliserons essentiellement comme débogueur,
mais qui peut également servir de documentation.
\end{itemize}
La console interactive en bas à droite, dans laquelle s'exécuteront les programmes.
\end{minipage} \hfill
\begin{minipage}[c]{.49\linewidth}
\begin{center}
\includegraphics[width=.9\textwidth]{images/fen.png}
\label{}
\end{center}
\end{minipage}
\end{figure}

\subsection{La console interactive}


\begin{figure}[h]
\begin{minipage}[c]{.69\linewidth}

Aller dans "interpréteurs" puis démarrer un interpréteur Ipython (cf figure ci-contre).
\newline\newline
In [1]:
La dernière ligne, qui commence par In suivi d’un nombre entre crochets, attend que l’on
tape une commande : c’est le mode interactif de Python, où chaque ligne tapée est immédiatement
exécutée. Ainsi, si l’on tape une expression, sa valeur s’affiche.

\end{minipage} \hfill
\begin{minipage}[c]{.3\linewidth}
\begin{center}
\includegraphics[width=.99\textwidth]{images/fen2.jpg}
\label{}
\end{center}
\end{minipage}
\end{figure}


\begin{py}
\begin{python}[h]
In [1]: 2+2
Out[1]: 4
\end{python}
\end{py}




On appelle session de travail une suite d’instructions tapées dans une fenêtre Python interactive
avec les réponses correspondantes. Il est possible d’enregistrer le contenu d’une
session de travail à l’aide de la commande Enregistrer l’historique... accessible par un clic
droit dans la console.


\begin{figure}[h]
\begin{minipage}[c]{.49\linewidth}
Dans ce mode, on peut d’ores et déjà utiliser des variables pour stocker des valeurs. L’affectation
s’écrit avec le symbole = et n’affiche aucune valeur ; mais la variable mémorise la
valeur qu’on lui a donnée et peut être utilisée dans la suite de la session.
\end{minipage} \hfill
\begin{minipage}[c]{.49\linewidth}
\begin{py}
\begin{python}[h]
In [2]: a=2
In [3]: a+a
Out[3]: 4
\end{python}
\end{py}
\end{minipage}
\end{figure}









\begin{figure}[h]
\begin{minipage}[c]{.49\linewidth}
Notons que si l’on utilise dans une expression une variable à laquelle on n'a jamais donné
de valeur, une erreur se produit.
\end{minipage} \hfill
\begin{minipage}[c]{.49\linewidth}
\begin{py}
\begin{python}[h]
In [4]: b+1

Traceback (most recent call last):
File "<ipython console>", line 1, in <module>
NameError: name 'b' is not defined
\end{python}
\end{py}

\end{minipage}
\end{figure}




\begin{rem}

\textsc{Lien avec le shell}

IPython peut également être utilisé comme un terminal système de remplacement. Son comportement par défaut est très familier aux shell Unix.

\begin{py}
\begin{python}[h]
In [1]: pwd
Out[1]: u'C:\\Python27\\lib\\site-packages\\xy'

In [2]: cd ..
C:\\Python27\\lib\\site-packages

In [3]: pwd
Out[3]: u'C:\\Python27\\lib\\site-packages'

In [4]: ls
 Le volume dans le lecteur C s'appelle OS
 Le numéro de série du volume est A65E-3C0C

 Répertoire de C:\\Python27\\lib\\site-packages

01/08/2013  11:11    <REP>          .
01/08/2013  11:11    <REP>          ..
04/05/2013  15:40    <REP>          _markerlib
10/11/2008  19:40            11776  _memimporter.pyd
...
\end{python}
\end{py}

\end{rem}

Enfin il est possible de rappeler une ligne tapée précédemment à l’aide des flèches « haut »
et « bas », et de modifier cette ligne avant de relancer son calcul avec « Entrée ».

À chaque nouvelle session, les valeurs des variables sont perdues ; les instructions précédemment
tapées peuvent toujours être rappelées, mais cela reste peu pratique et on n’imagine
évidemment pas écrire un programme complet de la sorte. Les sessions interactives
sont donc à réserver pour tester très rapidement l’évaluation de quelques expressions que
l’on ne souhaite pas conserver par la suite.

\subsection{L'éditeur}

\begin{figure}[h]
\begin{minipage}[c]{.49\linewidth}
Dès que l’on veut écrire un programme, ou même tout simplement une suite d'instructions
dont on veut garder une trace, on utilise l'éditeur.
\newline\newline \textbf{Écrivons dans celui-ci un premier programme Python.}
\end{minipage} \hfill
\begin{minipage}[c]{.49\linewidth}
\begin{py}
\begin{python}[h]
print("Bonjour !")
x = 42
print(x)
\end{python}
\end{py}
\end{minipage}
\end{figure}

On observe déjà plusieurs différences par rapport au mode interactif :
\begin{itemize}
\item les mots-clés du langage (comme print) et les nombres se colorent pour ressortir sur le
reste du texte.
\item Les chaînes de caractères (entre guillemets) se colorent également.
\item Lorsque l'on tape une parenthèse ouvrante, la parenthèse fermante correspondante se
crée automatiquement ; et lorsque l'on place le curseur à droite d'une parenthèse, celle-ci
se colore en rouge s'il manque la parenthèse correspondante, en vert sinon.
\end{itemize}

Pour que la machine exécute (on dit aussi interprète) les instructions que l’on a tapées,
il faut le lui demander par la commande Exécution du menu du même nom (raccourci
clavier F5). Les instructions sont alors lues et exécutées, et le résultat, lorsqu’il
y en a un, s'affiche dans l'interpréteur interactif.

\begin{savoir}
\textsc{SAVOIR-FAIRE Utiliser un environnement de développement intégré}

Le minimum pour pouvoir utiliser un environnement de développement intégré est
de savoir :
\begin{itemize}
\item Lancer l’IDE
\item Ouvrir et enregistrer les programmes que l’on écrit
\item Exécuter ces programmes
\end{itemize}
\end{savoir}

\subsection{Le débogueur}

La fenêtre située en haut à droite de Spyder possède plusieurs onglets :
\begin{itemize}
\item Inspecteur d'objets permet d'obtenir de l'aide sur un type ou sur une fonction ;
\item Explorateur de variables permet de connaître la valeur de toutes les variables à tout moment
;
\item Explorateur de fichiers permet de parcourir les fichiers Python du système de fichiers.
\end{itemize}


\begin{figure}[h]
\begin{minipage}[c]{.49\linewidth}
Pour chercher une erreur dans un programme, ou tout simplement pour mieux comprendre
son fonctionnement, il peut être utile de l'exécuter pas à pas. Si cela reste faisable de tête
pour des programmes simples, il devient vite beaucoup plus commode de confier cette
tâche à la machine. Voyons comment procéder sur l'exemple ci-contre.
\end{minipage} \hfill
\begin{minipage}[c]{.49\linewidth}
\begin{py}
\begin{python}[h]
x = 10
y = 7
x = x+y
y = x
x = 5 / (x-y)
\end{python}
\end{py}

\end{minipage}
\end{figure}




Après avoir recopié ce programme dans l'éditeur, au lieu de l'exécuter normalement, on
appelle la commande Déboguer du menu Exécution (raccourci Ctrl+F5 ). La première
ligne du programme que l'on a écrit (x=10) est surlignée et recopiée dans l'interpréteur, mais
elle n'est pas encore exécutée : on peut le vérifier en constatant que x n'a pas la valeur 10
dans l'explorateur de variables. 

Pour exécuter cette ligne, on peut cliquer sur le bouton Pas
en avant , ou bien taper n (comme next) dans l'interpréteur. La ligne est alors exécutée, x
prend la valeur 10, et c'est la ligne suivante (y=7) qui est surlignée. On peut ensuite continuer
à exécuter les lignes les unes après les autres et surveiller l'évolution des différentes variables
dans l'explorateur.

Comme il peut être malcommode de devoir cliquer sur un bouton pour chaque ligne du
programme alors que seules certaines posent problème, on peut fixer des points d'arrêts dans
le programme. Pour cela, on se place sur la ligne à laquelle on désire faire une pause dans
l'exécution du programme, et on choisit Ajouter un point d'arrêt dans le menu Exécution
(raccourci F12). On peut également double-cliquer dans la marge gauche du programme ;
un symbole s'affiche alors en face de cette ligne. Par exemple, dans le programme ci-avant,
il peut être judicieux de placer un point d'arrêt à la dernière ligne, dans laquelle risque de
se produire une division par zéro.

Désormais, si au lieu d'effectuer un Pas en avant, on choisit Continuer ( ou c dans l'interpréteur
interactif), le programme s'exécute normalement jusqu'au prochain point d'arrêt,
puis attend une commande de l'utilisateur pour continuer à s'exécuter. Dans cet exemple,
on voit dans l'explorateur de variables que x et y contiennent toutes deux la valeur 17 et qu'il
y aura donc effectivement une division par zéro.

\begin{savoir}
\textsc{SAVOIR-FAIRE Utiliser un débogueur}
Pour corriger une erreur dans un programme,
\begin{itemize}
\item on détermine les variables qui ne se comportent pas comme prévu
\item on localise l'erreur au moyen d'une exécution pas à pas
\end{itemize}
Dans le cas d'un programme de taille trop importante pour une exécution pas à pas
complète, on veillera à placer des points d'arrêt aux endroits critiques, c'est-à-dire les
opérations arithmétiques pouvant produire des erreurs, les fins de boucles, certains
tests...
\end{savoir}



\begin{exercice}
\textsc{Exercice } Cet exercice a pour seul but de s'entraîner à manipuler l'environnement de développement
intégré, il n'est pas nécessaire de savoir déjà programmer en Python pour le réaliser.
\begin{itemize}
\item Taper le programme suivant dans l'éditeur et l'exécuter. Que se passe-t-il ?
\begin{py}
\begin{python}[h]
i = 10
while i != 0 :
i = 1-i
print(i)
\end{python}
\end{py}
(Il est possible qu'à ce stade il soit nécessaire de fermer complètement l’IDE et de le rouvrir pour
continuer...)
\item Exécuter ce programme pas à pas et observer les valeurs successives prises par la variable i. \item Expliquer
le comportement observé à la première question.
\item Placer un point d'arrêt à un endroit approprié du programme pour montrer son comportement
sans avoir besoin de détailler des étapes inutiles.
\end{itemize}
\end{exercice}


















