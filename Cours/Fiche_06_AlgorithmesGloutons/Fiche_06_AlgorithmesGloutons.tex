\section{Présentation}

\begin{defi} \footnotesize \textbf{\textsf{Problème d'optimisation}} \normalsize
Un problème d'optimisation est un problème dans lequel on souhaite minimiser (ou maximiser) une fonction dépendant d'un jeu de paramètres. 
\end{defi}

\begin{exemple} ~\\

\vspace{-.5cm}

\textbf{Problème du rendu de monnaie} 

Supposons qu'un commerçant doit rendre 24,95 \euro à un client. Il dispose de pièces et de billets d'une valeur de 100, 50, 20, 10, 5, 2, 1, 0,50, 0,20, 0,10, 0,05, 0,02, 0,01 \euro. Quelle(s) combinaison(s) de billets et de pièces permet(tent) de rendre le moins de billets et de pièces au client ?

\textbf{Problème du sac à dos} 

Supposons qu'on doit remplir un sac à dos ayant une capacité limitée (\SI{15}{kg}). Pour remplir ce sac on dispose de différentes boîtes de masses et de valeurs données (\SI{1}{kg} -- 1\euro, \SI{2}{kg} -- 1\euro, \SI{1}{kg} -- 2\euro,  \SI{4}{kg} -- 10\euro, \SI{10}{kg} -- 4\euro). Comment remplir le sac pour maximiser la valeur tranpsortée ?

\end{exemple}


Pour résoudre des problèmes d'optimisation, il existe différentes straégies. On peut par exemple opter pour la \textbf{force brute}. Dans ce cas, en recherche l'ensemble des combinaisons de paramètres d'entrée permettant de répondre à l'objectif. 
Parmi l'ensemble des solutions déterminées, on recherche celle(s) qui répond(ent) << le mieux >> à l'objectif.

Ce type de résolution présente un inconvénient majeur : suivant le type de problème, l'évaluation de l'ensemble des combinaisons peut prendre un temps de calcul très important. 

\begin{defi} \footnotesize \textbf{\textsf{Algorithme gloutons}} \normalsize
Un algorithme glouton permet de trouver un optical local permettant de répondre au problème. Pour cela, à chaque itération de l'algorithme, on va choisir un optimum local.

\begin{itemize}
\item \textbf{Avantage : } facilité de la mise en \oe{}uvre. 
\item \textbf{Inconvénient : } l'optimum trouvé est un optimum local (et pas un optimum global). La solution n'est donc pas forcément la meilleure.
\item \textbf{Situations canoniques :} dans ce cas, le résultat de l'algorithme glouton est l'optimum global. 
\end{itemize}

\end{defi}

\begin{exemple} ~\\

\vspace{-.5cm}

\textbf{Problème du rendu de monnaie} 

On souhaite rendre 31\euro avec des pièces de 22, 10, et 1\euro. L'algorithme glouton proposera 1 pièce de 22\euro et 9 pièces de 1\euro. Or la solution optimale est 3 pièces de 10\euro et 1 pièce d'1\euro.

Le fait d'avoir des pièces de 20, 10, 5, 2 et 1\euro (comme dans notre système monétaire) permet à l'algorithme glouton de donner la solution optimale. La situation est canonique.
\end{exemple}

%
%\begin{lstlisting}
%def foo(v:int) -> int:
%    r = 0
%    n = 0
%    while r < v : 
%        n = n+1
%        r = r+n
%    return n
%\end{lstlisting}
%Puisqu’à la sortie de la boucle $m = a$, on a bien $p = ab$.