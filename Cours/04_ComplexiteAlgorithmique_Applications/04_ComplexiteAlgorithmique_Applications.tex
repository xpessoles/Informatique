%\setchapterimage{bandeau}
\chapter*{TD \arabic{cptTD} \\ 
Calculs de complexité -- 
\ifprof Corrigé \else Sujet \fi}
\addcontentsline{toc}{section}{TD \arabic{cptTD} :
Calculs de complexité -- 
\ifprof Corrigé \else Sujet \fi}

\iflivret \stepcounter{cptTD} \else
\ifprof  \stepcounter{cptTD} \else \fi
\fi

\setcounter{question}{0}
%\marginnote{Sources}
%\marginnote[1cm]{
%\UPSTIcompetence[2]{C1-02}
%\UPSTIcompetence[2]{C2-04}}





\question{Donner la complexité temporelle, dans le pire des cas et dans le meilleur des cas, de l'algorithme suivant.}
\begin{lstlisting}
def f(L):
    x = 0
    for i in range(len(L)) :
        for j in range(len(L[0])) :
            x = x+1
    return x
\end{lstlisting}
\ifprof
\begin{corrige}
$\mathcal{O}(n\times m)$
\end{corrige}
\else
\fi



\question{Donner la complexité temporelle, dans le pire des cas et dans le meilleur des cas, de l'algorithme suivant.}
\begin{lstlisting}
def f2(n) :
    x = 0
    for i in range (n) :
        for j in range (i) :
            x += 1
    return x
\end{lstlisting}
\ifprof
\begin{corrige}
$\mathcal{O}(n^2)$

Pour montrer ce résultat, on pourrait compter le nombre d'incrémentations de $x$ :
\begin{itemize}
\item la boucle intérieure itère $\sum_{j=0}^{j=i} 1 = i$;
\item cette boucle itère $\sum\limits_{i=0}^{i=n} i = \dfrac{n\left(n+1\right)}{2} $.
\end{itemize}
D'où le résultat.
\end{corrige}
\else
\fi



\question{Donner la complexité temporelle, dans le pire des cas et dans le meilleur des cas, de l'algorithme suivant.}
\begin{lstlisting}
def f3(n) :
    x, i = 0 , n
    while i > 1:
        x += 1
        i //= 2
    return x
\end{lstlisting}
\ifprof
\begin{corrige}
$\mathcal{O}(\log n)$
\end{corrige}
\else
\fi



\question{Donner la complexité temporelle, dans le pire des cas et dans le meilleur des cas, de l'algorithme suivant.}
\begin{lstlisting}
def f4(n) :
    x, i = 0 , n
    while i > 1:
        for j in range (n) :
            x += 1
        i //= 2
    return x
\end{lstlisting}
\ifprof
\begin{corrige}
$\mathcal{O}(n \log n)$
\end{corrige}
\else
\fi



\question{Donner la complexité temporelle, dans le pire des cas et dans le meilleur des cas, de l'algorithme suivant.}
\begin{lstlisting}
f5(n) :
    x, i = 0 , n
    while i > 1:
        for j in range (i) :
            x += 1
        i //= 2
    return x
\end{lstlisting}
\ifprof
\begin{corrige}
$\mathcal{O}( n)$
\end{corrige}
\else
\fi



\question{Donner la complexité temporelle, dans le pire des cas et dans le meilleur des cas, de l'algorithme suivant.}
\begin{lstlisting}
def f6(n) :
    x = 0
    for i in range (n) :
        j = 0
        while j * j < i:
            x += 1
            j += 1
    return x
\end{lstlisting}
\ifprof
\begin{corrige}
$\mathcal{O}( n\sqrt{n})$


La boucle \lstinline{while} s'exécute tant que $j^2<i$. Il y a donc approximativement $\sqrt{n}$ tours de boucle \lstinline{while}. 
La boucle \lstinline{for} s'exécute $n$ fois.
\end{corrige}
\else

\fi

